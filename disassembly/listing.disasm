Disassembly Listing for C32MX_Servo
Generated From:
E:/EDocuments/Code/32MX4/C32MX_Servo.X/dist/default/production/C32MX_Servo.X.production.elf
Aug 28, 2022 9:18:08 AM

---  e:/edocuments/code/32mx4/c32mx_servo.x/main.c  -----------------------------------------------------
1:                   /*
2:                    * File:   main.c
3:                    * Author: Chris
4:                    *
5:                    * Created on August 24, 2022, 10:36 PM
6:                    *
7:                    * This demo will be using a single Injora INJO025-270 servo
8:                    * 330 Hz (3030.3us) pulse: 1500us center, 500us min, 2500us max. 4us dead-zone
9:                    * operating at 4.8-6.0 VDC
10:                   */
11:                  
12:                  #define _SUPPRESS_PLIB_WARNING
13:                  
14:                  #include <xc.h>
15:                  #include <p32xxxx.h>
16:                  #include <peripheral/int.h>
17:                  #include <lega-c/peripheral/system.h>
18:                  #include <peripheral/adc10.h>
19:                  
20:                  #include "stdtypes.h"
21:                  #include "Cerebot32MX4.h"
22:                  
23:                  #define servo_period_100us 30303
24:                  #define servo_neutral_us 15000
25:                  #define servo_lowest_us 5000
26:                  #define servo_highest_us 25000
27:                  
28:                  /* ------------------------------------------------------------ */
29:                  /*				Global Variables								*/
30:                  /* ------------------------------------------------------------ */
31:                  volatile unsigned int change_delay;
32:                  volatile unsigned int change_amount; // servo movements, in main
33:                  int dir;
34:                  /* ------------------------------------------------------------ */
35:                  /*				Set Up of System Clock							*/
36:                  /* ------------------------------------------------------------ */
37:                  // Configuration Bit settings for System Clock = 80 MHz
38:                  //  Primary Osc w/PLL (XT+,HS+,EC+PLL)
39:                  //  Input Divider	2x Divider
40:                  //	Multiplier		18x Multiplier
41:                  //  WDT disabled
42:                  //  Other options are don't cares
43:                  
44:                  #define F_CPU 80000000L
45:                  
46:                  /* ------------------------------------------------------------ */
47:                  /*				Forward Declarations							*/
48:                  /* ------------------------------------------------------------ */
49:                  void deviceInit(void);
50:                  void appInit(void);
51:                  static void changeServoPeriod(void);
52:                  void Wait_ms(WORD delay);
53:                  uint32_t mapToPR(uint32_t);
54:                  
55:                  /* ------------------------------------------------------------ */
56:                  /*				Interrupt Service Routines						*/
57:                  
58:                  /* ------------------------------------------------------------ */
59:                  void
60:                  __ISR(_TIMER_2_VECTOR, ipl7auto) Timer2Handler(void) {
61:                      OC2R = mapToPR(ADC1BUF0);
62:                      IFS0bits.T2IF = 0;
63:                  }
64:                  
65:                  void
66:                  __ISR(_OUTPUT_COMPARE_2_VECTOR, ipl7auto) OC2_IntHandler(void) {
67:                      IFS0bits.OC2IF = 0;
68:                  
69:                  }
70:                  
71:                  /*
72:                   *  main
73:                   */
74:                  int main(void) {
75:                  
76:                      deviceInit();
77:                      appInit();
78:                  
79:                      while (fTrue) {
80:                          LATBSET = (1 << bnLed1);
81:                          Wait_ms(1000);
82:                  
83:                          LATBCLR = (1 << bnLed1);
84:                          Wait_ms(1000);
85:                      }
86:                  
87:                      return 0;
88:                  }
89:                  
90:                  void deviceInit() {
91:                      SYSTEMConfigPerformance(F_CPU);
92:                  
93:                      //Microchip recommends typing unused pins to ground
94:                      PORTA = 0;
95:                      PORTB = 0;
96:                      PORTC = 0;
97:                      PORTD = 0;
98:                      PORTE = 0;
99:                      PORTF = 0;
100:                     PORTG = 0;
101:                 
102:                     TRISA = 0;
103:                     TRISB = 0;
104:                     TRISC = 0;
105:                     TRISD = 0;
106:                     TRISE = 0;
107:                     TRISF = 0;
108:                     TRISG = 0;
109:                 }
110:                 
111:                 void appInit() {
112:                     // Output Compare 2 setup
113:                     OC2R = 25000;
114:                     OC2CONbits.ON = 0;
115:                     OC2CONbits.OCM0 = 1; // Compare event toggles OCx pin
116:                     OC2CONbits.OCM1 = 0;
117:                     OC2CONbits.OCM2 = 1;
118:                     OC2CONbits.OCTSEL = 0;
119:                     IPC2bits.OC2IP = 7;
120:                     IPC2bits.OC2IS = 3;
121:                     IFS0bits.OC2IF = 0;
122:                     IEC0bits.OC2IE = 1;
123:                 
124:                     // Timer2 setup
125:                     PR2 = servo_period_100us;
126:                     TMR2 = 0;
127:                     T2CONbits.TCKPS = 3; // 011 = 1:8 prescale value
128:                     IPC2bits.T2IP = 7;
129:                     IPC2bits.T2IS = 3;
130:                     IFS0bits.T1IF = 0;
131:                     IEC0bits.T2IE = 1;
132:                 
133:                     //    // Timer3 setup - adc interrupt source
134:                     //    PR3 = 10000;
135:                     //    TMR3 = 0;
136:                     //    T3CONbits.TCKPS = 3; // 011 = 1:8 prescale value
137:                     //    IPC2bits.T2IP = 7;
138:                     //    IPC2bits.T2IS = 3;
139:                     //    IFS0bits.T1IF = 0;
140:                     //    IEC0bits.T2IE = 1;
141:                 
142:                     AD1PCFGbits.PCFG15 = 0; // AN15 is set to analog input
143:                     TRISBSET = (1 << 15); // TRISB 15 is set to input
144:                 
145:                     // AD1CHS: ADC Input Select Register
146:                     // Positive Input Select bits for MUX B
147:                 
148:                 
149:                     AD1CHSbits.CH0NA = 0; // Channel 0 negative input is VR-
150:                     AD1CHSbits.CH0SA = 0xF; // Channel 0 positive input is AN15 [JB-07]
151:                 
152:                     AD1CON1bits.FORM = 0; // Output is 16bit integer format
153:                     AD1CON1bits.SSRC = 0b111; // Internal counter ends sampling and starts conversion (auto convert)
154:                 
155:                     AD1CON2bits.VCFG = 0; // Vdd/Vss are +/- ref
156:                     AD1CON2bits.SMPI = 0; // Conversion is always written to ADC1BUF0
157:                 
158:                     AD1CON3bits.ADCS = 1; // 4 T_pb clks for the conversion clock
159:                     AD1CON3bits.SAMC = 2; //
160:                 
161:                 
162:                     //    T3CONbits.ON = 1;
163:                     AD1CON1bits.ON = 1;
164:                     AD1CON1bits.ASAM = 1;
165:                     T2CONbits.ON = 1; // enable the timer
166:                     OC2CONbits.ON = 1; // enable the output compare
167:                 
168:                     // Begin with the servo signal high
169:                 
170:                     // intialize the global variable setting the speed of movement
171:                     change_delay = 500;
172:                     change_amount = 20000 / change_delay;
173:                     dir = -1;
174:                 
175:                     // Enable multi-vector interrupts.
176:                     INTEnableSystemMultiVectoredInt();
177:                     //    __builtin_enable_interrupts();
178:                 }
179:                 
180:                 static void changeServoPeriod(void) {
181:                 
182:                     change_delay -= 1;
183:                     if (change_delay == 0) {
184:                         dir *= -1;
185:                         change_delay = 500;
186:                         //        T1CONbits.ON = 0;
187:                         //        Wait_ms(1000);
188:                         //        T1CONbits.ON = 1;
189:                     }
190:                     if (dir < 0) {
191:                         OC2R -= change_amount;
192:                     } else {
193:                         OC2R += change_amount;
194:                     }
195:                 
196:                 }
197:                 
198:                 void Wait_ms(WORD delay) {
199:                 
200:                     WORD i;
201:                 
202:                     while (delay > 0) {
203:                 
204:                         for (i = 0; i < 7270; i++) {
205:                             _nop(); //Optimization settings can remove empty loops, fill with nops.
206:                         }//end for
207:                         delay -= 1;
208:                     }//end while
209:                 }//end Wait_ms()
210:                 
211:                 uint32_t mapToPR(uint32_t a) {
212:                     return 20000 * a / 1024 + 5000;
213:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0012A4  415DE800   RDPGPR SP, SP
9D0012A8  401B7000   MFC0 K1, EPC
9D0012AC  401A6002   MFC0 K0, SRSCtl
9D0012B0  27BDFF88   ADDIU SP, SP, -120
9D0012B4  401B6000   MFC0 K1, Status
9D0012B8  AFBA0070   SW K0, 112(SP)
9D0012BC  AFBB0074   SW K1, 116(SP)
9D0012C0  7C1B7844   INS K1, ZERO, 1, 15
9D0012C4  377B1C00   ORI K1, K1, 7168
9D0012C8  409B6000   MTC0 K1, Status
9D0012CC  AFA3001C   SW V1, 28(SP)
9D0012D0  AFA20018   SW V0, 24(SP)
9D0012D4  8FA30070   LW V1, 112(SP)
9D0012D8  3063000F   ANDI V1, V1, 15
9D0012DC  14600012   BNE V1, ZERO, 0x9D001328
9D0012E0  00000000   NOP
9D0012E4  AFBF005C   SW RA, 92(SP)
9D0012E8  AFBE0058   SW FP, 88(SP)
9D0012EC  AFB90054   SW T9, 84(SP)
9D0012F0  AFB80050   SW T8, 80(SP)
9D0012F4  AFAF004C   SW T7, 76(SP)
9D0012F8  AFAE0048   SW T6, 72(SP)
9D0012FC  AFAD0044   SW T5, 68(SP)
9D001300  AFAC0040   SW T4, 64(SP)
9D001304  AFAB003C   SW T3, 60(SP)
9D001308  AFAA0038   SW T2, 56(SP)
9D00130C  AFA90034   SW T1, 52(SP)
9D001310  AFA80030   SW T0, 48(SP)
9D001314  AFA7002C   SW A3, 44(SP)
9D001318  AFA60028   SW A2, 40(SP)
9D00131C  AFA50024   SW A1, 36(SP)
9D001320  AFA40020   SW A0, 32(SP)
9D001324  AFA10014   SW AT, 20(SP)
9D001328  00000000   NOP
9D00132C  00001012   MFLO V0
9D001330  AFA20064   SW V0, 100(SP)
9D001334  00001810   MFHI V1
9D001338  AFA30060   SW V1, 96(SP)
9D00133C  03A0F025   OR FP, SP, ZERO
9D001340  3C02BF81   LUI V0, -16511
9D001344  8C429070   LW V0, -28560(V0)
9D001348  00402025   OR A0, V0, ZERO
9D00134C  0F4006E0   JAL mapToPR
9D001350  00000000   NOP
9D001354  00401825   OR V1, V0, ZERO
9D001358  3C02BF80   LUI V0, -16512
9D00135C  AC433210   SW V1, 12816(V0)
9D001360  3C03BF88   LUI V1, -16504
9D001364  8C621030   LW V0, 4144(V1)
9D001368  7C024204   INS V0, ZERO, 8, 1
9D00136C  AC621030   SW V0, 4144(V1)
9D001370  00000000   NOP
9D001374  03C0E825   OR SP, FP, ZERO
9D001378  8FA20064   LW V0, 100(SP)
9D00137C  00400013   MTLO V0
9D001380  8FA30060   LW V1, 96(SP)
9D001384  00600011   MTHI V1
9D001388  8FA20070   LW V0, 112(SP)
9D00138C  3042000F   ANDI V0, V0, 15
9D001390  14400014   BNE V0, ZERO, 0x9D0013E4
9D001394  00000000   NOP
9D001398  8FBF005C   LW RA, 92(SP)
9D00139C  8FBE0058   LW FP, 88(SP)
9D0013A0  8FB90054   LW T9, 84(SP)
9D0013A4  8FB80050   LW T8, 80(SP)
9D0013A8  8FAF004C   LW T7, 76(SP)
9D0013AC  8FAE0048   LW T6, 72(SP)
9D0013B0  8FAD0044   LW T5, 68(SP)
9D0013B4  8FAC0040   LW T4, 64(SP)
9D0013B8  8FAB003C   LW T3, 60(SP)
9D0013BC  8FAA0038   LW T2, 56(SP)
9D0013C0  8FA90034   LW T1, 52(SP)
9D0013C4  8FA80030   LW T0, 48(SP)
9D0013C8  8FA7002C   LW A3, 44(SP)
9D0013CC  8FA60028   LW A2, 40(SP)
9D0013D0  8FA50024   LW A1, 36(SP)
9D0013D4  8FA40020   LW A0, 32(SP)
9D0013D8  8FA3001C   LW V1, 28(SP)
9D0013DC  8FA20018   LW V0, 24(SP)
9D0013E0  8FA10014   LW AT, 20(SP)
9D0013E4  00000000   NOP
9D0013E8  8FBB0074   LW K1, 116(SP)
9D0013EC  8FBA0070   LW K0, 112(SP)
9D0013F0  27BD0078   ADDIU SP, SP, 120
9D0013F4  409A6002   MTC0 K0, SRSCtl
9D0013F8  41DDE800   WRPGPR SP, SP
9D0013FC  409B6000   MTC0 K1, Status
9D001400  42000018   ERET
9D001404  415DE800   RDPGPR SP, SP
9D001408  401B7000   MFC0 K1, EPC
9D00140C  401A6002   MFC0 K0, SRSCtl
9D001410  27BDFFE0   ADDIU SP, SP, -32
9D001414  401B6000   MFC0 K1, Status
9D001418  AFBA0018   SW K0, 24(SP)
9D00141C  AFBB001C   SW K1, 28(SP)
9D001420  7C1B7844   INS K1, ZERO, 1, 15
9D001424  377B1C00   ORI K1, K1, 7168
9D001428  409B6000   MTC0 K1, Status
9D00142C  AFA30008   SW V1, 8(SP)
9D001430  AFA20004   SW V0, 4(SP)
9D001434  8FA30018   LW V1, 24(SP)
9D001438  3063000F   ANDI V1, V1, 15
9D00143C  AFBE000C   SW FP, 12(SP)
9D001440  00000000   NOP
9D001444  03A0F025   OR FP, SP, ZERO
9D001448  3C03BF88   LUI V1, -16504
9D00144C  8C621030   LW V0, 4144(V1)
9D001450  7C025284   INS V0, ZERO, 10, 1
9D001454  AC621030   SW V0, 4144(V1)
9D001458  00000000   NOP
9D00145C  03C0E825   OR SP, FP, ZERO
9D001460  8FA20018   LW V0, 24(SP)
9D001464  3042000F   ANDI V0, V0, 15
9D001468  14400004   BNE V0, ZERO, 0x9D00147C
9D00146C  00000000   NOP
9D001470  8FBE000C   LW FP, 12(SP)
9D001474  8FA30008   LW V1, 8(SP)
9D001478  8FA20004   LW V0, 4(SP)
9D00147C  00000000   NOP
9D001480  8FBB001C   LW K1, 28(SP)
9D001484  8FBA0018   LW K0, 24(SP)
9D001488  27BD0020   ADDIU SP, SP, 32
9D00148C  409A6002   MTC0 K0, SRSCtl
9D001490  41DDE800   WRPGPR SP, SP
9D001494  409B6000   MTC0 K1, Status
9D001498  42000018   ERET
9D00149C  27BDFFE8   ADDIU SP, SP, -24
9D0014A0  AFBF0014   SW RA, 20(SP)
9D0014A4  AFBE0010   SW FP, 16(SP)
9D0014A8  03A0F025   OR FP, SP, ZERO
9D0014AC  0F40053D   JAL deviceInit
9D0014B0  00000000   NOP
9D0014B4  0F400601   JAL appInit
9D0014B8  00000000   NOP
9D0014BC  3C02BF88   LUI V0, -16504
9D0014C0  24030400   ADDIU V1, ZERO, 1024
9D0014C4  AC436068   SW V1, 24680(V0)
9D0014C8  240403E8   ADDIU A0, ZERO, 1000
9D0014CC  0F4006C4   JAL Wait_ms
9D0014D0  00000000   NOP
9D0014D4  3C02BF88   LUI V0, -16504
9D0014D8  24030400   ADDIU V1, ZERO, 1024
9D0014DC  AC436064   SW V1, 24676(V0)
9D0014E0  240403E8   ADDIU A0, ZERO, 1000
9D0014E4  0F4006C4   JAL Wait_ms
9D0014E8  00000000   NOP
9D0014EC  1000FFF3   BEQ ZERO, ZERO, main
9D0014F0  00000000   NOP
9D0014F4  27BDFFA0   ADDIU SP, SP, -96
9D0014F8  AFBF005C   SW RA, 92(SP)
9D0014FC  AFBE0058   SW FP, 88(SP)
9D001500  03A0F025   OR FP, SP, ZERO
9D001504  3C0204C4   LUI V0, 1220
9D001508  3442B400   ORI V0, V0, -19456
9D00150C  AFC20010   SW V0, 16(FP)
9D001510  8FC20010   LW V0, 16(FP)
9D001514  AFC20014   SW V0, 20(FP)
9D001518  8FC20014   LW V0, 20(FP)
9D00151C  AFC20018   SW V0, 24(FP)
9D001778  3C02BF88   LUI V0, -16504
9D00177C  AC406010   SW ZERO, 24592(V0)
9D001780  3C02BF88   LUI V0, -16504
9D001784  AC406050   SW ZERO, 24656(V0)
9D001788  3C02BF88   LUI V0, -16504
9D00178C  AC406090   SW ZERO, 24720(V0)
9D001790  3C02BF88   LUI V0, -16504
9D001794  AC4060D0   SW ZERO, 24784(V0)
9D001798  3C02BF88   LUI V0, -16504
9D00179C  AC406110   SW ZERO, 24848(V0)
9D0017A0  3C02BF88   LUI V0, -16504
9D0017A4  AC406150   SW ZERO, 24912(V0)
9D0017A8  3C02BF88   LUI V0, -16504
9D0017AC  AC406190   SW ZERO, 24976(V0)
9D0017B0  3C02BF88   LUI V0, -16504
9D0017B4  AC406000   SW ZERO, 24576(V0)
9D0017B8  3C02BF88   LUI V0, -16504
9D0017BC  AC406040   SW ZERO, 24640(V0)
9D0017C0  3C02BF88   LUI V0, -16504
9D0017C4  AC406080   SW ZERO, 24704(V0)
9D0017C8  3C02BF88   LUI V0, -16504
9D0017CC  AC4060C0   SW ZERO, 24768(V0)
9D0017D0  3C02BF88   LUI V0, -16504
9D0017D4  AC406100   SW ZERO, 24832(V0)
9D0017D8  3C02BF88   LUI V0, -16504
9D0017DC  AC406140   SW ZERO, 24896(V0)
9D0017E0  3C02BF88   LUI V0, -16504
9D0017E4  AC406180   SW ZERO, 24960(V0)
9D0017E8  00000000   NOP
9D0017EC  03C0E825   OR SP, FP, ZERO
9D0017F0  8FBF005C   LW RA, 92(SP)
9D0017F4  8FBE0058   LW FP, 88(SP)
9D0017F8  27BD0060   ADDIU SP, SP, 96
9D0017FC  03E00008   JR RA
9D001800  00000000   NOP
9D001804  27BDFFE8   ADDIU SP, SP, -24
9D001808  AFBF0014   SW RA, 20(SP)
9D00180C  AFBE0010   SW FP, 16(SP)
9D001810  03A0F025   OR FP, SP, ZERO
9D001814  3C02BF80   LUI V0, -16512
9D001818  240361A8   ADDIU V1, ZERO, 25000
9D00181C  AC433210   SW V1, 12816(V0)
9D001820  3C03BF80   LUI V1, -16512
9D001824  94623200   LHU V0, 12800(V1)
9D001828  7C027BC4   INS V0, ZERO, 15, 1
9D00182C  A4623200   SH V0, 12800(V1)
9D001830  3C03BF80   LUI V1, -16512
9D001834  90623200   LBU V0, 12800(V1)
9D001838  24040001   ADDIU A0, ZERO, 1
9D00183C  7C820004   INS V0, A0, 0, 1
9D001840  A0623200   SB V0, 12800(V1)
9D001844  3C03BF80   LUI V1, -16512
9D001848  90623200   LBU V0, 12800(V1)
9D00184C  7C020844   INS V0, ZERO, 1, 1
9D001850  A0623200   SB V0, 12800(V1)
9D001854  3C03BF80   LUI V1, -16512
9D001858  90623200   LBU V0, 12800(V1)
9D00185C  24040001   ADDIU A0, ZERO, 1
9D001860  7C821084   INS V0, A0, 2, 1
9D001864  A0623200   SB V0, 12800(V1)
9D001868  3C03BF80   LUI V1, -16512
9D00186C  94623200   LHU V0, 12800(V1)
9D001870  7C0218C4   INS V0, ZERO, 3, 1
9D001874  A4623200   SH V0, 12800(V1)
9D001878  3C03BF88   LUI V1, -16504
9D00187C  8C6210B0   LW V0, 4272(V1)
9D001880  24040007   ADDIU A0, ZERO, 7
9D001884  7C82A484   INS V0, A0, 18, 3
9D001888  AC6210B0   SW V0, 4272(V1)
9D00188C  3C03BF88   LUI V1, -16504
9D001890  8C6210B0   LW V0, 4272(V1)
9D001894  24040003   ADDIU A0, ZERO, 3
9D001898  7C828C04   INS V0, A0, 16, 2
9D00189C  AC6210B0   SW V0, 4272(V1)
9D0018A0  3C03BF88   LUI V1, -16504
9D0018A4  8C621030   LW V0, 4144(V1)
9D0018A8  7C025284   INS V0, ZERO, 10, 1
9D0018AC  AC621030   SW V0, 4144(V1)
9D0018B0  3C03BF88   LUI V1, -16504
9D0018B4  8C621060   LW V0, 4192(V1)
9D0018B8  24040001   ADDIU A0, ZERO, 1
9D0018BC  7C825284   INS V0, A0, 10, 1
9D0018C0  AC621060   SW V0, 4192(V1)
9D0018C4  3C02BF80   LUI V0, -16512
9D0018C8  2403765F   ADDIU V1, ZERO, 30303
9D0018CC  AC430820   SW V1, 2080(V0)
9D0018D0  3C02BF80   LUI V0, -16512
9D0018D4  AC400810   SW ZERO, 2064(V0)
9D0018D8  3C03BF80   LUI V1, -16512
9D0018DC  94620800   LHU V0, 2048(V1)
9D0018E0  24040003   ADDIU A0, ZERO, 3
9D0018E4  7C823104   INS V0, A0, 4, 3
9D0018E8  A4620800   SH V0, 2048(V1)
9D0018EC  3C03BF88   LUI V1, -16504
9D0018F0  8C6210B0   LW V0, 4272(V1)
9D0018F4  24040007   ADDIU A0, ZERO, 7
9D0018F8  7C822084   INS V0, A0, 2, 3
9D0018FC  AC6210B0   SW V0, 4272(V1)
9D001900  3C03BF88   LUI V1, -16504
9D001904  8C6210B0   LW V0, 4272(V1)
9D001908  24040003   ADDIU A0, ZERO, 3
9D00190C  7C820804   INS V0, A0, 0, 2
9D001910  AC6210B0   SW V0, 4272(V1)
9D001914  3C03BF88   LUI V1, -16504
9D001918  8C621030   LW V0, 4144(V1)
9D00191C  7C022104   INS V0, ZERO, 4, 1
9D001920  AC621030   SW V0, 4144(V1)
9D001924  3C03BF88   LUI V1, -16504
9D001928  8C621060   LW V0, 4192(V1)
9D00192C  24040001   ADDIU A0, ZERO, 1
9D001930  7C824204   INS V0, A0, 8, 1
9D001934  AC621060   SW V0, 4192(V1)
9D001938  3C03BF81   LUI V1, -16511
9D00193C  94629060   LHU V0, -28576(V1)
9D001940  7C027BC4   INS V0, ZERO, 15, 1
9D001944  A4629060   SH V0, -28576(V1)
9D001948  3C02BF88   LUI V0, -16504
9D00194C  34038000   ORI V1, ZERO, -32768
9D001950  AC436048   SW V1, 24648(V0)
9D001954  3C03BF81   LUI V1, -16511
9D001958  8C629040   LW V0, -28608(V1)
9D00195C  7C02BDC4   INS V0, ZERO, 23, 1
9D001960  AC629040   SW V0, -28608(V1)
9D001964  3C03BF81   LUI V1, -16511
9D001968  8C629040   LW V0, -28608(V1)
9D00196C  2404000F   ADDIU A0, ZERO, 15
9D001970  7C829C04   INS V0, A0, 16, 4
9D001974  AC629040   SW V0, -28608(V1)
9D001978  3C03BF81   LUI V1, -16511
9D00197C  94629000   LHU V0, -28672(V1)
9D001980  7C025204   INS V0, ZERO, 8, 3
9D001984  A4629000   SH V0, -28672(V1)
9D001988  3C03BF81   LUI V1, -16511
9D00198C  94629000   LHU V0, -28672(V1)
9D001990  24040007   ADDIU A0, ZERO, 7
9D001994  7C823944   INS V0, A0, 5, 3
9D001998  A4629000   SH V0, -28672(V1)
9D00199C  3C03BF81   LUI V1, -16511
9D0019A0  94629010   LHU V0, -28656(V1)
9D0019A4  7C027B44   INS V0, ZERO, 13, 3
9D0019A8  A4629010   SH V0, -28656(V1)
9D0019AC  3C03BF81   LUI V1, -16511
9D0019B0  94629010   LHU V0, -28656(V1)
9D0019B4  7C022884   INS V0, ZERO, 2, 4
9D0019B8  A4629010   SH V0, -28656(V1)
9D0019BC  3C02BF81   LUI V0, -16511
9D0019C0  24030001   ADDIU V1, ZERO, 1
9D0019C4  A0439020   SB V1, -28640(V0)
9D0019C8  3C03BF81   LUI V1, -16511
9D0019CC  94629020   LHU V0, -28640(V1)
9D0019D0  24040002   ADDIU A0, ZERO, 2
9D0019D4  7C826204   INS V0, A0, 8, 5
9D0019D8  A4629020   SH V0, -28640(V1)
9D0019DC  3C03BF81   LUI V1, -16511
9D0019E0  94629000   LHU V0, -28672(V1)
9D0019E4  24040001   ADDIU A0, ZERO, 1
9D0019E8  7C827BC4   INS V0, A0, 15, 1
9D0019EC  A4629000   SH V0, -28672(V1)
9D0019F0  3C03BF81   LUI V1, -16511
9D0019F4  94629000   LHU V0, -28672(V1)
9D0019F8  24040001   ADDIU A0, ZERO, 1
9D0019FC  7C821084   INS V0, A0, 2, 1
9D001A00  A4629000   SH V0, -28672(V1)
9D001A04  3C03BF80   LUI V1, -16512
9D001A08  94620800   LHU V0, 2048(V1)
9D001A0C  24040001   ADDIU A0, ZERO, 1
9D001A10  7C827BC4   INS V0, A0, 15, 1
9D001A14  A4620800   SH V0, 2048(V1)
9D001A18  3C03BF80   LUI V1, -16512
9D001A1C  94623200   LHU V0, 12800(V1)
9D001A20  24040001   ADDIU A0, ZERO, 1
9D001A24  7C827BC4   INS V0, A0, 15, 1
9D001A28  A4623200   SH V0, 12800(V1)
9D001A2C  240201F4   ADDIU V0, ZERO, 500
9D001A30  AF828010   SW V0, -32752(GP)
9D001A34  8F828010   LW V0, -32752(GP)
9D001A38  24034E20   ADDIU V1, ZERO, 20000
9D001A3C  0062001B   DIVU V1, V0
9D001A40  004001F4   TEQ V0, ZERO
9D001A44  00001010   MFHI V0
9D001A48  00001012   MFLO V0
9D001A4C  AF828014   SW V0, -32748(GP)
9D001A50  2402FFFF   ADDIU V0, ZERO, -1
9D001A54  AF828018   SW V0, -32744(GP)
9D001A58  0F4007AA   JAL INTEnableSystemMultiVectoredInt
9D001A5C  00000000   NOP
9D001A60  00000000   NOP
9D001A64  03C0E825   OR SP, FP, ZERO
9D001A68  8FBF0014   LW RA, 20(SP)
9D001A6C  8FBE0010   LW FP, 16(SP)
9D001A70  27BD0018   ADDIU SP, SP, 24
9D001A74  03E00008   JR RA
9D001A78  00000000   NOP
9D001A7C  27BDFFF8   ADDIU SP, SP, -8
9D001A80  AFBE0004   SW FP, 4(SP)
9D001A84  03A0F025   OR FP, SP, ZERO
9D001A88  8F828010   LW V0, -32752(GP)
9D001A8C  2442FFFF   ADDIU V0, V0, -1
9D001A90  AF828010   SW V0, -32752(GP)
9D001A94  8F828010   LW V0, -32752(GP)
9D001A98  14400006   BNE V0, ZERO, changeServoPeriod
9D001A9C  00000000   NOP
9D001AA0  8F828018   LW V0, -32744(GP)
9D001AA4  00021023   SUBU V0, ZERO, V0
9D001AA8  AF828018   SW V0, -32744(GP)
9D001AAC  240201F4   ADDIU V0, ZERO, 500
9D001AB0  AF828010   SW V0, -32752(GP)
9D001AB4  8F828018   LW V0, -32744(GP)
9D001AB8  04410009   BGEZ V0, changeServoPeriod
9D001ABC  00000000   NOP
9D001AC0  8F828014   LW V0, -32748(GP)
9D001AC4  3C03BF80   LUI V1, -16512
9D001AC8  8C633210   LW V1, 12816(V1)
9D001ACC  00621823   SUBU V1, V1, V0
9D001AD0  3C02BF80   LUI V0, -16512
9D001AD4  AC433210   SW V1, 12816(V0)
9D001AD8  10000007   BEQ ZERO, ZERO, changeServoPeriod
9D001ADC  00000000   NOP
9D001AE0  8F838014   LW V1, -32748(GP)
9D001AE4  3C02BF80   LUI V0, -16512
9D001AE8  8C423210   LW V0, 12816(V0)
9D001AEC  00621821   ADDU V1, V1, V0
9D001AF0  3C02BF80   LUI V0, -16512
9D001AF4  AC433210   SW V1, 12816(V0)
9D001AF8  00000000   NOP
9D001AFC  03C0E825   OR SP, FP, ZERO
9D001B00  8FBE0004   LW FP, 4(SP)
9D001B04  27BD0008   ADDIU SP, SP, 8
9D001B08  03E00008   JR RA
9D001B0C  00000000   NOP
9D001B10  27BDFFF0   ADDIU SP, SP, -16
9D001B14  AFBE000C   SW FP, 12(SP)
9D001B18  03A0F025   OR FP, SP, ZERO
9D001B1C  00801025   OR V0, A0, ZERO
9D001B20  1000000E   BEQ ZERO, ZERO, 0x9D001B5C
9D001B24  A7C20010   SH V0, 16(FP)
9D001B28  10000005   BEQ ZERO, ZERO, 0x9D001B40
9D001B2C  A7C00000   SH ZERO, 0(FP)
9D001B30  00000040   SSNOP
9D001B34  97C20000   LHU V0, 0(FP)
9D001B38  24420001   ADDIU V0, V0, 1
9D001B3C  A7C20000   SH V0, 0(FP)
9D001B40  97C20000   LHU V0, 0(FP)
9D001B44  2C421C66   SLTIU V0, V0, 7270
9D001B48  1440FFF9   BNE V0, ZERO, 0x9D001B30
9D001B4C  00000000   NOP
9D001B50  97C20010   LHU V0, 16(FP)
9D001B54  2442FFFF   ADDIU V0, V0, -1
9D001B58  A7C20010   SH V0, 16(FP)
9D001B5C  97C20010   LHU V0, 16(FP)
9D001B60  1440FFF1   BNE V0, ZERO, 0x9D001B28
9D001B64  00000000   NOP
9D001B68  00000000   NOP
9D001B6C  03C0E825   OR SP, FP, ZERO
9D001B70  8FBE000C   LW FP, 12(SP)
9D001B74  27BD0010   ADDIU SP, SP, 16
9D001B78  03E00008   JR RA
9D001B7C  00000000   NOP
9D001B80  27BDFFF8   ADDIU SP, SP, -8
9D001B84  AFBE0004   SW FP, 4(SP)
9D001B88  03A0F025   OR FP, SP, ZERO
9D001B8C  AFC40008   SW A0, 8(FP)
9D001B90  8FC30008   LW V1, 8(FP)
9D001B94  00601025   OR V0, V1, ZERO
9D001B98  00021080   SLL V0, V0, 2
9D001B9C  00431021   ADDU V0, V0, V1
9D001BA0  000210C0   SLL V0, V0, 3
9D001BA4  00431023   SUBU V0, V0, V1
9D001BA8  00021100   SLL V0, V0, 4
9D001BAC  00431021   ADDU V0, V0, V1
9D001BB0  00021140   SLL V0, V0, 5
9D001BB4  00021282   SRL V0, V0, 10
9D001BB8  24421388   ADDIU V0, V0, 5000
9D001BBC  03C0E825   OR SP, FP, ZERO
9D001BC0  8FBE0004   LW FP, 4(SP)
9D001BC4  27BD0008   ADDIU SP, SP, 8
9D001BC8  03E00008   JR RA
9D001BCC  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/system.h  ------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000898  27BDFFC0   ADDIU SP, SP, -64
9D00089C  AFBF003C   SW RA, 60(SP)
9D0008A0  AFBE0038   SW FP, 56(SP)
9D0008A4  03A0F025   OR FP, SP, ZERO
9D0008A8  AFC40040   SW A0, 64(FP)
9D0008AC  8FC20040   LW V0, 64(FP)
9D0008B0  AFC20014   SW V0, 20(FP)
9D0008B4  8FC30040   LW V1, 64(FP)
9D0008B8  3C0204C4   LUI V0, 1220
9D0008BC  3442B401   ORI V0, V0, -19455
9D0008C0  0062102B   SLTU V0, V1, V0
9D0008C4  14400008   BNE V0, ZERO, SYSTEMConfigPB
9D0008C8  00000000   NOP
9D0008CC  3C020008   LUI V0, 8
9D0008D0  AFC20010   SW V0, 16(FP)
9D0008D4  8FC20014   LW V0, 20(FP)
9D0008D8  00021042   SRL V0, V0, 1
9D0008DC  AFC20014   SW V0, 20(FP)
9D0008E0  10000002   BEQ ZERO, ZERO, SYSTEMConfigPB
9D0008E4  00000000   NOP
9D0008E8  AFC00010   SW ZERO, 16(FP)
9D0008EC  8FC20010   LW V0, 16(FP)
9D0008F0  AFC20018   SW V0, 24(FP)
9D000A3C  8FC20014   LW V0, 20(FP)
9D000A40  03C0E825   OR SP, FP, ZERO
9D000A44  8FBF003C   LW RA, 60(SP)
9D000A48  8FBE0038   LW FP, 56(SP)
9D000A4C  27BD0040   ADDIU SP, SP, 64
9D000A50  03E00008   JR RA
9D000A54  00000000   NOP
9D000A58  27BDFFE0   ADDIU SP, SP, -32
9D000A5C  AFBF001C   SW RA, 28(SP)
9D000A60  AFBE0018   SW FP, 24(SP)
9D000A64  03A0F025   OR FP, SP, ZERO
9D000A68  AFC40020   SW A0, 32(FP)
9D000A6C  AFC00010   SW ZERO, 16(FP)
9D000A70  10000009   BEQ ZERO, ZERO, SYSTEMConfigWaitStates
9D000A74  00000000   NOP
9D000A78  8FC20010   LW V0, 16(FP)
9D000A7C  24420001   ADDIU V0, V0, 1
9D000A80  AFC20010   SW V0, 16(FP)
9D000A84  8FC30020   LW V1, 32(FP)
9D000A88  3C02FE36   LUI V0, -458
9D000A8C  34423C80   ORI V0, V0, 15488
9D000A90  00621021   ADDU V0, V1, V0
9D000A94  AFC20020   SW V0, 32(FP)
9D000A98  8FC30020   LW V1, 32(FP)
9D000A9C  3C0201C9   LUI V0, 457
9D000AA0  3442C381   ORI V0, V0, -15487
9D000AA4  0062102B   SLTU V0, V1, V0
9D000AA8  1040FFF3   BEQ V0, ZERO, SYSTEMConfigWaitStates
9D000AAC  00000000   NOP
9D000AB0  0F4007DE   JAL INTDisableInterrupts
9D000AB4  00000000   NOP
9D000AB8  AFC20014   SW V0, 20(FP)
9D000ABC  3C02BF88   LUI V0, -16504
9D000AC0  8FC30010   LW V1, 16(FP)
9D000AC4  AC434000   SW V1, 16384(V0)
9D000AC8  8FC40014   LW A0, 20(FP)
9D000ACC  0F4007B7   JAL INTRestoreInterrupts
9D000AD0  00000000   NOP
9D000AD4  00000000   NOP
9D000AD8  03C0E825   OR SP, FP, ZERO
9D000ADC  8FBF001C   LW RA, 28(SP)
9D000AE0  8FBE0018   LW FP, 24(SP)
9D000AE4  27BD0020   ADDIU SP, SP, 32
9D000AE8  03E00008   JR RA
9D000AEC  00000000   NOP
9D000AF0  27BDFFB0   ADDIU SP, SP, -80
9D000AF4  AFBF004C   SW RA, 76(SP)
9D000AF8  AFBE0048   SW FP, 72(SP)
9D000AFC  03A0F025   OR FP, SP, ZERO
9D000B00  AFC40050   SW A0, 80(FP)
9D000B04  8FC20050   LW V0, 80(FP)
9D000B08  AFC2001C   SW V0, 28(FP)
9D000B0C  8FC2001C   LW V0, 28(FP)
9D000B14  8FC3001C   LW V1, 28(FP)
9D000B2C  3C020008   LUI V0, 8
9D000B34  8FC20020   LW V0, 32(FP)
9D000B48  AFC00024   SW ZERO, 36(FP)
9D000C9C  8FC20020   LW V0, 32(FP)
9D000CA0  AFC20014   SW V0, 20(FP)
9D000CA4  AFC00010   SW ZERO, 16(FP)
9D000CA8  10000009   BEQ ZERO, ZERO, SYSTEMConfigWaitStatesAndPB
9D000CAC  00000000   NOP
9D000CB0  8FC20010   LW V0, 16(FP)
9D000CB4  24420001   ADDIU V0, V0, 1
9D000CB8  AFC20010   SW V0, 16(FP)
9D000CBC  8FC30050   LW V1, 80(FP)
9D000CC0  3C02FE36   LUI V0, -458
9D000CC4  34423C80   ORI V0, V0, 15488
9D000CC8  00621021   ADDU V0, V1, V0
9D000CCC  AFC20050   SW V0, 80(FP)
9D000CD0  8FC30050   LW V1, 80(FP)
9D000CD4  3C0201C9   LUI V0, 457
9D000CD8  3442C381   ORI V0, V0, -15487
9D000CDC  0062102B   SLTU V0, V1, V0
9D000CE0  1040FFF3   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D000CE4  00000000   NOP
9D000CE8  0F4007DE   JAL INTDisableInterrupts
9D000CEC  00000000   NOP
9D000CF0  AFC20018   SW V0, 24(FP)
9D000CF4  3C02BF88   LUI V0, -16504
9D000CF8  8FC30010   LW V1, 16(FP)
9D000CFC  AC434000   SW V1, 16384(V0)
9D000D00  8FC40018   LW A0, 24(FP)
9D000D04  0F4007B7   JAL INTRestoreInterrupts
9D000D08  00000000   NOP
9D000D0C  8FC20014   LW V0, 20(FP)
9D000D10  03C0E825   OR SP, FP, ZERO
9D000D14  8FBF004C   LW RA, 76(SP)
9D000D18  8FBE0048   LW FP, 72(SP)
9D000D1C  27BD0050   ADDIU SP, SP, 80
9D000D20  03E00008   JR RA
9D000D24  00000000   NOP
9D000D28  27BDFFA0   ADDIU SP, SP, -96
9D000D2C  AFBF005C   SW RA, 92(SP)
9D000D30  AFBE0058   SW FP, 88(SP)
9D000D34  03A0F025   OR FP, SP, ZERO
9D000D38  AFC40060   SW A0, 96(FP)
9D000D3C  8FC20060   LW V0, 96(FP)
9D000D40  AFC2001C   SW V0, 28(FP)
9D000D44  8FC2001C   LW V0, 28(FP)
9D000D48  AFC20020   SW V0, 32(FP)
9D000D4C  8FC20020   LW V0, 32(FP)
9D000D54  8FC30020   LW V1, 32(FP)
9D000D6C  3C020008   LUI V0, 8
9D000D74  8FC20024   LW V0, 36(FP)
9D000D88  AFC00028   SW ZERO, 40(FP)
9D000EDC  8FC20024   LW V0, 36(FP)
9D000EE0  AFC20044   SW V0, 68(FP)
9D000EE4  AFC00048   SW ZERO, 72(FP)
9D000EF0  8FC20048   LW V0, 72(FP)
9D000EFC  8FC3001C   LW V1, 28(FP)
9D000F10  8FC3001C   LW V1, 28(FP)
9D000F28  0F4007DE   JAL INTDisableInterrupts
9D000F34  3C02BF88   LUI V0, -16504
9D000F40  8FC4004C   LW A0, 76(FP)
9D000F4C  8FC20044   LW V0, 68(FP)
9D000F50  AFC20010   SW V0, 16(FP)
9D000F54  0F4007DE   JAL INTDisableInterrupts
9D000F58  00000000   NOP
9D000F5C  AFC20014   SW V0, 20(FP)
9D000F60  3C02BF88   LUI V0, -16504
9D000F64  24030040   ADDIU V1, ZERO, 64
9D000F68  AC432004   SW V1, 8196(V0)
9D000F6C  3C02BF88   LUI V0, -16504
9D000F70  8C424000   LW V0, 16384(V0)
9D000F74  AFC20018   SW V0, 24(FP)
9D000F78  8FC20018   LW V0, 24(FP)
9D000F7C  34420030   ORI V0, V0, 48
9D000F80  AFC20018   SW V0, 24(FP)
9D000F84  3C02BF88   LUI V0, -16504
9D000F88  8FC30018   LW V1, 24(FP)
9D000F8C  AC434000   SW V1, 16384(V0)
9D000F90  0F4007D0   JAL CheKseg0CacheOn
9D000F94  00000000   NOP
9D000F98  8FC40014   LW A0, 20(FP)
9D000F9C  0F4007B7   JAL INTRestoreInterrupts
9D000FA0  00000000   NOP
9D000FA4  8FC20010   LW V0, 16(FP)
9D000FA8  03C0E825   OR SP, FP, ZERO
9D000FAC  8FBF005C   LW RA, 92(SP)
9D000FB0  8FBE0058   LW FP, 88(SP)
9D000FB4  27BD0060   ADDIU SP, SP, 96
9D000FB8  03E00008   JR RA
9D000FBC  00000000   NOP
9D000FC0  27BDFFA8   ADDIU SP, SP, -88
9D000FC4  AFBF0054   SW RA, 84(SP)
9D000FC8  AFBE0050   SW FP, 80(SP)
9D000FCC  03A0F025   OR FP, SP, ZERO
9D000FD0  AFC40058   SW A0, 88(FP)
9D000FD4  AFC5005C   SW A1, 92(FP)
9D000FD8  0F4007DE   JAL INTDisableInterrupts
9D000FDC  00000000   NOP
9D000FE0  AFC20010   SW V0, 16(FP)
9D000FE4  3C02BF88   LUI V0, -16504
9D000FE8  24030040   ADDIU V1, ZERO, 64
9D000FEC  AC432004   SW V1, 8196(V0)
9D000FF0  8FC2005C   LW V0, 92(FP)
9D000FF4  30420001   ANDI V0, V0, 1
9D000FF8  1040001D   BEQ V0, ZERO, 0x9D001070
9D000FFC  00000000   NOP
9D001000  8FC20058   LW V0, 88(FP)
9D001004  AFC2001C   SW V0, 28(FP)
9D001008  AFC00020   SW ZERO, 32(FP)
9D001014  8FC20020   LW V0, 32(FP)
9D001020  8FC3001C   LW V1, 28(FP)
9D001034  8FC3001C   LW V1, 28(FP)
9D00104C  0F4007DE   JAL INTDisableInterrupts
9D001058  3C02BF88   LUI V0, -16504
9D001064  8FC40024   LW A0, 36(FP)
9D001070  8FC2005C   LW V0, 92(FP)
9D001074  30420002   ANDI V0, V0, 2
9D001078  10400067   BEQ V0, ZERO, 0x9D001218
9D00107C  00000000   NOP
9D001080  8FC20058   LW V0, 88(FP)
9D001084  AFC20028   SW V0, 40(FP)
9D001088  8FC20028   LW V0, 40(FP)
9D001090  8FC30028   LW V1, 40(FP)
9D0010A4  00000000   NOP
9D0010B0  8FC2002C   LW V0, 44(FP)
9D0010C4  AFC00030   SW ZERO, 48(FP)
9D001218  8FC2005C   LW V0, 92(FP)
9D00121C  30420004   ANDI V0, V0, 4
9D001220  1040000C   BEQ V0, ZERO, 0x9D001254
9D001224  00000000   NOP
9D001228  3C02BF88   LUI V0, -16504
9D00122C  8C424000   LW V0, 16384(V0)
9D001230  AFC20014   SW V0, 20(FP)
9D001234  8FC20014   LW V0, 20(FP)
9D001238  34420030   ORI V0, V0, 48
9D00123C  AFC20014   SW V0, 20(FP)
9D001240  3C02BF88   LUI V0, -16504
9D001244  8FC30014   LW V1, 20(FP)
9D001248  AC434000   SW V1, 16384(V0)
9D00124C  0F4007D0   JAL CheKseg0CacheOn
9D001250  00000000   NOP
9D001254  8FC20058   LW V0, 88(FP)
9D001258  AFC20018   SW V0, 24(FP)
9D00125C  3C02BF81   LUI V0, -16511
9D001260  8C42F000   LW V0, -4096(V0)
9D001264  7C420CC0   EXT V0, V0, 19, 2
9D001268  304200FF   ANDI V0, V0, 255
9D00126C  00401825   OR V1, V0, ZERO
9D001270  8FC20018   LW V0, 24(FP)
9D001274  00621006   SRLV V0, V0, V1
9D001278  AFC20018   SW V0, 24(FP)
9D00127C  8FC40010   LW A0, 16(FP)
9D001280  0F4007B7   JAL INTRestoreInterrupts
9D001284  00000000   NOP
9D001288  8FC20018   LW V0, 24(FP)
9D00128C  03C0E825   OR SP, FP, ZERO
9D001290  8FBF0054   LW RA, 84(SP)
9D001294  8FBE0050   LW FP, 80(SP)
9D001298  27BD0058   ADDIU SP, SP, 88
9D00129C  03E00008   JR RA
9D0012A0  00000000   NOP
9D001520  8FC20018   LW V0, 24(FP)
9D001524  AFC2001C   SW V0, 28(FP)
9D001528  8FC30018   LW V1, 24(FP)
9D00152C  3C0204C4   LUI V0, 1220
9D001530  3442B401   ORI V0, V0, -19455
9D001534  0062102B   SLTU V0, V1, V0
9D001538  14400008   BNE V0, ZERO, 0x9D00155C
9D00153C  00000000   NOP
9D001540  3C020008   LUI V0, 8
9D001544  AFC20020   SW V0, 32(FP)
9D001548  8FC2001C   LW V0, 28(FP)
9D00154C  00021042   SRL V0, V0, 1
9D001550  AFC2001C   SW V0, 28(FP)
9D001554  10000002   BEQ ZERO, ZERO, 0x9D001560
9D001558  00000000   NOP
9D00155C  AFC00020   SW ZERO, 32(FP)
9D001560  8FC20020   LW V0, 32(FP)
9D001564  AFC20024   SW V0, 36(FP)
9D0016B0  8FC2001C   LW V0, 28(FP)
9D0016B4  AFC2003C   SW V0, 60(FP)
9D0016B8  AFC00040   SW ZERO, 64(FP)
9D0016C4  8FC20040   LW V0, 64(FP)
9D0016D0  8FC30014   LW V1, 20(FP)
9D0016E4  8FC30014   LW V1, 20(FP)
9D0016FC  0F4007DE   JAL INTDisableInterrupts
9D001708  3C02BF88   LUI V0, -16504
9D001714  8FC40044   LW A0, 68(FP)
9D001720  8FC2003C   LW V0, 60(FP)
9D001724  AFC20048   SW V0, 72(FP)
9D001728  0F4007DE   JAL INTDisableInterrupts
9D001734  3C02BF88   LUI V0, -16504
9D001740  3C02BF88   LUI V0, -16504
9D00174C  8FC20050   LW V0, 80(FP)
9D001758  3C02BF88   LUI V0, -16504
9D001764  0F4007D0   JAL CheKseg0CacheOn
9D00176C  8FC4004C   LW A0, 76(FP)
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/osc.h  ---------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the “Company”) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company’s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
219:                     oscBits.PBDIV=0;
220:                     oscBits.w|=oscPbDiv;
221:                     OSCCON=oscBits.w;       // write back
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000720  27BDFFD0   ADDIU SP, SP, -48
9D000724  AFBF002C   SW RA, 44(SP)
9D000728  AFBE0028   SW FP, 40(SP)
9D00072C  03A0F025   OR FP, SP, ZERO
9D000730  AFC40030   SW A0, 48(FP)
9D000734  0F4007DE   JAL INTDisableInterrupts
9D000738  00000000   NOP
9D00073C  AFC20010   SW V0, 16(FP)
9D000788  AFC20014   SW V0, 20(FP)
9D00078C  3C02BF81   LUI V0, -16511
9D000790  AC40F230   SW ZERO, -3536(V0)
9D000794  3C02BF81   LUI V0, -16511
9D000798  3C03AA99   LUI V1, -21863
9D00079C  34636655   ORI V1, V1, 26197
9D0007A0  AC43F230   SW V1, -3536(V0)
9D0007A4  3C02BF81   LUI V0, -16511
9D0007A8  3C035566   LUI V1, 21862
9D0007AC  346399AA   ORI V1, V1, -26198
9D0007B0  AC43F230   SW V1, -3536(V0)
9D0007B4  3C02BF81   LUI V0, -16511
9D0007B8  8C42F000   LW V0, -4096(V0)
9D0007BC  AFC20024   SW V0, 36(FP)
9D0007C0  8FC20024   LW V0, 36(FP)
9D0007C4  7C02A4C4   INS V0, ZERO, 19, 2
9D0007C8  AFC20024   SW V0, 36(FP)
9D0007CC  8FC30024   LW V1, 36(FP)
9D0007D0  8FC20030   LW V0, 48(FP)
9D0007D4  00621025   OR V0, V1, V0
9D0007D8  AFC20024   SW V0, 36(FP)
9D0007DC  8FC30024   LW V1, 36(FP)
9D0007E0  3C02BF81   LUI V0, -16511
9D0007E4  AC43F000   SW V1, -4096(V0)
9D0007E8  3C02BF81   LUI V0, -16511
9D0007EC  8C42F000   LW V0, -4096(V0)
9D0007F0  AFC20024   SW V0, 36(FP)
9D0007F4  3C02BF81   LUI V0, -16511
9D0007F8  3C033333   LUI V1, 13107
9D0007FC  34633333   ORI V1, V1, 13107
9D000800  AC43F230   SW V1, -3536(V0)
9D000804  8FC20014   LW V0, 20(FP)
9D000808  AFC20018   SW V0, 24(FP)
9D000870  8FC40010   LW A0, 16(FP)
9D000874  0F4007B7   JAL INTRestoreInterrupts
9D000878  00000000   NOP
9D00087C  00000000   NOP
9D000880  03C0E825   OR SP, FP, ZERO
9D000884  8FBF002C   LW RA, 44(SP)
9D000888  8FBE0028   LW FP, 40(SP)
9D00088C  27BD0030   ADDIU SP, SP, 48
9D000890  03E00008   JR RA
9D000894  00000000   NOP
9D0008F4  0F4007DE   JAL INTDisableInterrupts
9D000948  AFC20024   SW V0, 36(FP)
9D000974  3C02BF81   LUI V0, -16511
9D000980  8FC20030   LW V0, 48(FP)
9D00098C  8FC30030   LW V1, 48(FP)
9D00099C  8FC30030   LW V1, 48(FP)
9D0009A0  3C02BF81   LUI V0, -16511
9D0009A8  3C02BF81   LUI V0, -16511
9D0009B4  3C02BF81   LUI V0, -16511
9D000A30  8FC4001C   LW A0, 28(FP)
9D000B54  0F4007DE   JAL INTDisableInterrupts
9D000BA8  AFC20034   SW V0, 52(FP)
9D000BD4  3C02BF81   LUI V0, -16511
9D000BE0  8FC20040   LW V0, 64(FP)
9D000BEC  8FC30040   LW V1, 64(FP)
9D000BFC  8FC30040   LW V1, 64(FP)
9D000C00  3C02BF81   LUI V0, -16511
9D000C08  3C02BF81   LUI V0, -16511
9D000C14  3C02BF81   LUI V0, -16511
9D000C90  8FC4002C   LW A0, 44(FP)
9D000D94  0F4007DE   JAL INTDisableInterrupts
9D000DE8  AFC20038   SW V0, 56(FP)
9D000E14  3C02BF81   LUI V0, -16511
9D000E20  8FC20050   LW V0, 80(FP)
9D000E2C  8FC30050   LW V1, 80(FP)
9D000E3C  8FC30050   LW V1, 80(FP)
9D000E40  3C02BF81   LUI V0, -16511
9D000E48  3C02BF81   LUI V0, -16511
9D000E54  3C02BF81   LUI V0, -16511
9D000ED0  8FC40030   LW A0, 48(FP)
9D0010D0  0F4007DE   JAL INTDisableInterrupts
9D001124  AFC20040   SW V0, 64(FP)
9D001150  3C02BF81   LUI V0, -16511
9D00115C  8FC2004C   LW V0, 76(FP)
9D001168  8FC3004C   LW V1, 76(FP)
9D001178  8FC3004C   LW V1, 76(FP)
9D00117C  3C02BF81   LUI V0, -16511
9D001184  3C02BF81   LUI V0, -16511
9D001190  3C02BF81   LUI V0, -16511
9D00120C  8FC40038   LW A0, 56(FP)
9D001568  0F4007DE   JAL INTDisableInterrupts
9D0015BC  AFC20030   SW V0, 48(FP)
9D0015E8  3C02BF81   LUI V0, -16511
9D0015F4  8FC20054   LW V0, 84(FP)
9D001600  8FC30054   LW V1, 84(FP)
9D001610  8FC30054   LW V1, 84(FP)
9D001614  3C02BF81   LUI V0, -16511
9D00161C  3C02BF81   LUI V0, -16511
9D001628  3C02BF81   LUI V0, -16511
9D0016A4  8FC40028   LW A0, 40(FP)
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/int.h  ---------------------
1:                   /********************************************************************
2:                    * FileName:        int.h
3:                    * Dependencies:
4:                    * Processor:       PIC32MX
5:                    * Hardware:        N/A
6:                    * Assembler:       N/A
7:                    * Linker:          N/A
8:                    * Company:         Microchip Technology Inc.
9:                    *
10:                   * Software License Agreement:
11:                   * The software supplied herewith by Microchip Technology Incorporated
12:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
13:                   * supplied to you, the Company’s customer, for use solely and
14:                   * exclusively on Microchip PICmicro Microcontroller products. The
15:                   * software is owned by the Company and/or its supplier, and is
16:                   * protected under applicable copyright laws. All rights are reserved.
17:                   * Any use in violation of the foregoing restrictions may subject the
18:                   * user to criminal sanctions under applicable laws, as well as to
19:                   * civil liability for the breach of the terms and conditions of this
20:                   * license.
21:                   *
22:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
23:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
24:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
25:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
26:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
27:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
28:                   *
29:                   * $Id: INT.h,v 1.6 2006/11/07 23:29:45 C12923 Exp $
30:                   * $Name:  $
31:                  
32:                   ********************************************************************/
33:                  
34:                  #ifndef _PIC32INT_HEADER_FILE
35:                  #define _PIC32INT_HEADER_FILE
36:                  
37:                  #ifdef __cplusplus
38:                  extern "C"
39:                    {
40:                  #endif
41:                  
42:                  /*
43:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
44:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
45:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
46:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
47:                  */
48:                  #ifndef _SUPPRESS_PLIB_WARNING
49:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
50:                  #endif
51:                  
52:                  
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  // Section: Includes
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  #include <xc.h>
59:                  #include <sys/attribs.h>
60:                  
61:                  #if defined(__32MX120F064H__) || \
62:                      defined(__32MX130F128H__) || \
63:                      defined(__32MX130F128L__) || \
64:                      defined(__32MX150F256H__) || \
65:                      defined(__32MX150F256L__) || \
66:                      defined(__32MX170F512H__) || \
67:                      defined(__32MX170F512L__) || \
68:                      defined(__32MX230F128H__) || \
69:                      defined(__32MX230F128L__) || \
70:                      defined(__32MX250F256H__) || \
71:                      defined(__32MX250F256L__) || \
72:                      defined(__32MX270F512H__) || \
73:                      defined(__32MX270F512L__) || \
74:                      defined(__32MX530F128H__) || \
75:                      defined(__32MX530F128L__) || \
76:                      defined(__32MX550F256H__) || \
77:                      defined(__32MX550F256L__) || \
78:                      defined(__32MX570F512H__) || \
79:                      defined(__32MX570F512L__)
80:                    #error "Device not supported by legacy interrupt PLIB!"
81:                  #elif (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || defined(__32MXGENERIC__))
82:                    #include <peripheral/int_1xx_2xx.h>
83:                  #elif  ((__PIC32_FEATURE_SET__ >= 300) && (__PIC32_FEATURE_SET__ <= 499))
84:                    #include <peripheral/int_3xx_4xx.h>
85:                  #elif (((__PIC32_FEATURE_SET__ >= 500) && (__PIC32_FEATURE_SET__ <= 799)) || defined (__32MXPOCONO__))
86:                    #include <peripheral/int_5xx_6xx_7xx.h>
87:                  #else
88:                    #error "Device not supported by the interrupt peripheral library"
89:                  #endif
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Legacy Includes
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  #ifndef _PLIB_DISABLE_LEGACY
96:                  #include <peripheral/legacy/int_legacy.h>
97:                  #endif
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 // Section: Constants & Data Types
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 
104:                 // *****************************************************************************
105:                 /* Interrupt Single Vector Shadow Set
106:                 
107:                   Summary:
108:                     Single vector shadow set selector.
109:                 
110:                   Description:
111:                     These definitions can be used enable the use of the shadow set when
112:                     in single vector mode.
113:                 */
114:                 typedef enum
115:                 {
116:                     // Use the the CPU's register set when entering the handler.
117:                     INT_REGISTOR_SET_SELECT_NONE /*DOM-IGNORE-BEGIN*/ = 0 /*DOM-IGNORE-END*/,
118:                     // Use the shadow set when entering the handler
119:                     INT_REGISTOR_SET_SELECT_SS0  /*DOM-IGNORE-BEGIN*/ = (_INTCON_SS0_MASK) /*DOM-IGNORE-END*/
120:                 
121:                 }INT_SV_SS;
122:                 
123:                 // *****************************************************************************
124:                 /* Interrupt Vector Priority
125:                 
126:                   Summary:
127:                     Interrupt vector priority definitions.
128:                 
129:                   Description:
130:                     These definitions can be used to set the priority of an interrupt
131:                     vector.
132:                 */
133:                 typedef enum
134:                 {
135:                     // Interrupt vector priority level of 0, interrupt is disabled.
136:                     INT_PRIORITY_DISABLED /*DOM-IGNORE-BEGIN*/=      0 /*DOM-IGNORE-END*/,
137:                     // Interrupt vector priority level of 1.
138:                     INT_PRIORITY_LEVEL_1  /*DOM-IGNORE-BEGIN*/=      1 /*DOM-IGNORE-END*/,
139:                     // Interrupt vector priority level of 2.
140:                     INT_PRIORITY_LEVEL_2  /*DOM-IGNORE-BEGIN*/=      2 /*DOM-IGNORE-END*/,
141:                     // Interrupt vector priority level of 3.
142:                     INT_PRIORITY_LEVEL_3  /*DOM-IGNORE-BEGIN*/=      3 /*DOM-IGNORE-END*/,
143:                     // Interrupt vector priority level of 4.
144:                     INT_PRIORITY_LEVEL_4  /*DOM-IGNORE-BEGIN*/=      4 /*DOM-IGNORE-END*/,
145:                     // Interrupt vector priority level of 5.
146:                     INT_PRIORITY_LEVEL_5  /*DOM-IGNORE-BEGIN*/=      5 /*DOM-IGNORE-END*/,
147:                     // Interrupt vector priority level of 6.
148:                     INT_PRIORITY_LEVEL_6  /*DOM-IGNORE-BEGIN*/=      6 /*DOM-IGNORE-END*/,
149:                     // Interrupt vector priority level of 7.
150:                     INT_PRIORITY_LEVEL_7  /*DOM-IGNORE-BEGIN*/=      7  /*DOM-IGNORE-END*/
151:                 }INT_PRIORITY;
152:                 
153:                 // *****************************************************************************
154:                 /* Interrupt Vector Sub-priority
155:                 
156:                   Summary:
157:                     Interrupt vector sub-priority definitions.
158:                 
159:                   Description:
160:                     These definitions can be used to set the sub-priority of an interrupt
161:                     vector.
162:                 */
163:                 typedef enum
164:                 {
165:                     // Interrupt vector sub-priority level of 0.
166:                     INT_SUB_PRIORITY_LEVEL_0 /*DOM-IGNORE-BEGIN*/=   0 /*DOM-IGNORE-END*/,
167:                     // Interrupt vector sub-priority level of 1.
168:                     INT_SUB_PRIORITY_LEVEL_1 /*DOM-IGNORE-BEGIN*/=   1 /*DOM-IGNORE-END*/,
169:                     // Interrupt vector sub-priority level of 2.
170:                     INT_SUB_PRIORITY_LEVEL_2 /*DOM-IGNORE-BEGIN*/=   2 /*DOM-IGNORE-END*/,
171:                     // Interrupt vector sub-priority level of 3.
172:                     INT_SUB_PRIORITY_LEVEL_3 /*DOM-IGNORE-BEGIN*/=   3 /*DOM-IGNORE-END*/
173:                 }INT_SUB_PRIORITY;
174:                 
175:                 // *****************************************************************************
176:                 /* Interrupt Enable/Disable
177:                 
178:                   Summary:
179:                     Interrupt enable/disable definitions.
180:                 
181:                   Description:
182:                     These definitions can be used to enable or disable an interrupt.
183:                 */
184:                 typedef enum
185:                 {
186:                     // Disables the interrupt.
187:                     INT_DISABLED /*DOM-IGNORE-BEGIN*/ = 0 /*DOM-IGNORE-END*/,
188:                     // Enables the interrupt.
189:                     INT_ENABLED /*DOM-IGNORE-BEGIN*/  = 1 /*DOM-IGNORE-END*/
190:                 }INT_EN_DIS;
191:                 // *****************************************************************************
192:                 /* Interrupt Temporal Proximity Control
193:                 
194:                   Summary:
195:                     Interrupt Temporal Proximity Control definitions.
196:                 
197:                   Description:
198:                     These definitions can be used to set the interrupt priority of the Interrupt Temporal Proximity Timer.
199:                 */
200:                 typedef enum
201:                 {
202:                     // Temporal Proximity Timer disabled.
203:                     INT_TPC_DISABLE            /*DOM-IGNORE-BEGIN*/=      0x00000700 /*DOM-IGNORE-END*/,
204:                     // Temporal Proximity Timer enable for interupt priority level 1.
205:                     INT_TPC_GROUP_PRI_LEVEL_1  /*DOM-IGNORE-BEGIN*/=      1 /*DOM-IGNORE-END*/,
206:                     // Temporal Proximity Timer enable for interupt priority level 2 and below.
207:                     INT_TPC_GROUP_PRI_LEVEL_2  /*DOM-IGNORE-BEGIN*/=      2 /*DOM-IGNORE-END*/,
208:                     // Temporal Proximity Timer enable for interupt priority level 3 and below.
209:                     INT_TPC_GROUP_PRI_LEVEL_3  /*DOM-IGNORE-BEGIN*/=      3 /*DOM-IGNORE-END*/,
210:                     // Temporal Proximity Timer enable for interupt priority level 4 and below.
211:                     INT_TPC_GROUP_PRI_LEVEL_4  /*DOM-IGNORE-BEGIN*/=      4 /*DOM-IGNORE-END*/,
212:                     // Temporal Proximity Timer enable for interupt priority level 5 and below.
213:                     INT_TPC_GROUP_PRI_LEVEL_5  /*DOM-IGNORE-BEGIN*/=      5 /*DOM-IGNORE-END*/,
214:                     // Temporal Proximity Timer enable for interupt priority level 6 and below.
215:                     INT_TPC_GROUP_PRI_LEVEL_6  /*DOM-IGNORE-BEGIN*/=      6 /*DOM-IGNORE-END*/,
216:                     // Temporal Proximity Timer enable for interupt priority level 7 and below.
217:                     INT_TPC_GROUP_PRI_LEVEL_7  /*DOM-IGNORE-BEGIN*/=      7 /*DOM-IGNORE-END*/
218:                 }INT_TPC_GROUP;
219:                 
220:                 // *****************************************************************************
221:                 /* Interrupt Vector Spacing
222:                 
223:                   Summary:
224:                     Interrupt vector spacing definitions.
225:                 
226:                   Description:
227:                     These definitions can be used to set the core's EBASE vector spacing.
228:                 */
229:                 typedef enum
230:                 {
231:                     // Vector spacing of 32 bytes.
232:                     INT_VS_32  /*DOM-IGNORE-BEGIN*/= 32 /*DOM-IGNORE-END*/,
233:                     // Vector spacing of 64 bytes.
234:                     INT_VS_64  /*DOM-IGNORE-BEGIN*/= 64 /*DOM-IGNORE-END*/,
235:                     // Vector spacing of 128 bytes.
236:                     INT_VS_128  /*DOM-IGNORE-BEGIN*/= 128 /*DOM-IGNORE-END*/,
237:                     // Vector spacing of 256 bytes.
238:                     INT_VS_256  /*DOM-IGNORE-BEGIN*/= 256 /*DOM-IGNORE-END*/,
239:                     // Vector spacing of 512 bytes.
240:                     INT_VS_512  /*DOM-IGNORE-BEGIN*/= 512 /*DOM-IGNORE-END*/
241:                 }INT_VS;
242:                 
243:                 // *****************************************************************************
244:                 /* Interrupt Configuration
245:                 
246:                   Summary:
247:                     Interrupt configuration parameters.
248:                 
249:                   Description:
250:                     These definitions can be used to configure the system interrupt controller.
251:                 */
252:                 typedef enum
253:                 {
254:                     // Configure the interrupt module for Mult-vector mode.
255:                     INT_SYSTEM_CONFIG_MULT_VECTOR,
256:                     // Configure the interrupt module for Single Vectored mode.
257:                     INT_SYSTEM_CONFIG_SINGLE_VECTOR
258:                 }INT_SYSTEM_CONFIG;
259:                 
260:                 // *****************************************************************************
261:                 // *****************************************************************************
262:                 // Section: Interrupt Peripheral Library Interface Routines and Macors
263:                 // *****************************************************************************
264:                 // *****************************************************************************
265:                 
266:                 /*******************************************************************************
267:                   Function:
268:                     unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
269:                 
270:                   Summary:
271:                     Disables the PIC32MX from handling interrupts.
272:                 
273:                   Description:
274:                     This routine disables the core from handling any pending interrupt requests.
275:                 
276:                   Precondition:
277:                     None
278:                 
279:                   Parameters:
280:                     None
281:                 
282:                   Returns:
283:                     The previous state of the CP0 register Status.IE bit.  The INTRestoreInterrupts
284:                     function can be used in other routines to restore the system interrupt state.
285:                 
286:                   Example:
287:                     <code>
288:                     unsigned int intStatus;
289:                 
290:                     intStatus = INTDisableInterrupts();
291:                     </code>
292:                 
293:                   Remarks:
294:                     This function cannot be compiled using the MIPS16 instruction set.
295:                   *****************************************************************************/
296:                 unsigned int __attribute__((nomips16)) INTDisableInterrupts(void);
297:                 
298:                 /*******************************************************************************
299:                   Function:
300:                     unsigned int __attribute__((nomips16))  INTEnableInterrupts(void)
301:                 
302:                   Summary:
303:                     Enables the PIC32MX to handle interrupts.
304:                 
305:                   Description:
306:                     This routine enables the core to handle any pending interrupt requests.
307:                 
308:                   Precondition:
309:                     Need to configure system using INTConfigureSystem
310:                 
311:                   Parameters:
312:                     None
313:                 
314:                   Returns:
315:                     The previous state of the CP0 register Status.IE bit.  The INTRestoreInterrupts
316:                     function can be used in other routines to restore the system interrupt state.
317:                 
318:                   Example:
319:                     <code>
320:                     unsigned int intStatus;
321:                 
322:                     intStatus = INTEnableInterrupts();
323:                     </code>
324:                 
325:                   Remarks:
326:                     This function cannot be compiled using the MIPS16 instruction set.
327:                   *****************************************************************************/
328:                 unsigned int __attribute__((nomips16))  INTEnableInterrupts(void);
329:                 
330:                 /*******************************************************************************
331:                   Function:
332:                     void __attribute__((nomips16))  INTRestoreInterrupts(unsigned int status)
333:                 
334:                   Summary:
335:                     Restores the PIC32MX interrupt state.
336:                 
337:                   Description:
338:                     This routine restores the core to the previous interrupt handling state.
339:                 
340:                   Precondition:
341:                     None
342:                 
343:                   Parameters:
344:                     status      - the state of the CP0 register Status.IE
345:                 
346:                   Returns:
347:                     None
348:                 
349:                   Example:
350:                     <code>
351:                     unsigned int intStatus;
352:                 
353:                     intStatus = INTDisableInterrupts();
354:                 
355:                     // ... application code
356:                 
357:                     INTRestoreInterrupts(intStatus);
358:                     </code>
359:                 
360:                   Remarks:
361:                     This function cannot be compiled using the MIPS16 instruction set.
362:                   *****************************************************************************/
363:                 void __attribute__((nomips16))  INTRestoreInterrupts(unsigned int status);
364:                 
365:                 /*******************************************************************************
366:                   Function:
367:                     void __attribute__ ((nomips16)) INTConfigureSystem(INT_SYSTEM_CONFIG config);
368:                 
369:                   Summary:
370:                     Configures the system for  multi-vector or single vectored interrupts.
371:                 
372:                   Description:
373:                     This routine configures the core to receive interrupt requests and configures the
374:                     Interrupt module for Multi-vectored or Single Vectored mode.
375:                 
376:                   Precondition:
377:                     None
378:                 
379:                   Parameters:
380:                     config      - The interrupt configuration to set.
381:                 
382:                   Returns:
383:                     None
384:                 
385:                   Example:
386:                     Configure for Multi-vectored mode
387:                     <code>
388:                 
389:                     // configure for multi-vectored mode
390:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
391:                 
392:                     // enable interrupts
393:                     INTEnableInterrupts();
394:                 
395:                     // ...
396:                     </code>
397:                 
398:                     Configure for Single Vectored mode
399:                     <code>
400:                 
401:                     // configure for single vectored mode
402:                     INTConfigureSystem(INT_SYSTEM_CONFIG_SINGLE_VECTOR);
403:                 
404:                     // enable interrupts
405:                     INTEnableInterrupts();
406:                 
407:                     // ...
408:                     </code>
409:                 
410:                   Remarks:
411:                     This function cannot be compiled using the MIPS16 instruction set.
412:                   *****************************************************************************/
413:                 void __attribute__ ((nomips16)) INTConfigureSystem(INT_SYSTEM_CONFIG config);
414:                 
415:                 /*******************************************************************************
416:                   Function:
417:                     void __attribute__((nomips16)) INTSetEBASE(unsigned int ebase_address)
418:                 
419:                   Summary:
420:                     Sets the PIC32MX exception base.
421:                 
422:                   Description:
423:                     This routine sets the exception base of the core.
424:                 
425:                   Precondition:
426:                     None
427:                 
428:                   Parameters:
429:                     ebase_address   - The address of the EBASE.
430:                                     * must be be located in KSEG0 or KSEG1
431:                                     * must be 4KB aligned
432:                 
433:                   Returns:
434:                     None
435:                 
436:                   Example:
437:                     <code>
438:                 
439:                     INTSetEBASE(0xBFC01000);
440:                     </code>
441:                 
442:                   Remarks:
443:                     This function cannot be compiled using the MIPS16 instruction set.
444:                   *****************************************************************************/
445:                 void __attribute__((nomips16)) INTSetEBASE(unsigned int ebase_address);
446:                 
447:                 /*******************************************************************************
448:                   Function:
449:                     void __attribute__((nomips16)) INTSetVectorSpacing(INT_VS vector_spacing)
450:                 
451:                   Summary:
452:                     Sets the PIC32MX exception vector spacing.
453:                 
454:                   Description:
455:                     This routine sets the exception vector spacing of the core.
456:                 
457:                   Precondition:
458:                     None
459:                 
460:                   Parameters:
461:                     vector_spacing  - The desired vector spacing.
462:                 
463:                   Returns:
464:                     None
465:                 
466:                   Example:
467:                     <code>
468:                 
469:                     INTSetVectorSpacing(INT_VS_32);
470:                     </code>
471:                 
472:                   Remarks:
473:                     This function cannot be compiled using the MIPS16 instruction set.
474:                   *****************************************************************************/
475:                 void __attribute__((nomips16)) INTSetVectorSpacing(INT_VS vector_spacing);
476:                 
477:                 /*******************************************************************************
478:                   Function:
479:                     extern inline void __attribute__ ((always_inline)) INTSingleVectorRegisterSet(INT_SV_SS reg_set)
480:                 
481:                   Summary:
482:                     Sets the single vectored interrupt handler's general purpose register set.
483:                 
484:                   Description:
485:                     This routine sets the single vectored interrupt handler's general purpose register set.
486:                 
487:                   Precondition:
488:                     The interrupt controller must be set in Single Vectored mode.
489:                 
490:                   Parameters:
491:                     reg_set         - Register set for the single vectored handler.
492:                 
493:                   Returns:
494:                     None
495:                 
496:                   Example:
497:                     <code>
498:                 
499:                     INTSingleVectorRegisterSet(INT_REGISTOR_SET_SELECT_NONE);
500:                     </code>
501:                 
502:                   Remarks:
503:                     None.
504:                   *****************************************************************************/
505:                 extern inline void __attribute__ ((always_inline)) INTSingleVectorRegisterSet(INT_SV_SS reg_set)
506:                 {
507:                     INTCONCLR   = reg_set;
508:                     INTCONSET    = reg_set;
509:                 }
510:                 
511:                 /*******************************************************************************
512:                   Function:
513:                     extern inline unsigned int __attribute__ ((always_inline)) INTGetInterruptVectorNumber(void)
514:                 
515:                   Summary:
516:                     Gets the pending interrupt vector.
517:                 
518:                   Description:
519:                     This routine gets the pending interrupt vector number.
520:                 
521:                   Precondition:
522:                     None
523:                 
524:                   Parameters:
525:                     None
526:                 
527:                   Returns:
528:                     The pending interrupt vector number.
529:                 
530:                   Example:
531:                     <code>
532:                     unsigned int vector_num;
533:                 
534:                     vector_num = INTGetInterruptVectorNumber();
535:                 
536:                     if(vector_num == _CORE_TIMER_VECTOR)
537:                     {
538:                         // ...
539:                     }
540:                     </code>
541:                 
542:                   Remarks:
543:                     The user can refer to the device file to get the vector number defines.
544:                   *****************************************************************************/
545:                 extern inline unsigned int __attribute__ ((always_inline)) INTGetInterruptVectorNumber(void)
546:                 {
547:                     return (unsigned int)(INTSTATbits.VEC);
548:                 }
549:                 /*******************************************************************************
550:                   Function:
551:                     extern inline INT_PRIORITY __attribute__ ((always_inline)) INTGetInterruptVectorPriority(void)
552:                 
553:                   Summary:
554:                     Gets the pending interrupt vector's priority.
555:                 
556:                   Description:
557:                     This routine gets the pending interrupt vector's priority.
558:                 
559:                   Precondition:
560:                     None
561:                 
562:                   Parameters:
563:                     None
564:                 
565:                   Returns:
566:                     The pending interrupt vector's priority.
567:                 
568:                   Example:
569:                     <code>
570:                     INT_PRIORITY vector_pri;
571:                 
572:                     vector_pri = INTGetInterruptVectorPriority();
573:                     </code>
574:                 
575:                   Remarks:
576:                     None.
577:                   *****************************************************************************/
578:                 extern inline INT_PRIORITY __attribute__ ((always_inline)) INTGetInterruptVectorPriority(void)
579:                 {
580:                     return (INT_PRIORITY)(INTSTATbits.SRIPL);
581:                 }
582:                 
583:                 /*******************************************************************************
584:                   Function:
585:                     extern inline void __attribute__ ((always_inline)) INTGetInterruptVectorNumberAndPriority(unsigned int *number, INT_PRIORITY *priority)
586:                 
587:                   Summary:
588:                     Gets the pending interrupt vector number and priority.
589:                 
590:                   Description:
591:                     This routine gets the pending interrupt vector number and priority.
592:                 
593:                   Precondition:
594:                     *number - pointer to the vector number
595:                 
596:                     *priority - pointer to the interrupt priority
597:                 
598:                   Parameters:
599:                     None
600:                 
601:                   Returns:
602:                     The pending interrupt vector's priority.
603:                 
604:                   Example:
605:                     <code>
606:                     INT_PRIORITY vector_pri;
607:                     unsigned int vector_num;
608:                 
609:                     INTGetInterruptVectorNumberAndPriority(&vector_num, &vector_pri);
610:                 
611:                     if(vector_num == _CORE_TIMER_VECTOR)
612:                     {
613:                         // ...
614:                     }
615:                     </code>
616:                 
617:                   Remarks:
618:                     None.
619:                   *****************************************************************************/
620:                 extern inline void __attribute__ ((always_inline)) INTGetInterruptVectorNumberAndPriority(unsigned int *number, INT_PRIORITY *priority)
621:                 {
622:                     *number     = INTSTAT;
623:                     *priority   = (INT_PRIORITY)((*number >> 8) & 7);
624:                     *number     &= 0x3F;
625:                 }
626:                 
627:                 /*******************************************************************************
628:                   Function:
629:                     void INTClearFlag(INT_SOURCE source)
630:                 
631:                   Summary:
632:                     Clears an interrupt request flag.
633:                 
634:                   Description:
635:                     This routine clears an interrupt request flag.
636:                 
637:                   Precondition:
638:                     None
639:                 
640:                   Parameters:
641:                     source  - Interrupt source.
642:                 
643:                   Returns:
644:                     None
645:                 
646:                   Example:
647:                     <code>
648:                     INTClearFlag(INT_CT);
649:                     </code>
650:                 
651:                   Remarks:
652:                     None
653:                   *****************************************************************************/
654:                 void INTClearFlag(INT_SOURCE source);
655:                 
656:                 /*******************************************************************************
657:                   Function:
658:                     void INTSetFlag(INT_SOURCE source)
659:                 
660:                   Summary:
661:                     Sets an interrupt request flag.
662:                 
663:                   Description:
664:                     This routine sets an interrupt request flag.
665:                 
666:                   Precondition:
667:                     None
668:                 
669:                   Parameters:
670:                     source  - Interrupt source.
671:                 
672:                   Returns:
673:                     None
674:                 
675:                   Example:
676:                     <code>
677:                     INTSetFlag(INT_CT);
678:                     </code>
679:                 
680:                   Remarks:
681:                     If the corresponding interrupt enable is set, this routine will cause the
682:                     application to vector to the interrupt's handler.
683:                   *****************************************************************************/
684:                 void INTSetFlag(INT_SOURCE source);
685:                 
686:                 /*******************************************************************************
687:                   Function:
688:                     unsigned int INTGetFlag(INT_SOURCE source)
689:                 
690:                   Summary:
691:                     Gets the interrupt request flag.
692:                 
693:                   Description:
694:                     This routine gets an interrupt request flag.
695:                 
696:                   Precondition:
697:                     None
698:                 
699:                   Parameters:
700:                     source  - Interrupt source.
701:                 
702:                   Returns:
703:                     * 0 if the interrupt request flag is clear
704:                     * 1 if the interrupt request flag is set
705:                 
706:                   Example:
707:                     <code>
708:                     if(INTGetFlag(INT_CT))
709:                     {
710:                         // ... do something
711:                     }
712:                     </code>
713:                 
714:                   Remarks:
715:                     None
716:                   *****************************************************************************/
717:                 unsigned int INTGetFlag(INT_SOURCE source);
718:                 
719:                 /*******************************************************************************
720:                   Function:
721:                     void INTEnable(INT_SOURCE source, INT_EN_DIS enable)
722:                 
723:                   Summary:
724:                     Enables or disables the interrupt.
725:                 
726:                   Description:
727:                     This routine enables or disables the interrupt source.
728:                 
729:                   Precondition:
730:                     None
731:                 
732:                   Parameters:
733:                     source  - Interrupt source.
734:                     enable  - Enable state to set.
735:                 
736:                   Returns:
737:                     None
738:                 
739:                   Example:
740:                     <code>
741:                     INTEnable(INT_CT, INT_ENABLED);
742:                     </code>
743:                 
744:                   Remarks:
745:                     None
746:                   *****************************************************************************/
747:                 void INTEnable(INT_SOURCE source, INT_EN_DIS enable);
748:                 
749:                 /*******************************************************************************
750:                   Function:
751:                     unsigned int INTGetEnable(INT_SOURCE source)
752:                 
753:                   Summary:
754:                     Gets the interrupt enable.
755:                 
756:                   Description:
757:                     This routine gets an interrupt enable.
758:                 
759:                   Precondition:
760:                     None
761:                 
762:                   Parameters:
763:                     source  - Interrupt source.
764:                 
765:                   Returns:
766:                     * 0 if interrupt is disabled
767:                     * else interrupt is enabled
768:                 
769:                   Example:
770:                     <code>
771:                     if(INTGetEnable(INT_CT))
772:                     {
773:                         // ... do something
774:                     }
775:                     </code>
776:                 
777:                   Remarks:
778:                     None
779:                   *****************************************************************************/
780:                 unsigned int INTGetEnable(INT_SOURCE source);
781:                 
782:                 /*******************************************************************************
783:                   Function:
784:                     void INTSetVectorPriority(INT_VECTOR vector, INT_PRIORITY priority)
785:                 
786:                   Summary:
787:                     Sets the interrupt vector's priority.
788:                 
789:                   Description:
790:                     This routine sets the interrupt vector's priority.
791:                 
792:                   Precondition:
793:                     None
794:                 
795:                   Parameters:
796:                     vector    - Interrupt vector.
797:                     priority  - Interrupt vector's priority.
798:                 
799:                   Returns:
800:                     None
801:                 
802:                   Example:
803:                     <code>
804:                     INTSetVectorPriority(INT_CORE_TIMER_VECTOR, INT_PRIORITY_LEVEL_4);
805:                     </code>
806:                 
807:                   Remarks:
808:                     None
809:                   *****************************************************************************/
810:                 void INTSetVectorPriority(INT_VECTOR vector, INT_PRIORITY priority);
811:                 
812:                 /*******************************************************************************
813:                   Function:
814:                     INT_PRIORITY INTGetVectorPriority(INT_VECTOR vector)
815:                 
816:                   Summary:
817:                     Gets the interrupt vector's priority.
818:                 
819:                   Description:
820:                     This routine gets the interrupt vector's priority.
821:                 
822:                   Precondition:
823:                     None
824:                 
825:                   Parameters:
826:                     vector    - Interrupt vector.
827:                 
828:                   Returns:
829:                     interrupt vector's priority
830:                 
831:                   Example:
832:                     <code>
833:                     INT_PRIORITY intPriority;
834:                 
835:                     intPriority = INTGetVectorPriority(INT_CORE_TIMER_VECTOR);
836:                     </code>
837:                 
838:                   Remarks:
839:                     None
840:                   *****************************************************************************/
841:                 INT_PRIORITY INTGetVectorPriority(INT_VECTOR vector);
842:                 
843:                 /*******************************************************************************
844:                   Function:
845:                     void INTSetVectorSubPriority(INT_VECTOR vector, INT_SUB_PRIORITY subPriority)
846:                 
847:                   Summary:
848:                     Sets the interrupt vector's sub-priority.
849:                 
850:                   Description:
851:                     This routine sets the interrupt vector's sub-priority.
852:                 
853:                   Precondition:
854:                     None
855:                 
856:                   Parameters:
857:                     vector          - Interrupt vector.
858:                     subPriority     - Interrupt vector's sub-priority.
859:                 
860:                   Returns:
861:                     None
862:                 
863:                   Example:
864:                     <code>
865:                     INTSetVectorSubPriority(INT_CORE_TIMER_VECTOR, INT_SUB_PRIORITY_LEVEL_1);
866:                     </code>
867:                 
868:                   Remarks:
869:                     None
870:                   *****************************************************************************/
871:                 void INTSetVectorSubPriority(INT_VECTOR vector, INT_SUB_PRIORITY subPriority);
872:                 
873:                 /*******************************************************************************
874:                   Function:
875:                     INT_SUB_PRIORITY INTGetVectorSubPriority(INT_VECTOR vector)
876:                 
877:                   Summary:
878:                     Gets the interrupt vector's priority.
879:                 
880:                   Description:
881:                     This routine gets the interrupt vector's priority.
882:                 
883:                   Precondition:
884:                     None
885:                 
886:                   Parameters:
887:                     vector    - Interrupt vector.
888:                 
889:                   Returns:
890:                     interrupt vector's sub-priority
891:                 
892:                   Example:
893:                     <code>
894:                     INT_SUB_PRIORITY intSubPriority;
895:                 
896:                     intSubPriority = INTGetVectorSubPriority(INT_CORE_TIMER_VECTOR);
897:                     </code>
898:                 
899:                   Remarks:
900:                     None
901:                   *****************************************************************************/
902:                 INT_SUB_PRIORITY INTGetVectorSubPriority(INT_VECTOR vector);
903:                 
904:                 
905:                 /*******************************************************************************
906:                   Function:
907:                     extern inline void __attribute__ ((always_inline)) INTSetIntProximityTimerReload(unsigned int time)
908:                 
909:                   Summary:
910:                     Sets or reloads the interrupt proximity timer.
911:                 
912:                   Description:
913:                     This routine sets or reloads the interrupt proximity timer.
914:                 
915:                   Precondition:
916:                     None
917:                 
918:                   Parameters:
919:                     time            - 32-bit timer value.
920:                 
921:                   Returns:
922:                     None
923:                 
924:                   Example:
925:                     <code>
926:                     INTSetIntProximityTimerReload(56000);
927:                     </code>
928:                 
929:                   Remarks:
930:                     None
931:                   *****************************************************************************/
932:                 extern inline void __attribute__ ((always_inline)) INTSetIntProximityTimerReload(unsigned int time)
933:                 {
934:                     IPTMR = time;
935:                 }
936:                 /*******************************************************************************
937:                   Function:
938:                     extern inline unsigned int __attribute__ ((always_inline)) INTGetIntProximityTimer(void)
939:                 
940:                   Summary:
941:                     Gets the interrupt proximity timer.
942:                 
943:                   Description:
944:                     This routine gets the interrupt proximity timer.
945:                 
946:                   Precondition:
947:                     None
948:                 
949:                   Parameters:
950:                     None
951:                 
952:                   Returns:
953:                     The current tick count of the timer.
954:                 
955:                   Example:
956:                     <code>
957:                     unsigned int time
958:                 
959:                     time = INTGetIntProximityTimer();
960:                     </code>
961:                 
962:                   Remarks:
963:                     None
964:                   *****************************************************************************/
965:                 extern inline unsigned int __attribute__ ((always_inline)) INTGetIntProximityTimer(void)
966:                 {
967:                     return IPTMR;
968:                 }
969:                 /*******************************************************************************
970:                   Function:
971:                     extern inline void __attribute__ ((always_inline)) INTSetTemporalProximityControl(INT_TPC_GROUP level)
972:                 
973:                   Summary:
974:                     Sets the Temporal Proximity Control level.
975:                 
976:                   Description:
977:                     This routine sets the temporal Proximity Control level.
978:                 
979:                   Precondition:
980:                     None
981:                 
982:                   Parameters:
983:                     level   - Level of the temporal proximity control.
984:                 
985:                   Returns:
986:                     None
987:                 
988:                   Example:
989:                     <code>
990:                     INTSetTemporalProximityControl(INT_TPC_GROUP_PRI_LEVEL_3);
991:                     </code>
992:                 
993:                   Remarks:
994:                     None
995:                   *****************************************************************************/
996:                 extern inline void __attribute__ ((always_inline)) INTSetTemporalProximityControl(INT_TPC_GROUP level)
997:                 {
998:                     INTCONCLR = INT_TPC_DISABLE;
999:                 
1000:                    if(level != INT_TPC_DISABLE)
1001:                        INTCONSET = (level << _INTCON_TPC_POSITION);
1002:                }
1003:                
1004:                /*******************************************************************************
1005:                //DOM-IGNORE-BEGIN
1006:                  *****************************************************************************/
1007:                #define CORE_SW_0           0x00000100
1008:                #define CORE_SW_1           0x00000200
1009:                /*******************************************************************************
1010:                //DOM-IGNORE-END
1011:                  *****************************************************************************/
1012:                
1013:                
1014:                /*******************************************************************************
1015:                  Function:
1016:                    void __attribute__ ((nomips16)) CoreSetSoftwareInterrupt0(void)
1017:                
1018:                  Summary:
1019:                    Set the Core Software Interrupt 0.
1020:                
1021:                  Description:
1022:                    This routine sets the core software interrupt 0.  This will produce an interrupt
1023:                    service request.
1024:                
1025:                  Precondition:
1026:                    None
1027:                
1028:                  Parameters:
1029:                    None
1030:                
1031:                  Returns:
1032:                    None
1033:                
1034:                  Example:
1035:                    <code>
1036:                
1037:                    CoreSetSoftwareInterrupt0();
1038:                    </code>
1039:                
1040:                  Remarks:
1041:                    This function cannot be compiled using the MIPS16 instruction set.
1042:                  *****************************************************************************/
1043:                void __attribute__((nomips16)) CoreSetSoftwareInterrupt0(void);
1044:                
1045:                /*******************************************************************************
1046:                  Function:
1047:                    void __attribute__ ((nomips16)) CoreSetSoftwareInterrupt1(void)
1048:                
1049:                  Summary:
1050:                    Set the Core Software Interrupt 1.
1051:                
1052:                  Description:
1053:                    This routine sets the core software interrupt 1.  This will produce an interrupt
1054:                    service request.
1055:                
1056:                  Precondition:
1057:                    None
1058:                
1059:                  Parameters:
1060:                    None
1061:                
1062:                  Returns:
1063:                    None
1064:                
1065:                  Example:
1066:                    <code>
1067:                
1068:                    CoreSetSoftwareInterrupt1();
1069:                    </code>
1070:                
1071:                  Remarks:
1072:                    This function cannot be compiled using the MIPS16 instruction set.
1073:                  *****************************************************************************/
1074:                void __attribute__((nomips16))  CoreSetSoftwareInterrupt1(void);
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void __attribute__ ((nomips16)) CoreClearSoftwareInterrupt0(void)
1079:                
1080:                  Summary:
1081:                    Clears the Core Software Interrupt 0.
1082:                
1083:                  Description:
1084:                    This routine clears the core software interrupt 0.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    None
1091:                
1092:                  Returns:
1093:                    None
1094:                
1095:                  Example:
1096:                    <code>
1097:                
1098:                    CoreClearSoftwareInterrupt0();
1099:                
1100:                    INTClearFlag(INT_CS0);
1101:                    </code>
1102:                
1103:                  Remarks:
1104:                    This function cannot be compiled using the MIPS16 instruction set.
1105:                
1106:                    You must call this routine before clearing the interrupt request flag.
1107:                  *****************************************************************************/
1108:                void __attribute__((nomips16))  CoreClearSoftwareInterrupt0(void);
1109:                
1110:                /*******************************************************************************
1111:                  Function:
1112:                    void __attribute__ ((nomips16)) CoreClearSoftwareInterrupt1(void)
1113:                
1114:                  Summary:
1115:                    Clears the Core Software Interrupt 1.
1116:                
1117:                  Description:
1118:                    This routine clears the core software interrupt 1.
1119:                
1120:                  Precondition:
1121:                    None
1122:                
1123:                  Parameters:
1124:                    None
1125:                
1126:                  Returns:
1127:                    None
1128:                
1129:                  Example:
1130:                    <code>
1131:                
1132:                    CoreClearSoftwareInterrupt1();
1133:                
1134:                    INTClearFlag(INT_CS1);
1135:                    </code>
1136:                
1137:                  Remarks:
1138:                    This function cannot be compiled using the MIPS16 instruction set.
1139:                
1140:                    You must call this routine before clearing the interrupt request flag.
1141:                  *****************************************************************************/
1142:                void __attribute__((nomips16))  CoreClearSoftwareInterrupt1(void);
1143:                
1144:                #ifdef __cplusplus
1145:                  }
1146:                #endif
1147:                
1148:                #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000000  27BDFFF8   ADDIU SP, SP, -8
9D000004  AFBE0004   SW FP, 4(SP)
9D000008  03A0F025   OR FP, SP, ZERO
9D00000C  AFC40008   SW A0, 8(FP)
9D000010  3C02BF88   LUI V0, -16504
9D000014  8FC30008   LW V1, 8(FP)
9D000018  AC431004   SW V1, 4100(V0)
9D00001C  3C02BF88   LUI V0, -16504
9D000020  8FC30008   LW V1, 8(FP)
9D000024  AC431008   SW V1, 4104(V0)
9D000028  00000000   NOP
9D00002C  03C0E825   OR SP, FP, ZERO
9D000030  8FBE0004   LW FP, 4(SP)
9D000034  27BD0008   ADDIU SP, SP, 8
9D000038  03E00008   JR RA
9D00003C  00000000   NOP
9D000040  27BDFFF8   ADDIU SP, SP, -8
9D000044  AFBE0004   SW FP, 4(SP)
9D000048  03A0F025   OR FP, SP, ZERO
9D00004C  3C02BF88   LUI V0, -16504
9D000050  8C421010   LW V0, 4112(V0)
9D000054  7C422800   EXT V0, V0, 0, 6
9D000058  304200FF   ANDI V0, V0, 255
9D00005C  03C0E825   OR SP, FP, ZERO
9D000060  8FBE0004   LW FP, 4(SP)
9D000064  27BD0008   ADDIU SP, SP, 8
9D000068  03E00008   JR RA
9D00006C  00000000   NOP
9D000070  27BDFFF8   ADDIU SP, SP, -8
9D000074  AFBE0004   SW FP, 4(SP)
9D000078  03A0F025   OR FP, SP, ZERO
9D00007C  3C02BF88   LUI V0, -16504
9D000080  8C421010   LW V0, 4112(V0)
9D000084  7C421200   EXT V0, V0, 8, 3
9D000088  304200FF   ANDI V0, V0, 255
9D00008C  03C0E825   OR SP, FP, ZERO
9D000090  8FBE0004   LW FP, 4(SP)
9D000094  27BD0008   ADDIU SP, SP, 8
9D000098  03E00008   JR RA
9D00009C  00000000   NOP
9D0000A0  27BDFFF8   ADDIU SP, SP, -8
9D0000A4  AFBE0004   SW FP, 4(SP)
9D0000A8  03A0F025   OR FP, SP, ZERO
9D0000AC  AFC40008   SW A0, 8(FP)
9D0000B0  AFC5000C   SW A1, 12(FP)
9D0000B4  3C02BF88   LUI V0, -16504
9D0000B8  8C431010   LW V1, 4112(V0)
9D0000BC  8FC20008   LW V0, 8(FP)
9D0000C0  AC430000   SW V1, 0(V0)
9D0000C4  8FC20008   LW V0, 8(FP)
9D0000C8  8C420000   LW V0, 0(V0)
9D0000CC  00021202   SRL V0, V0, 8
9D0000D0  30430007   ANDI V1, V0, 7
9D0000D4  8FC2000C   LW V0, 12(FP)
9D0000D8  AC430000   SW V1, 0(V0)
9D0000DC  8FC20008   LW V0, 8(FP)
9D0000E0  8C420000   LW V0, 0(V0)
9D0000E4  3043003F   ANDI V1, V0, 63
9D0000E8  8FC20008   LW V0, 8(FP)
9D0000EC  AC430000   SW V1, 0(V0)
9D0000F0  00000000   NOP
9D0000F4  03C0E825   OR SP, FP, ZERO
9D0000F8  8FBE0004   LW FP, 4(SP)
9D0000FC  27BD0008   ADDIU SP, SP, 8
9D000100  03E00008   JR RA
9D000104  00000000   NOP
9D000108  27BDFFF8   ADDIU SP, SP, -8
9D00010C  AFBE0004   SW FP, 4(SP)
9D000110  03A0F025   OR FP, SP, ZERO
9D000114  AFC40008   SW A0, 8(FP)
9D000118  3C02BF88   LUI V0, -16504
9D00011C  8FC30008   LW V1, 8(FP)
9D000120  AC431020   SW V1, 4128(V0)
9D000124  00000000   NOP
9D000128  03C0E825   OR SP, FP, ZERO
9D00012C  8FBE0004   LW FP, 4(SP)
9D000130  27BD0008   ADDIU SP, SP, 8
9D000134  03E00008   JR RA
9D000138  00000000   NOP
9D00013C  27BDFFF8   ADDIU SP, SP, -8
9D000140  AFBE0004   SW FP, 4(SP)
9D000144  03A0F025   OR FP, SP, ZERO
9D000148  3C02BF88   LUI V0, -16504
9D00014C  8C421020   LW V0, 4128(V0)
9D000150  03C0E825   OR SP, FP, ZERO
9D000154  8FBE0004   LW FP, 4(SP)
9D000158  27BD0008   ADDIU SP, SP, 8
9D00015C  03E00008   JR RA
9D000160  00000000   NOP
9D000164  27BDFFF8   ADDIU SP, SP, -8
9D000168  AFBE0004   SW FP, 4(SP)
9D00016C  03A0F025   OR FP, SP, ZERO
9D000170  AFC40008   SW A0, 8(FP)
9D000174  3C02BF88   LUI V0, -16504
9D000178  24030700   ADDIU V1, ZERO, 1792
9D00017C  AC431004   SW V1, 4100(V0)
9D000180  8FC30008   LW V1, 8(FP)
9D000184  24020700   ADDIU V0, ZERO, 1792
9D000188  10620005   BEQ V1, V0, 0x9D0001A0
9D00018C  00000000   NOP
9D000190  8FC20008   LW V0, 8(FP)
9D000194  00021A00   SLL V1, V0, 8
9D000198  3C02BF88   LUI V0, -16504
9D00019C  AC431008   SW V1, 4104(V0)
9D0001A0  00000000   NOP
9D0001A4  03C0E825   OR SP, FP, ZERO
9D0001A8  8FBE0004   LW FP, 4(SP)
9D0001AC  27BD0008   ADDIU SP, SP, 8
9D0001B0  03E00008   JR RA
9D0001B4  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/dma_3xx_4xx.h  -------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the “Company”) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company’s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_3XX_4XX_H_
43:                  #define _DMA_3XX_4XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                  	#define _DMA_CHANNELS		// DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                  	typedef enum
66:                  	{
67:                  		DMA_CHANNEL0,
68:                  	#ifdef _DMAC1
69:                  		DMA_CHANNEL1,
70:                  	#ifdef _DMAC2
71:                  		DMA_CHANNEL2,
72:                  	#ifdef _DMAC3
73:                  		DMA_CHANNEL3,
74:                  	#ifdef _DMAC4
75:                  		DMA_CHANNEL4,
76:                  	#ifdef _DMAC5
77:                  		DMA_CHANNEL5,
78:                  	#ifdef _DMAC6
79:                  		DMA_CHANNEL6,
80:                  	#ifdef _DMAC7
81:                  		DMA_CHANNEL7,
82:                  	#endif	// _DMAC7
83:                  	#endif	// _DMAC6
84:                  	#endif	// _DMAC5
85:                  	#endif	// _DMAC4
86:                  	#endif	// _DMAC3
87:                  	#endif	// _DMAC2
88:                  	#endif	// _DMAC1
89:                  		//	add/remove DMA channel as needed here
90:                  
91:                  		DMA_CHANNELS	// number of current available channels
92:                  	}DmaChannel;
93:                  
94:                  
95:                  	// Relative Dma channels priority, between each other
96:                  	typedef enum
97:                  	{
98:                  		DMA_CHN_PRI0,
99:                  		DMA_CHN_PRI1,
100:                 		DMA_CHN_PRI2,
101:                 		DMA_CHN_PRI3
102:                 	}DmaChannelPri;
103:                 
104:                 
105:                 
106:                 	// high level definitions for the API functions
107:                 
108:                 	typedef enum
109:                 	{
110:                 		DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
111:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
112:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
113:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
114:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
115:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
116:                 		DMA_OPEN_MATCH	= 0x80000000,                           // DMA channel stops on match
117:                 	}DmaOpenFlags;	// flags for the channel open
118:                 
119:                 
120:                 	typedef enum
121:                 	{
122:                 		DMA_EV_ERR =			0x1,		// address error event
123:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
124:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
125:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
126:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
127:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
128:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
129:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
130:                 
131:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
133:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_TXFER_OK,			// the transfer was performed successfully
139:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
140:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
141:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
142:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
143:                 		DMA_TXFER_TMO			// DMA transfer timeout
144:                 	}DmaTxferRes;		// DMA transfer result
145:                 
146:                 	typedef enum
147:                 	{
148:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
149:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
150:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
151:                 	}DmaWaitMode;		// DMA transfer wait mode
152:                 
153:                 
154:                 	/*********************************************************************
155:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
156:                 	 *
157:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
158:                 	 *
159:                 	 * Input:           chn    - channel to be configured in the DMA controller
160:                 	 *                  chPri  - the priority given to the channel, 0-3
161:                 	 *                  oFlags - orred flags specifying the open mode:
162:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
163:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
164:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
165:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
166:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
167:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
168:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
169:                 	 *
170:                 	 *
171:                 	 *
172:                 	 * Output:          None
173:                 	 *
174:                 	 * Side Effects:    None
175:                 	 *
176:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
177:                 	 *
178:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
179:                 	 *                  Use the low level functions to address special settings.
180:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
181:                 	 *                  After that the channel is configured.
182:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
183:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
184:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
185:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
186:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
187:                 	 *                  User has to call event channel functions to enable the event flags if needed.
188:                 	 *
189:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
190:                 	 ********************************************************************/
191:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
192:                 
193:                 	/*********************************************************************
194:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
195:                 	 *
196:                 	 * PreCondition:    None
197:                 	 *
198:                 	 * Input:			chn		- channel to be enabled
199:                 	 *
200:                 	 * Output:          None
201:                 	 *
202:                 	 * Side Effects:    None
203:                 	 *
204:                 	 * Overview:		The function enables a previously configured DMA channel.
205:                 	 *
206:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
207:                 	 *
208:                 	 * Example:			DmaChnEnable(DMA_CHANNEL2);
209:                 	 ********************************************************************/
210:                 	 void			DmaChnEnable(DmaChannel chn);
211:                 
212:                 	/*********************************************************************
213:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
214:                 	 *
215:                 	 * PreCondition:    None
216:                 	 *
217:                 	 * Input:			chn		- selected channel in the DMA controller
218:                 	 *
219:                 	 * Output:          None
220:                 	 *
221:                 	 * Side Effects:    None
222:                 	 *
223:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
224:                 	 *
225:                 	 * Note:            None.
226:                 	 *
227:                 	 * Example:			DmaChnDisable(DMA_CHANNEL2);
228:                 	 ********************************************************************/
229:                 	 void			DmaChnDisable(DmaChannel chn);
230:                 
231:                 	/*********************************************************************
232:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
233:                 	 *
234:                 	 * PreCondition:    chn		- valid DMA channel
235:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
236:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
237:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
238:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
239:                 	 *
240:                 	 * Input:			chn			- DMA channel number
241:                 	 * 								- vSrcAdd: source of the DMA transfer
242:                 	 * 								- vDstAdd: destination of the DMA transfer
243:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
244:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
245:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
246:                 	 *
247:                 	 * Output:          None
248:                 	 *
249:                 	 * Side Effects:    None
250:                 	 *
251:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
252:                 	 * 					the source and the destination addresses.
253:                 	 * 					the source and destination lengths
254:                 	 * 					and the number of bytes	transferred per event.
255:                 	 *
256:                 	 * Note:			The function clears the existing DMA channel event flags.
257:                 	 *
258:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL2, &U2RXREG, dstBuff, 1, 200, 1);
259:                 	 ********************************************************************/
260:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
261:                 
262:                 
263:                 	/*********************************************************************
264:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
265:                 	 *
266:                 	 * PreCondition:    chn		- valid DMA channel
267:                 	 *
268:                 	 * Input:           chn		- DMA channel number
269:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
270:                 	 * Output:          None
271:                 	 *
272:                 	 * Side Effects:    None
273:                 	 *
274:                 	 * Overview:        The function is a helper to set directly the transfer source address.
275:                 	 *
276:                 	 * Note:            None.
277:                 	 *
278:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
279:                 	 ********************************************************************/
280:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
281:                 
282:                 	/*********************************************************************
283:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
284:                 	 *
285:                 	 * PreCondition:    chn		- valid DMA channel
286:                 	 *
287:                 	 * Input:			chn			- DMA channel number
288:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
289:                 	 * Output:          None
290:                 	 *
291:                 	 * Side Effects:    None
292:                 	 *
293:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
294:                 	 *
295:                 	 * Note:            None
296:                 	 *
297:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
298:                 	 ********************************************************************/
299:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
300:                 
301:                 	/*********************************************************************
302:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
303:                 	 *
304:                 	 * PreCondition:    chn	- valid DMA channel
305:                 	 *
306:                 	 * Input:			chn		- DMA channel number
307:                 	 * 					pattern	-  the match pattern
308:                 	 *
309:                 	 * Output:          None
310:                 	 *
311:                 	 * Side Effects:    None
312:                 	 *
313:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
314:                 	 *
315:                 	 * Note:            None.
316:                 	 *
317:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL2, '\r');
318:                 	 ********************************************************************/
319:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
320:                 
321:                 	/*********************************************************************
322:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
323:                 	 *
324:                 	 * PreCondition:    chn	- valid DMA channel
325:                 	 *
326:                 	 * Input:			chn		- DMA channel number
327:                 	 *
328:                 	 * Output:          The channel match pattern.
329:                 	 *
330:                 	 * Side Effects:    None
331:                 	 *
332:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
333:                 	 *
334:                 	 * Note:            None.
335:                 	 *
336:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL2);
337:                 	 ********************************************************************/
338:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
339:                 
340:                 	/*********************************************************************
341:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
342:                 	 *
343:                 	 * PreCondition:    chn	- valid DMA channel
344:                 	 *
345:                 	 * Input:			chn		- DMA channel number
346:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
347:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
348:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
349:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
350:                 	 * 								If 0, wait forever.
351:                 	 *
352:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
353:                 	 * 					an DmaTxferRes error code  otherwise
354:                 	 *
355:                 	 * Side Effects:    None
356:                 	 *
357:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
358:                 	 * 					The DMA channel is enabled.
359:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
360:                 	 * 					this event) the function will periodically query the DMA controller for the
361:                 	 * 					transfer completion status.
362:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
363:                      * 					the block transfer than the function will re-force the transfer for each cell.
364:                 	 *
365:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
366:                      *                  by hardware interrupt requests.
367:                      *                  This is because the transfers are software forced, theere is no
368:                      *                  wait for the occurrence of the hardware trigger. 
369:                 	 *
370:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
371:                 	 ********************************************************************/
372:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
373:                 
374:                 	/*********************************************************************
375:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
376:                 	 *
377:                 	 * PreCondition:    chn	- valid DMA channel
378:                 	 *
379:                 	 * Input:			chn		- DMA channel number
380:                 	 *
381:                 	 * Output:          None
382:                 	 *
383:                 	 * Side Effects:    None
384:                 	 *
385:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
386:                 	 *
387:                 	 * Note:            None.
388:                 	 *
389:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL2);
390:                 	 ********************************************************************/
391:                 	 void			DmaChnForceTxfer(DmaChannel chn);
392:                 
393:                 	/*********************************************************************
394:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
395:                 	 *
396:                 	 * PreCondition:    chn	- valid DMA channel
397:                 	 *
398:                 	 * Input:			chn		- DMA channel number
399:                 	 *
400:                 	 * Output:          None
401:                 	 *
402:                 	 * Side Effects:    None
403:                 	 *
404:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
405:                 	 *
406:                 	 * Note:            None.
407:                 	 *
408:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL2);
409:                 	 ********************************************************************/
410:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
411:                 
412:                 	// High level channel event and interrupt control functions
413:                 
414:                 	/*********************************************************************
415:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
416:                 	 *
417:                 	 * PreCondition:    chn	- valid DMA channel
418:                 	 *
419:                 	 * Input:			chn		- DMA channel number
420:                 	 * 					eFlags	- event flags with the following significance:
421:                 	 * 								- DMA_EV_ERR: address error event
422:                 	 * 								- DMA_EV_ABORT: transfer abort event
423:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
424:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
425:                 	 * 								- DMA_EV_DST_HALF: destination half event
426:                 	 * 								- DMA_EV_DST_FULL: destination full event
427:                 	 * 								- DMA_EV_SRC_HALF: source half event
428:                 	 * 								- DMA_EV_SRC_FULL: source full event
429:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
430:                 	 *
431:                 	 * Output:          None
432:                 	 *
433:                 	 * Side Effects:    None
434:                 	 *
435:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
436:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
437:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
438:                 	 *
439:                 	 * Note:            None.
440:                 	 *
441:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
442:                 	 ********************************************************************/
443:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
444:                 
445:                 	/*********************************************************************
446:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
447:                 	 *
448:                 	 * PreCondition:    chn	- valid DMA channel
449:                 	 *
450:                 	 * Input:			chn		- DMA channel number
451:                 	 * 					eFlags	- event flags with the following significance:
452:                 	 * 								- DMA_EV_ERR: address error event
453:                 	 * 								- DMA_EV_ABORT: transfer abort event
454:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
455:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
456:                 	 * 								- DMA_EV_DST_HALF: destination half event
457:                 	 * 								- DMA_EV_DST_FULL: destination full event
458:                 	 * 								- DMA_EV_SRC_HALF: source half event
459:                 	 * 								- DMA_EV_SRC_FULL: source full event
460:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
461:                 	 *
462:                 	 * Output:          None
463:                 	 *
464:                 	 * Side Effects:    None
465:                 	 *
466:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
467:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
468:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
469:                 	 *
470:                 	 * Note:            None.
471:                 	 *
472:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
473:                 	 ********************************************************************/
474:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
475:                 
476:                 	/*********************************************************************
477:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
478:                 	 *
479:                 	 * PreCondition:    chn	- valid DMA channel
480:                 	 *
481:                 	 * Input:			chn		- DMA channel number
482:                 	 * 					eFlags	- event flags with the following significance:
483:                 	 * 								- DMA_EV_ERR: address error event
484:                 	 * 								- DMA_EV_ABORT: transfer abort event
485:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
486:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
487:                 	 * 								- DMA_EV_DST_HALF: destination half event
488:                 	 * 								- DMA_EV_DST_FULL: destination full event
489:                 	 * 								- DMA_EV_SRC_HALF: source half event
490:                 	 * 								- DMA_EV_SRC_FULL: source full event
491:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
492:                 	 *
493:                 	 * Output:          None
494:                 	 *
495:                 	 * Side Effects:    None
496:                 	 *
497:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
498:                 	 * 					The channel event flags are forced to the eFlags value.
499:                 	 *
500:                 	 * Note:            None.
501:                 	 *
502:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
503:                 	 ********************************************************************/
504:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
505:                 
506:                 	/*********************************************************************
507:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
508:                 	 *
509:                 	 * PreCondition:    chn	- valid DMA channel
510:                 	 *
511:                 	 * Input:			chn		- DMA channel number
512:                 	 *
513:                 	 * Output:          - event flags with the following significance:
514:                 	 * 						- DMA_EV_ERR: address error event
515:                 	 * 						- DMA_EV_ABORT: transfer abort event
516:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
517:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
518:                 	 * 						- DMA_EV_DST_HALF: destination half event
519:                 	 * 						- DMA_EV_DST_FULL: destination full event
520:                 	 * 						- DMA_EV_SRC_HALF: source half event
521:                 	 * 						- DMA_EV_SRC_FULL: source full event
522:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
523:                 	 *
524:                 	 * Side Effects:    None
525:                 	 *
526:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
527:                 	 *
528:                 	 * Note:            None.
529:                 	 *
530:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL2);
531:                 	 ********************************************************************/
532:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
533:                 
534:                 	/*********************************************************************
535:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
536:                 	 *
537:                 	 * PreCondition:    chn	- valid DMA channel
538:                 	 *
539:                 	 * Input:			chn		- DMA channel number
540:                 	 * 					eFlags	- event flags with the following significance:
541:                 	 * 								- DMA_EV_ERR: address error event
542:                 	 * 								- DMA_EV_ABORT: transfer abort event
543:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
544:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
545:                 	 * 								- DMA_EV_DST_HALF: destination half event
546:                 	 * 								- DMA_EV_DST_FULL: destination full event
547:                 	 * 								- DMA_EV_SRC_HALF: source half event
548:                 	 * 								- DMA_EV_SRC_FULL: source full event
549:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
550:                 	 *
551:                 	 * Output:          None
552:                 	 *
553:                 	 * Side Effects:    None
554:                 	 *
555:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
556:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
557:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
558:                 	 *
559:                 	 * Note:            None.
560:                 	 *
561:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
562:                 	 ********************************************************************/
563:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
564:                 
565:                 	/*********************************************************************
566:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
567:                 	 *
568:                 	 * PreCondition:    chn	- valid DMA channel
569:                 	 *
570:                 	 * Input:			chn		- DMA channel number
571:                 	 *
572:                 	 * Output:          event flags with the following significance:
573:                 	 * 						- DMA_EV_ERR: address error event
574:                 	 * 						- DMA_EV_ABORT: transfer abort event
575:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
576:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
577:                 	 * 						- DMA_EV_DST_HALF: destination half event
578:                 	 * 						- DMA_EV_DST_FULL: destination full event
579:                 	 * 						- DMA_EV_SRC_HALF: source half event
580:                 	 * 						- DMA_EV_SRC_FULL: source full event
581:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
582:                 	 *
583:                 	 * Side Effects:    None
584:                 	 *
585:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
586:                 	 *
587:                 	 * Note:            None.
588:                 	 *
589:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL2);
590:                 	 ********************************************************************/
591:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
592:                 
593:                 
594:                 	// high level helpers for fast strcpy/memcpy transfers
595:                 
596:                 	/*********************************************************************
597:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
598:                 	 *
599:                 	 * PreCondition:    chn		- a valid DMA channel
600:                 	 * 					s1, s2	- valid memory pointers
601:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
602:                 	 *
603:                 	 * Input:			s1		- destination pointer
604:                 	 * 					s2		- source pointer
605:                 	 * 					n		- number of bytes to transfer
606:                 	 * 					chn		- the DMA channel to perform the transfer
607:                 	 * 					chPri	- the desired channel priority
608:                 	 *
609:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
610:                 	 * 					an DmaTxferRes error code  otherwise
611:                 	 *
612:                 	 * Side Effects:    None
613:                 	 *
614:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
615:                 	 * 			Then it copies one block of memory from source to destination.
616:                 	 *
617:                 	 *
618:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
619:                 	 * 						This way, the transfer will occur correctly together with CRC calculation.
620:                 	 * 					- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
621:                 	 * 					- Multiple channels could be opened to perform fast memory transfers, if necessary.
622:                 	 * 					- The function clears the suspend state and resumes the operation of the DMA controller.
623:                 	 *
624:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL2, DMA_CHN_PRI3);
625:                  	 ********************************************************************/
626:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
627:                 
628:                 	/*********************************************************************
629:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
630:                 	 *
631:                 	 * PreCondition:    chn		- a valid DMA channel
632:                 	 * 					s1, s2	- valid memory pointers
633:                 	 *
634:                 	 * Input:			s1		- destination pointer
635:                 	 * 					s2		- source pointer
636:                 	 * 					chn		- the DMA channel to perform the transfer
637:                 	 * 					chPri	- the desired channel priority
638:                 	 *
639:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
640:                 	 * 					an DmaTxferRes error code  otherwise
641:                 	 *
642:                 	 * Side Effects:    None
643:                 	 *
644:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
645:                 	 * 			Then it copies one zero terminated string from source to destination.
646:                 	 *
647:                 	 *
648:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
649:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
650:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
651:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
652:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
653:                 	 *
654:                 	 *
655:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL2, DMA_CHN_PRI3);
656:                 	 *********************************************************************/
657:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
658:                 
659:                 	/*********************************************************************
660:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
661:                 	 *
662:                 	 * PreCondition:    chn		- a valid DMA channel
663:                 	 * 				- s1, s2	- valid memory pointers
664:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
665:                 	 *
666:                 	 * Input:			s1		- destination pointer
667:                 	 * 					s2		- source pointer
668:                 	 * 					n	- max number of bytes to transfer
669:                 	 * 					chn		- the DMA channel to perform the transfer
670:                 	 * 					chPri	- the desired channel priority
671:                 	 *
672:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
673:                 	 * 					an DmaTxferRes error code  otherwise
674:                 	 *
675:                 	 * Side Effects:    None
676:                 	 *
677:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
678:                 	 * 			Then it copies one zero terminated string from source to destination.
679:                 	 * 			It copies no more than n characters from s2.
680:                 	 *
681:                 	 *
682:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
683:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
684:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
685:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
686:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
687:                 	 *
688:                 	 *
689:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL2, DMA_CHN_PRI3);
690:                 	 ********************************************************************/
691:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
692:                 
693:                 	/*********************************************************************
694:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
695:                 	 *
696:                 	 * PreCondition:    chn		- a valid DMA channel
697:                 	 * 					d, s		- valid memory pointer
698:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
699:                 	 *
700:                 	 * Input:			d		- address where to deposit the result
701:                 	 * 					s		- source buffer pointer
702:                 	 * 					n		- number of bytes in the pointer
703:                 	 * 					chn		- the DMA channel to use
704:                 	 * 					chPri	- the desired channel priority
705:                 	 *
706:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
707:                 	 * 					an DmaTxferRes error code  otherwise
708:                 	 *
709:                 	 * Side Effects:    None
710:                 	 *
711:                 	 * Overview:		The function is a helper that calculates the CRC of a memory block.
712:                 	 * 			The function configures the DMA channel for a fast memory transfer and calculates the CRC.
713:                 	 *
714:                 	 *
715:                 	 * Note:            - The CRC generator must have been previously configured using mCrcConfigure()
716:                 	 * 					- No transfer is done, just the CRC is calculated.
717:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
718:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
719:                 	 *
720:                 	 * Example:		int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
721:                 	 ********************************************************************/
722:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
723:                 
724:                 
725:                 	// High level CRC functions
726:                 
727:                 	/*********************************************************************
728:                 	 * Function:        void DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
729:                 	 *
730:                 	 * PreCondition:    pLen		- valid polynomial length within 1-16
731:                 	 *
732:                 	 * Input:			polynomial	- the layout of the CRC generator
733:                 	 * 					pLen		- the length of the CRC generator polynomial
734:                 	 * 					seed		- the initial seed of the CRC generator
735:                 	 *
736:                 	 * Output:          None
737:                 	 *
738:                 	 * Side Effects:    None
739:                 	 *
740:                 	 * Overview:		The function configures the CRC module by setting the parameters that define the generator polynomial:
741:                 	 * 					- the length of the CRC generator polynomial, pLen;
742:                 	 * 					- the function sets the layout of the shift stages that take place in the CRC generation.
743:                 	 * 						Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
744:                 	 * 						If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
745:                 	 * 						Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
746:                 	 * 						are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
747:                 	 * 						feedback should be 0x8005, or 0x8004, but not 0x018005;
748:                 	 *					- the function sets the seed of the CRC generator. This is the initial data present in the
749:                 	 * 						CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
750:                 	 *
751:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
752:                 	 * 					- When the append mode is set, the attached DMA channel has to have destination size <=4.
753:                 	 * 						Upon the transfer completion the calculated CRC is stored at the destination address.
754:                 	 * 					- When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
755:                 	 * 						the CrcResult() function.
756:                 	 * 					- The CRC module should be configured before enabled.
757:                 	 *
758:                 	 * Example:			DmaCrcConfigure(0x8005, 16, 0xffff);
759:                 	 ********************************************************************/
760:                 	extern __inline__ void __attribute__((always_inline)) DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
761:                 	{
762:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
763:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
764:                 		DCRCDATA=seed;
765:                 		DCRCXOR=polynomial;
766:                 	}
767:                 
768:                 	/*********************************************************************
769:                 	 * Function:        void CrcAttachChannel(DmaChannel chn, int appendMode)
770:                 	 *
771:                 	 * PreCondition:    chn		- valid DMA channel
772:                 	 *
773:                 	 * Input:			chn			- the DMA channel to be attached to the CRC generator module.
774:                 	 * 					appendMode	- if TRUE the data passed to the CRC generator is not transferred to destination
775:                 	 * 									but it's written to the destination address when the block transfer is complete.
776:                 	 * 								- if FALSE the data is transferred normally while the CRC is calculated. The CRC will
777:                 	 * 									be available using the CrcResult function.
778:                 	 *
779:                 	 * Output:          None
780:                 	 *
781:                 	 * Side Effects:    None
782:                 	 *
783:                 	 * Overview:		The function attaches the CRC module to an DMA channel and enables the CRC generator.
784:                 	 * 					From now on, all the DMA traffic is directed to the CRC generator. Once the DMA block transfer
785:                 	 * 					is complete, the CRC result is available both at the DMA destination address and in the CRC data register.
786:                 	 *
787:                 	 * Note:            None
788:                 	 *
789:                 	 * Example:			CrcAttachChannel(0, TRUE);
790:                 	 ********************************************************************/
791:                 	 void			CrcAttachChannel(DmaChannel chn, int appendMode);
792:                 
793:                 	/*********************************************************************
794:                 	 * Function:        unsigned int CrcResult(void)
795:                 	 *
796:                 	 * PreCondition:    None
797:                 	 *
798:                 	 * Input:			None
799:                 	 *
800:                 	 * Output:          the current value of the CRC generator.
801:                 	 *
802:                 	 * Side Effects:    None
803:                 	 *
804:                 	 * Overview:		The function returns the calculated CRC value.
805:                 	 *
806:                 	 * Note:            The function returns the valid CRC result by masking out the unused MSbits in the CRC register.
807:                 	 * 					Use CrcGetValue() to get the full CRC register value.
808:                 	 *
809:                 	 * Example:			int myCrc=CrcResult();
810:                 	 ********************************************************************/
811:                 	 unsigned int		CrcResult(void);
812:                 
813:                 
814:                 /*********************  end of high level functions ****************************************/
815:                 
816:                 	// low level definitions for the API functions
817:                 
818:                 
819:                 	typedef struct
820:                 	{
821:                 		union
822:                 		{
823:                 			struct
824:                 			{
825:                 				unsigned int chn:	3;		// last active DMA channel
826:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
827:                 			};
828:                 			unsigned int	w;						// word access
829:                 		}lastAccess;
830:                 		void*	lastAddress;		// most recent DMA address
831:                 	}DmaStatus;			// DMA controller status
832:                 #if(defined(__32MX330F064H__)||\
833:                     defined(__32MX330F064L__)||\
834:                     defined(__32MX350F128H__)||\
835:                     defined(__32MX350F128L__)||\
836:                     defined(__32MX350F256H__)||\
837:                     defined(__32MX350F256L__)||\
838:                     defined(__32MX370F512H__)||\
839:                     defined(__32MX370F512L__)||\
840:                     defined(__32MX430F064H__)||\
841:                     defined(__32MX430F064L__)||\
842:                     defined(__32MX450F128H__)||\
843:                     defined(__32MX450F128L__)||\
844:                     defined(__32MX450F256H__)||\
845:                     defined(__32MX450F256L__)||\
846:                     defined(__32MX470F512L__)||\
847:                     defined(__32MX470F512L__))
848:                 typedef enum
849:                 	{
850:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
851:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
852:                 		//
853:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
854:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
855:                 #else
856:                 	typedef enum
857:                 	{
858:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
859:                 		DMA_GFLG_SIDL =		_DMACON_SIDL_MASK,		// DMA controller sleep/active in idle mode
860:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
861:                 		//
862:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_SIDL|DMA_GFLG_ON		// all flags
863:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
864:                 
865:                 #endif
866:                 
867:                 
868:                 	typedef enum
869:                 	{
870:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
871:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
872:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
873:                         // the start and abort IRQ signals
874:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
875:                 
876:                 
877:                         // compiler use only field
878:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
879:                 	}DmaEvCtrlFlags;	// DMA channel event control fields accessibile as flags
880:                 	// also part of DmaEvCtrlFlags:
881:                 	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
882:                 	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
883:                 
884:                 	// DMA channel event control as a structure:
885:                 	#define	DmaEvCtrl	__DCH0ECONbits_t
886:                 
887:                 
888:                 
889:                 
890:                 	typedef enum
891:                 	{
892:                 		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
893:                 		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
894:                 		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
895:                 		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
896:                 		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
897:                         // use the DMA_CTL_PRI() below for selecting the DMA
898:                         // channel priority
899:                 	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
900:                 	// also part of DmaChnCtrlFlags:
901:                 	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
902:                 
903:                 	// DMA channel control as a structure:
904:                 	#define	DmaChnCtrl  	__DCH0CONbits_t
905:                 
906:                 	typedef struct
907:                 	{
908:                 		void*	vSrcAdd;		// source of the DMA transfer, virtual
909:                 		void*	vDstAdd;		// destination of the DMA transfer, virtual
910:                 		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
911:                 		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
912:                 		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
913:                 	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
914:                 
915:                 
916:                 	/********************** low level DMA channel functions *******************************/
917:                 
918:                 
919:                 
920:                 	// Global DMA controller functions
921:                 
922:                 
923:                 	/*********************************************************************
924:                 	 * Function:        void DmaEnable(int enable)
925:                 	 *
926:                 	 * PreCondition:    None
927:                 	 *
928:                 	 * Input:           enable - boolean to enable/disable the DMA controller
929:                 	 *
930:                 	 * Output:          None
931:                 	 *
932:                 	 * Side Effects:    None
933:                 	 *
934:                 	 * Overview:       The function enables/disables the DMA controller.
935:                 	 *
936:                 	 * Note:           None.
937:                 	 *
938:                 	 * Example:        DmaEnable(1);
939:                 	 ********************************************************************/
940:                 	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
941:                 	{
942:                 		if(enable)
943:                 		{
944:                 			DMACONSET=_DMACON_ON_MASK;
945:                 		}
946:                 		else
947:                 		{
948:                 			DMACONCLR=_DMACON_ON_MASK;
949:                 			while(DMACONbits.ON);		// wait to take effect
950:                 		}
951:                 	}
952:                 
953:                 	/*********************************************************************
954:                 	 * Function:        void DmaReset(void)
955:                 	 *
956:                 	 * PreCondition:    None
957:                 	 *
958:                 	 * Input:		None
959:                 	 *
960:                 	 * Output:          None
961:                 	 *
962:                 	 * Side Effects:    None
963:                 	 *
964:                 	 * Overview:        The function resets the DMA controller.
965:                 	 *
966:                 	 * Note:            None.
967:                 	 *
968:                 	 * Example:        DmaReset();
969:                 	 ********************************************************************/
970:                 	#define            DmaReset()	DmaEnable(0)
971:                 
972:                 	/*********************************************************************
973:                 	 * Function:        int DmaSuspend(void)
974:                 	 *
975:                 	 * PreCondition:    None
976:                 	 *
977:                 	 * Input:		None
978:                 	 *
979:                 	 * Output:          true if the DMA was previously suspended, false otherwise
980:                 	 *
981:                 	 *
982:                 	 * Side Effects:    None
983:                 	 *
984:                 	 * Overview:        The function suspends the DMA controller.
985:                 	 *
986:                 	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
987:                 	 *                  I.e. the function has to wait for the suspension to take place!
988:                 	 *
989:                 	 * Example:			int susp=DmaSuspend();
990:                 	 ********************************************************************/
991:                     extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
992:                 	{
993:                 		int suspSt;
994:                 		if(!(suspSt=DMACONbits.SUSPEND))
995:                 		{
996:                 			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
997:                 			while(!(DMACONbits.SUSPEND));	// wait to be actually suspended
998:                 		}
999:                 		return suspSt;
1000:                	}
1001:                
1002:                
1003:                
1004:                	/*********************************************************************
1005:                	 * Function:        void DmaResume(int susp)
1006:                	 *
1007:                	 * PreCondition:    None
1008:                	 *
1009:                	 * Input:		the desired DMA suspended state.
1010:                	 *
1011:                	 * Output:          None
1012:                	 *
1013:                	 * Side Effects:    None
1014:                	 *
1015:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1016:                	 *
1017:                	 * Note:            None.
1018:                	 *
1019:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1020:                	 ********************************************************************/
1021:                    extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1022:                	{
1023:                		if(susp)
1024:                		{
1025:                			DmaSuspend();
1026:                		}
1027:                		else
1028:                		{
1029:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
1030:                		}
1031:                	}
1032:                
1033:                	/*********************************************************************
1034:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1035:                	 *
1036:                	 * PreCondition:    pStat	- valid pointer
1037:                	 *
1038:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1039:                	 * 							status, carrying the following info:
1040:                	 * 								- chn:	the last active DMA channel
1041:                	 * 								- rdOp: the last DMA operation, read/write
1042:                	 * 								- lastAddress: the most recent DMA address
1043:                	 *
1044:                	 * Output:          None
1045:                	 *
1046:                	 * Side Effects:    None
1047:                	 *
1048:                	 * Overview:		The function updates the info for the current DMA controller status.
1049:                	 * 					It updates the last DMA: operation, channel used and address.
1050:                	 *
1051:                	 * Note:            None.
1052:                	 *
1053:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1054:                	 ********************************************************************/
1055:                	 void			DmaGetStatus(DmaStatus* pStat);
1056:                
1057:                	/*********************************************************************
1058:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1059:                	 *
1060:                	 * PreCondition:    None
1061:                	 *
1062:                	 * Input:			gFlags	- flags to be set, having the following fields:
1063:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1064:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1065:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1066:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1067:                	 *
1068:                	 * Output:          None
1069:                	 *
1070:                	 * Side Effects:    None
1071:                	 *
1072:                	 * Overview:		The function affects the global behavior of the DMA controller.
1073:                	 * 					It sets the specified flags. Any flag that is set in the gFlags will be
1074:                	 * 					enabled, the other flags won't be touched.
1075:                	 *
1076:                	 * Note:            None.
1077:                	 *
1078:                	 * Example:			DmaSetGlobalFlags(DMA_GFLG_SIDL|DMA_GFLG_ON);
1079:                	 ********************************************************************/
1080:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1081:                	{
1082:                		DMACONSET=gFlags;
1083:                	}
1084:                
1085:                	/*********************************************************************
1086:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1087:                	 *
1088:                	 * PreCondition:    None
1089:                	 *
1090:                	 * Input:			gFlags	- flags to be cleared, having the following fields:
1091:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1092:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1093:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1094:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1095:                	 *
1096:                	 * Output:          None
1097:                	 *
1098:                	 * Side Effects:    None
1099:                	 *
1100:                	 * Overview:		The function affects the global behavior of the DMA controller.
1101:                	 * 					It clears the specified flags. Any flag that is set in the gFlags will be
1102:                	 * 					cleared, the other flags won't be touched.
1103:                	 *
1104:                	 * Note:            None.
1105:                	 *
1106:                	 * Example:			DmaClrGlobalFlags(DMA_GFLG_SUSPEND|DMA_GFLG_SIDL);
1107:                	 ********************************************************************/
1108:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1109:                	{
1110:                		DMACONCLR=gFlags;
1111:                	}
1112:                
1113:                
1114:                	/*********************************************************************
1115:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1116:                	 *
1117:                	 * PreCondition:    None
1118:                	 *
1119:                	 * Input:			gFlags	- flags to be set, having the following fields:
1120:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1121:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1122:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1123:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1124:                	 *
1125:                	 * Output:          None
1126:                	 *
1127:                	 * Side Effects:    None
1128:                	 *
1129:                	 * Overview:		The function affects the global behavior of the DMA controller.
1130:                	 * 					It forces the flags to have the specified gFlags value.
1131:                	 *
1132:                	 * Note:            None.
1133:                	 *
1134:                	 * Example:			DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1135:                	 ********************************************************************/
1136:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1137:                	{
1138:                		DMACON=gFlags;
1139:                	}
1140:                
1141:                	/*********************************************************************
1142:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1143:                	 *
1144:                	 * PreCondition:    None
1145:                	 *
1146:                	 * Input:			None
1147:                	 *
1148:                	 * Output:          The current DMA controller flags settings.
1149:                	 * 						- DMA_GFLG_SUSPEND: DMA controller operation suspend
1150:                	 * 						- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1151:                	 * 						- DMA_GFLG_ON: DMA controller enabled/desabled
1152:                	 *
1153:                	 * Side Effects:    None
1154:                	 *
1155:                	 * Overview:		The function returns the global flags of the DMA controller.
1156:                	 *
1157:                	 * Note:            None.
1158:                	 *
1159:                	 * Example:			DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1160:                	 ********************************************************************/
1161:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1162:                	{
1163:                		return (DmaGlblFlags)DMACON;
1164:                	}
1165:                
1166:                
1167:                	/*********************************************************************
1168:                	 * Function:        int DmaGetMaxTxferSize(void)
1169:                	 *
1170:                	 * PreCondition:    None
1171:                	 *
1172:                	 * Input:           None
1173:                	 *
1174:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1175:                	 *
1176:                	 * Side Effects:    None
1177:                	 *
1178:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1179:                	 *
1180:                	 * Note:            Revision dependant.
1181:                	 *
1182:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1183:                	 ********************************************************************/
1184:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1185:                	{
1186:                		return 256;
1187:                	}
1188:                
1189:                
1190:                	// Direct Channel control functions
1191:                
1192:                	typedef enum
1193:                	{
1194:                		DMA_CONFIG_DEFAULT = 0,							        // DMA default operation
1195:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
1196:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1197:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),			// DMA channel is chained to higher channel
1198:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,				// events detection enabled while channel off
1199:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
1200:                		DMA_CONFIG_MATCH	= 0x80000000,						// DMA channel stops on match
1201:                	}DmaConfigFlags;	// flags for the channel configuration
1202:                
1203:                	/*********************************************************************
1204:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1205:                	 *
1206:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1207:                	 *
1208:                	 * Input:           chn    - channel to be configured in the DMA controller
1209:                	 *                  chPri  - the priority given to the channel, 0-3
1210:                	 *                  cFlags - orred flags specifying the configuration:
1211:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1212:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1213:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1214:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1215:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1216:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1217:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1218:                	 *
1219:                	 *
1220:                	 *
1221:                	 * Output:          None
1222:                	 *
1223:                	 * Side Effects:    None
1224:                	 *
1225:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1226:                	 *
1227:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1228:                	 *                  The channel is just configured.
1229:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1230:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1231:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1232:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1233:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1234:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1235:                	 *
1236:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1237:                	 ********************************************************************/
1238:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1239:                
1240:                
1241:                	/*********************************************************************
1242:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1243:                	 *
1244:                	 * PreCondition:    chn	- valid DMA channel
1245:                	 *
1246:                	 * Input:			chn		- DMA channel number
1247:                	 *
1248:                	 * Output:          Current channel source pointer.
1249:                	 *
1250:                	 * Side Effects:    None
1251:                	 *
1252:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1253:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1254:                	 *
1255:                	 * Note:            None
1256:                	 *
1257:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL2);
1258:                	 ********************************************************************/
1259:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1260:                
1261:                	/*********************************************************************
1262:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1263:                	 *
1264:                	 * PreCondition:    chn	- valid DMA channel
1265:                	 *
1266:                	 * Input:			chn		- DMA channel number
1267:                	 *
1268:                	 * Output:          Current channel destination pointer.
1269:                	 *
1270:                	 * Side Effects:    None
1271:                	 *
1272:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1273:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1274:                	 *
1275:                	 * Note:            None
1276:                	 *
1277:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL2);
1278:                	 ********************************************************************/
1279:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1280:                
1281:                	/*********************************************************************
1282:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1283:                	 *
1284:                	 * PreCondition:    chn	- valid DMA channel
1285:                	 *
1286:                	 * Input:			chn		- DMA channel number
1287:                	 *
1288:                	 * Output:          Current channel transfer pointer.
1289:                	 *
1290:                	 * Side Effects:    None
1291:                	 *
1292:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1293:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1294:                	 *
1295:                	 * Note:            None
1296:                	 *
1297:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL2);
1298:                	 ********************************************************************/
1299:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1300:                
1301:                
1302:                
1303:                	/*********************************************************************
1304:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1305:                	 *
1306:                	 * PreCondition:    chn	- valid DMA channel
1307:                	 *
1308:                	 * Input:			chn			- DMA channel number
1309:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1310:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1311:                	 * 										- SIRQEN: enable/disable the start IRQ action
1312:                	 * 										- PATEN: enable/disable the pattern match and abort
1313:                	 * 									or any of the DmaEvCtrlFlags:
1314:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1315:                	 *
1316:                	 *
1317:                	 * Output:          None
1318:                	 *
1319:                	 * Side Effects:    None
1320:                	 *
1321:                	 * Overview:		The function sets the events that start and abort the transfer
1322:                	 * 					for the selected DMA channel.
1323:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1324:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1325:                	 *
1326:                	 * Note:            None.
1327:                	 *
1328:                	 * Example:			either:
1329:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1330:                	 * 					or:
1331:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1332:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1333:                	 *
1334:                	 ********************************************************************/
1335:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1336:                
1337:                
1338:                	/*********************************************************************
1339:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1340:                	 *
1341:                	 * PreCondition:    chn	- valid DMA channel
1342:                	 *
1343:                	 * Input:			chn			- DMA channel number
1344:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1345:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1346:                	 * 										- SIRQEN: enable/disable the start IRQ action
1347:                	 * 										- PATEN: enable/disable the pattern match and abort
1348:                	 * 									or any of the DmaEvCtrlFlags:
1349:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1350:                	 *
1351:                	 *
1352:                	 * Output:          None
1353:                	 *
1354:                	 * Side Effects:    None
1355:                	 *
1356:                	 * Overview:		The function clears the events that start and abort the transfer
1357:                	 * 					for the selected DMA channel.
1358:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1359:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1360:                	 *
1361:                	 * Note:            None.
1362:                	 *
1363:                	 * Example:			either:
1364:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1365:                	 * 					or:
1366:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1367:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1368:                	 *
1369:                	 ********************************************************************/
1370:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1371:                
1372:                
1373:                
1374:                	/*********************************************************************
1375:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1376:                	 *
1377:                	 * PreCondition:    chn	- valid DMA channel
1378:                	 *
1379:                	 * Input:			chn			- DMA channel number
1380:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1381:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1382:                	 * 										- SIRQEN: enable/disable the start IRQ action
1383:                	 * 										- PATEN: enable/disable the pattern match and abort
1384:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1385:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1386:                	 * 									or any of the DmaEvCtrlFlags:
1387:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1388:                	 *
1389:                	 *
1390:                	 * Output:          None
1391:                	 *
1392:                	 * Side Effects:    None
1393:                	 *
1394:                	 * Overview:		The function writes the events that start and abort the transfer
1395:                	 * 					for the selected DMA channel.
1396:                	 *
1397:                	 * Note:            None.
1398:                	 *
1399:                	 * Example:			either:
1400:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1401:                	 * 					or:
1402:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1403:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1404:                	 *
1405:                	 ********************************************************************/
1406:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1407:                
1408:                
1409:                
1410:                	/*********************************************************************
1411:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1412:                	 *
1413:                	 * PreCondition:    chn	- valid DMA channel
1414:                	 *
1415:                	 * Input:			chn			- DMA channel number
1416:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1417:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1418:                	 * 										- SIRQEN: enable/disable the start IRQ action
1419:                	 * 										- PATEN: enable/disable the pattern match and abort
1420:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1421:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1422:                	 * 									or any of the DmaEvCtrlFlags:
1423:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1424:                	 *
1425:                	 *
1426:                	 * Output:          None
1427:                	 *
1428:                	 * Side Effects:    None
1429:                	 *
1430:                	 * Overview:		The function sets the events that start and abort the transfer
1431:                	 * 					for the selected DMA channel.
1432:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1433:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1434:                	 *
1435:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1436:                	 *
1437:                	 * Example:			either:
1438:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1439:                	 * 					or:
1440:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1441:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, evCtrl.w);
1442:                	 *
1443:                	 ********************************************************************/
1444:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1445:                
1446:                
1447:                	/*********************************************************************
1448:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1449:                	 *
1450:                	 * PreCondition:    chn	- valid DMA channel
1451:                	 *
1452:                	 * Input:			chn		- DMA channel number
1453:                	 *
1454:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1455:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1456:                	 * 							- SIRQEN: enable/disable the start IRQ action
1457:                	 * 							- PATEN: enable/disable the pattern match and abort
1458:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1459:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1460:                	 * 						or any of the DmaEvCtrlFlags:
1461:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1462:                	 *
1463:                	 *
1464:                	 * Side Effects:    None
1465:                	 *
1466:                	 * Overview:		The function retrieves the events that start and abort the transfer
1467:                	 * 					for the selected DMA channel.
1468:                	 *
1469:                	 * Note:            None.
1470:                	 *
1471:                	 * Example:			either:
1472:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1473:                	 * 					or:
1474:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrl.PATEN){...}
1475:                	 *
1476:                	 ********************************************************************/
1477:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1478:                
1479:                
1480:                	/*********************************************************************
1481:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1482:                	 *
1483:                	 * PreCondition:    chn	- valid DMA channel
1484:                	 *
1485:                	 * Input:			chn			- DMA channel number
1486:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1487:                	 * 										- autoEn: enable/disable the automatic mode
1488:                	 * 										- chainEn: enable/disable channel chaining
1489:                	 * 										- detectEn: enable/disable events detection when channel disabled
1490:                	 * 										- chEn: enable/disable channel functionality
1491:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1492:                	 * 									or any of the DmaChnCtrlFlags flags:
1493:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1494:                	 *
1495:                	 * Output:          None
1496:                	 *
1497:                	 * Side Effects:    None
1498:                	 *
1499:                	 * Overview:		The function sets the selected DMA channel control flags:
1500:                	 * 					the chaining or auto mode, and events detection.
1501:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1502:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1503:                	 *
1504:                	 * Note:            None.
1505:                	 *
1506:                	 * Example:			either:
1507:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1508:                	 * 					or:
1509:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1510:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, chCtrl.w);
1511:                	 *
1512:                	 ********************************************************************/
1513:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1514:                
1515:                	/*********************************************************************
1516:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1517:                	 *
1518:                	 * PreCondition:    chn	- valid DMA channel
1519:                	 *
1520:                	 * Input:			chn			- DMA channel number
1521:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1522:                	 * 										- autoEn: enable/disable the automatic mode
1523:                	 * 										- chainEn: enable/disable channel chaining
1524:                	 * 										- detectEn: enable/disable events detection when channel disabled
1525:                	 * 										- chEn: enable/disable channel functionality
1526:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1527:                	 * 									or any of the DmaChnCtrlFlags flags:
1528:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1529:                	 *
1530:                	 * Output:          None
1531:                	 *
1532:                	 * Side Effects:    None
1533:                	 *
1534:                	 * Overview:		The function clears the selected DMA channel control flags:
1535:                	 * 					the chaining or auto mode and events detection.
1536:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1537:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1538:                	 *
1539:                	 * Note:            None.
1540:                	 *
1541:                	 * Example:			either:
1542:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1543:                	 * 					or:
1544:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1545:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, chCtrl.w);
1546:                	 *
1547:                	 ********************************************************************/
1548:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1549:                
1550:                	/*********************************************************************
1551:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1552:                	 *
1553:                	 * PreCondition:    chn	- valid DMA channel
1554:                	 *
1555:                	 * Input:			chn			- DMA channel number
1556:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1557:                	 * 										- chPri: channel priority 0-3
1558:                	 * 										- autoEn: enable/disable the automatic mode
1559:                	 * 										- chainEn: enable/disable channel chaining
1560:                	 * 										- detectEn: enable/disable events detection when channel disabled
1561:                	 * 										- chEn: enable/disable channel functionality
1562:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1563:                	 * 									or any of the DmaChnCtrlFlags flags:
1564:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1565:                	 *
1566:                	 * Output:          None
1567:                	 *
1568:                	 * Side Effects:    None
1569:                	 *
1570:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1571:                	 * 					the channel priority, chaining mode or auto and events detection.
1572:                	 *
1573:                	 * Note:            None.
1574:                	 *
1575:                	 * Example:			either:
1576:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1577:                	 * 					or:
1578:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1579:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, chCtrl.w);
1580:                	 *
1581:                	 ********************************************************************/
1582:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1583:                
1584:                	/*********************************************************************
1585:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1586:                	 *
1587:                	 * PreCondition:    chn	- valid DMA channel
1588:                	 *
1589:                	 * Input:	    chn		- DMA channel number
1590:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1591:                	 * 						- chPri: channel priority 0-3
1592:                	 * 						- autoEn: enable/disable the automatic mode
1593:                	 * 						- chainEn: enable/disable channel chaining
1594:                	 * 						- detectEn: enable/disable events detection when channel disabled
1595:                	 * 						- chEn: enable/disable channel functionality
1596:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1597:                	 * 					or any of the DmaChnCtrlFlags flags:
1598:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1599:                	 *
1600:                	 * Output:          None
1601:                	 *
1602:                	 * Side Effects:    None
1603:                	 *
1604:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1605:                	 * 					the channel priority, chaining mode or auto and events detection.
1606:                	 *
1607:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1608:                	 *
1609:                	 * Example:         either:
1610:                	 *                      DmaChnSetControl(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1611:                	 *                  or:
1612:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1613:                	 * 			DmaChnSetControl(DMA_CHANNEL2, chCtrl.w);
1614:                	 *
1615:                	 ********************************************************************/
1616:                #define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1617:                
1618:                	/*********************************************************************
1619:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1620:                	 *
1621:                	 * PreCondition:    chn	- valid DMA channel
1622:                	 *
1623:                	 * Input:			chn			- DMA channel number
1624:                	 *
1625:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1626:                	 * 							- chPri: channel priority 0-3
1627:                	 * 							- autoEn: enable/disable the automatic mode
1628:                	 * 							- chainEn: enable/disable channel chaining
1629:                	 * 							- detectEn: enable/disable events detection when channel disabled
1630:                	 * 							- chEn: enable/disable channel functionality
1631:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1632:                	 *						or any of the DmaChnCtrlFlags flags:
1633:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1634:                	 *
1635:                	 * Side Effects:    None
1636:                	 *
1637:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1638:                	 * 					including the channel enable/disable status, the channel priority,
1639:                	 * 					chaining mode, auto mode and events detection.
1640:                	 *
1641:                	 * Note:            None.
1642:                	 *
1643:                	 * Example:			either:
1644:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL2); if(ctrl&DMA_CTL_AUTO_EN) {...}
1645:                	 * 					or:
1646:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL2); if(chnCtrl.autoEn) {...}
1647:                	 *
1648:                	 ********************************************************************/
1649:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1650:                
1651:                
1652:                	/*********************************************************************
1653:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1654:                	 *
1655:                	 * PreCondition:    chn	- valid DMA channel
1656:                	 *
1657:                	 * Input:			chn		- DMA channel number
1658:                	 *
1659:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1660:                	 *
1661:                	 * Side Effects:    None
1662:                	 *
1663:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1664:                	 *
1665:                	 * Note:            None.
1666:                	 *
1667:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL2);
1668:                	 *
1669:                	 ********************************************************************/
1670:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1671:                
1672:                	/*********************************************************************
1673:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1674:                	 *
1675:                	 * PreCondition:    chn		- valid DMA channel
1676:                	 * 					pTxCtrl	- valid pointer
1677:                	 *
1678:                	 * Input:			chn			- DMA channel number
1679:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1680:                	 * 								- vSrcAdd: source of the DMA transfer
1681:                	 * 								- vDstAdd: destination of the DMA transfer
1682:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1683:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1684:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1685:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1692:                	 * 					the source and the destination addresses.
1693:                	 * 					It also retrieves the source and destination lengths
1694:                	 * 					and the number of bytes	transferred per event.
1695:                	 *
1696:                	 * Note:            None
1697:                	 *
1698:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL2, &txCtl, FALSE);
1699:                	 ********************************************************************/
1700:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1701:                
1702:                	// Low level CRC functions
1703:                
1704:                	/*********************************************************************
1705:                	 * Function:        void DmaCrcEnable(int enable)
1706:                	 *
1707:                	 * PreCondition:    None
1708:                	 *
1709:                	 * Input:           enable - boolean to enable/disable the CRC module
1710:                	 *
1711:                	 * Output:          None
1712:                	 *
1713:                	 * Side Effects:    None
1714:                	 *
1715:                	 * Overview:        The function enables the CRC module functionality and the attached DMA channel transfers are routed to the CRC module.
1716:                	 *
1717:                	 * Note:            The CRC module should be properly configured before enabled.
1718:                	 *
1719:                	 * Example:         CrcEnable(1);
1720:                	 ********************************************************************/
1721:                	extern __inline__ void __attribute__((always_inline)) DmaCrcEnable(int enable)
1722:                	{
1723:                		if(enable)
1724:                		{
1725:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1726:                		}
1727:                		else
1728:                		{
1729:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1730:                		}
1731:                	}
1732:                
1733:                
1734:                
1735:                	/*********************************************************************
1736:                	 * Function:        int DmaCrcGetEnable(void)
1737:                	 *
1738:                	 * PreCondition:    None
1739:                	 *
1740:                	 * Input:			None
1741:                	 *
1742:                	 * Output:          TRUE, if the CRC module is enabled
1743:                	 * 					FALSE otherwise
1744:                	 *
1745:                	 * Side Effects:    None
1746:                	 *
1747:                	 * Overview:		The function returns the CRC module enabling status.
1748:                	 *
1749:                	 * Note:            None
1750:                	 *
1751:                	 * Example:			int isCrcEnabled=DmaCrcGetEnable();
1752:                	 ********************************************************************/
1753:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetEnable(void)
1754:                	{
1755:                		return	DCRCCONbits.CRCEN!=0;
1756:                	}
1757:                
1758:                	
1759:                	/*********************************************************************
1760:                	 * Function:        void DmaCrcAppendModeEnable(int enable)
1761:                	 *
1762:                	 * PreCondition:    None
1763:                	 *
1764:                	 * Input:           enable - boolean to enable/disable the append mode
1765:                	 *
1766:                	 * Output:          None
1767:                	 *
1768:                	 * Side Effects:    None
1769:                	 *
1770:                	 * Overview:		The function enables the CRC append mode. In this mode, the attached DMA channel reads
1771:                	 * 					the source data but does not write it to the destination address. The data it's just passed
1772:                	 * 					to the CRC generator for CRC calculation.
1773:                	 * 					When the block transfer is completed, the CRC result is written to the
1774:                	 * 					DMA channel destination address.
1775:                	 *
1776:                	 * Note:            The CRC module should be properly configured before enabled.
1777:                	 *
1778:                	 * Example:         DmaCrcAppendModeEnable(1);
1779:                	 ********************************************************************/
1780:                	extern __inline__ void __attribute__((always_inline)) DmaCrcAppendModeEnable(int enable)
1781:                	{
1782:                		if(enable)
1783:                		{
1784:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1785:                		}
1786:                		else
1787:                		{
1788:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1789:                		}
1790:                	}
1791:                
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        int DmaCrcGetAppendMode(void)
1795:                	 *
1796:                	 * PreCondition:    None
1797:                	 *
1798:                	 * Input:           None
1799:                	 *
1800:                	 * Output:          TRUE, if the CRC append mode is enabled
1801:                	 * 					FALSE otherwise
1802:                	 *
1803:                	 * Side Effects:    None
1804:                	 *
1805:                	 * Overview:		The function returns the CRC module enabling status.
1806:                	 *
1807:                	 * Note:            None
1808:                	 *
1809:                	 * Example:			int isAppendEnabled=DmaCrcGetAppendMode();
1810:                	 ********************************************************************/
1811:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetAppendMode(void)
1812:                	{
1813:                		return DCRCCONbits.CRCAPP!=0;
1814:                	}
1815:                
1816:                	/*********************************************************************
1817:                	 * Function:        void DmaCrcSetAttach(DmaChannel chn)
1818:                	 *
1819:                	 * PreCondition:    chn		- valid DMA channel
1820:                	 *
1821:                	 * Input:			chn	- the DMA channel to be attached to the CRC module (the DMA channel transfers will be routed to the CRC module)
1822:                	 *
1823:                	 * Output:          None
1824:                	 *
1825:                	 * Side Effects:    None
1826:                	 *
1827:                	 * Overview:		The function attaches a DMA channel to the CRC module.
1828:                	 *
1829:                	 * Note:            None
1830:                	 *
1831:                	 * Example:			DmaCrcSetAttach(DMA_CHANNEL0);
1832:                	 ********************************************************************/
1833:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetAttach(DmaChannel chn)
1834:                	{
1835:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1836:                		DCRCCONSET=chn;
1837:                	}
1838:                		
1839:                	/*********************************************************************
1840:                	 * Function:        DmaChannel DmaCrcGetAttach(void)
1841:                	 *
1842:                	 * PreCondition:    None
1843:                	 *
1844:                	 * Input:			None
1845:                	 *
1846:                	 * Output:          the DMA channel that is currently attached to the CRC module
1847:                	 *
1848:                	 * Side Effects:    None
1849:                	 *
1850:                	 * Overview:		The function returns the DMA channel number that is currently attached to the CRC module.
1851:                	 *
1852:                	 * Note:            None
1853:                	 *
1854:                	 * Example:			DmaChannel chn=DmaCrcGetAttach();
1855:                	 ********************************************************************/
1856:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaCrcGetAttach(void)
1857:                	{
1858:                		return	(DmaChannel)DCRCCONbits.CRCCH;
1859:                	}
1860:                
1861:                
1862:                	/*********************************************************************
1863:                	 * Function:        void DmaCrcSetPLen(int pLen)
1864:                	 *
1865:                	 * PreCondition:    pLen	- valid polynomial length within 1-16
1866:                	 *
1867:                	 * Input:			pLen	- the length of the CRC generator polynomial
1868:                	 *
1869:                	 * Output:          None
1870:                	 *
1871:                	 * Side Effects:    None
1872:                	 *
1873:                	 * Overview:		The length of the CRC generator polynomial is set as being pLen;
1874:                	 *
1875:                	 * Note:            None
1876:                	 *
1877:                	 * Example:         DmaCrcSetPLen(16);
1878:                	 ********************************************************************/
1879:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1880:                	{
1881:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
1882:                		DCRCCONSET=(pLen)-1;
1883:                	}
1884:                		
1885:                	/*********************************************************************
1886:                	 * Function:        int DmaCrcGetPLen(void)
1887:                	 *
1888:                	 * PreCondition:    None
1889:                	 *
1890:                	 * Input:           None
1891:                	 *
1892:                	 * Output:          the length of the CRC generator polynomial
1893:                	 *
1894:                	 * Side Effects:    None
1895:                	 *
1896:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
1897:                	 *                  It's always a number between 1 and 16.
1898:                	 *
1899:                	 * Note:            None
1900:                	 *
1901:                	 * Example:         int polyLen=DmaCrcGetPLen();
1902:                	 ********************************************************************/
1903:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
1904:                	{
1905:                		return	DCRCCONbits.PLEN+1; 
1906:                	}
1907:                	
1908:                
1909:                	/*********************************************************************
1910:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
1911:                	 *
1912:                	 * PreCondition:    None
1913:                	 *
1914:                	 * Input:			feedback	- the layout of the CRC generator
1915:                	 *
1916:                	 * Output:          None
1917:                	 *
1918:                	 * Side Effects:    None
1919:                	 *
1920:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
1921:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1922:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1923:                	 *
1924:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1925:                	 *
1926:                	 * Example:         DmaCrcSetShiftFeedback(0x8005);
1927:                	 ********************************************************************/
1928:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
1929:                	{
1930:                		DCRCXOR=feedback;
1931:                	}
1932:                
1933:                		
1934:                	/*********************************************************************
1935:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
1936:                	 *
1937:                	 * PreCondition:    None
1938:                	 *
1939:                	 * Input:			None
1940:                	 *
1941:                	 * Output:          the current layout of the CRC generator
1942:                	 *
1943:                	 * Side Effects:    None
1944:                	 *
1945:                	 * Overview:		The function returns the layout of the shift stages that take place in the CRC generation.
1946:                	 * 					A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1947:                	 * 					If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1948:                	 *
1949:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1950:                	 *
1951:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
1952:                	 ********************************************************************/
1953:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
1954:                	{
1955:                		return DCRCXOR;
1956:                	}
1957:                
1958:                	/*********************************************************************
1959:                	 * Function:        void DmaCrcSetSeed(unsigned int seed)
1960:                	 *
1961:                	 * PreCondition:    None
1962:                	 *
1963:                	 * Input:			seed	- the initial seed of the CRC generator
1964:                	 *
1965:                	 * Output:          None
1966:                	 *
1967:                	 * Side Effects:    None
1968:                	 *
1969:                	 * Overview:		The function sets the seed of the CRC generator. This is the initial data present in the
1970:                	 * 					CRC shift register before the CRC calculation begins.
1971:                	 *
1972:                	 * Note:            None
1973:                	 *
1974:                	 * Example:			DmaCrcSetSeed(0xffff);
1975:                	 ********************************************************************/
1976:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetSeed(unsigned int seed)
1977:                	{
1978:                		DCRCDATA=seed;
1979:                	}
1980:                		
1981:                	/*********************************************************************
1982:                	 * Function:        unsigned int DmaCrcGetValue(void)
1983:                	 *
1984:                	 * PreCondition:    None
1985:                	 *
1986:                	 * Input:			None
1987:                	 *
1988:                	 * Output:          the current value of the CRC generator
1989:                	 *
1990:                	 * Side Effects:    None
1991:                	 *
1992:                	 * Overview:		The function returns the current value of the CRC generator.
1993:                	 *
1994:                	 * Note:            Only the remainder bits (0 to pLen-1) are significant, the rest should be ignored.
1995:                	 *
1996:                	 * Example:		unsigned int calcCrc=DmaCrcGetValue();
1997:                	 ********************************************************************/
1998:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetValue(void)
1999:                	{
2000:                		return DCRCDATA;
2001:                	}
2002:                
2003:                
2004:                	// Channel test/debug and special functions
2005:                
2006:                	/*********************************************************************
2007:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2008:                	 *
2009:                	 * PreCondition:    chn	- valid DMA channel
2010:                	 *
2011:                	 * Input:			chn		- DMA channel number
2012:                	 * 					eFlags	- event flags with the following significance:
2013:                	 * 								- DMA_EV_ERR: address error event
2014:                	 * 								- DMA_EV_ABORT: transfer abort event
2015:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2016:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2017:                	 * 								- DMA_EV_DST_HALF: destination half event
2018:                	 * 								- DMA_EV_DST_FULL: destination full event
2019:                	 * 								- DMA_EV_SRC_HALF: source half event
2020:                	 * 								- DMA_EV_SRC_FULL: source full event
2021:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2022:                	 *
2023:                	 * Output:          None
2024:                	 *
2025:                	 * Side Effects:    None
2026:                	 *
2027:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2028:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2029:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2030:                	 *
2031:                	 * Note:            This is intended as a channel test function.
2032:                	 *
2033:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2034:                	 ********************************************************************/
2035:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2036:                
2037:                	/*********************************************************************
2038:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2039:                	 *
2040:                	 * PreCondition:    chn	- valid DMA channel
2041:                	 *
2042:                	 * Input:			chn		- DMA channel number
2043:                	 * 					eFlags	- event flags with the following significance:
2044:                	 * 								- DMA_EV_ERR: address error event
2045:                	 * 								- DMA_EV_ABORT: transfer abort event
2046:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2047:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2048:                	 * 								- DMA_EV_DST_HALF: destination half event
2049:                	 * 								- DMA_EV_DST_FULL: destination full event
2050:                	 * 								- DMA_EV_SRC_HALF: source half event
2051:                	 * 								- DMA_EV_SRC_FULL: source full event
2052:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2053:                	 *
2054:                	 * Output:          None
2055:                	 *
2056:                	 * Side Effects:    None
2057:                	 *
2058:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2059:                	 * 					The channel event flags are forced to the eFlags value.
2060:                	 *
2061:                	 * Note:            This is intended as a channel test function.
2062:                	 *
2063:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2064:                	 ********************************************************************/
2065:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2066:                
2067:                
2068:                	/********************************************************************
2069:                	 * Include legacy DMA functions
2070:                	 * New projects should not use them!
2071:                	 * Note that interrupt functions are no longer provided.
2072:                	 * The functions in the int.h should be used instead.
2073:                	 ********************************************************************/
2074:                	#ifndef _PLIB_DISABLE_LEGACY
2075:                		#include <peripheral/legacy/dma_legacy.h>
2076:                	#endif
2077:                
2078:                	 
2079:                #else
2080:                	#undef _DMA_CHANNELS		// no DMA channels
2081:                #endif	// _DMAC0
2082:                
2083:                #endif /*_DMA_H_*/
2084:                
2085:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0001B8  27BDFFF8   ADDIU SP, SP, -8
9D0001BC  AFBE0004   SW FP, 4(SP)
9D0001C0  03A0F025   OR FP, SP, ZERO
9D0001C4  AFC40008   SW A0, 8(FP)
9D0001C8  AFC5000C   SW A1, 12(FP)
9D0001CC  AFC60010   SW A2, 16(FP)
9D0001D0  3C02BF88   LUI V0, -16504
9D0001D4  24030F00   ADDIU V1, ZERO, 3840
9D0001D8  AC433034   SW V1, 12340(V0)
9D0001DC  8FC2000C   LW V0, 12(FP)
9D0001E0  2442FFFF   ADDIU V0, V0, -1
9D0001E4  00021200   SLL V0, V0, 8
9D0001E8  00401825   OR V1, V0, ZERO
9D0001EC  3C02BF88   LUI V0, -16504
9D0001F0  AC433038   SW V1, 12344(V0)
9D0001F4  3C02BF88   LUI V0, -16504
9D0001F8  8FC30010   LW V1, 16(FP)
9D0001FC  AC433040   SW V1, 12352(V0)
9D000200  3C02BF88   LUI V0, -16504
9D000204  8FC30008   LW V1, 8(FP)
9D000208  AC433050   SW V1, 12368(V0)
9D00020C  00000000   NOP
9D000210  03C0E825   OR SP, FP, ZERO
9D000214  8FBE0004   LW FP, 4(SP)
9D000218  27BD0008   ADDIU SP, SP, 8
9D00021C  03E00008   JR RA
9D000220  00000000   NOP
9D000224  27BDFFF8   ADDIU SP, SP, -8
9D000228  AFBE0004   SW FP, 4(SP)
9D00022C  03A0F025   OR FP, SP, ZERO
9D000230  AFC40008   SW A0, 8(FP)
9D000234  8FC20008   LW V0, 8(FP)
9D000238  10400006   BEQ V0, ZERO, 0x9D000254
9D00023C  00000000   NOP
9D000240  3C02BF88   LUI V0, -16504
9D000244  34038000   ORI V1, ZERO, -32768
9D000248  AC433008   SW V1, 12296(V0)
9D00024C  1000000B   BEQ ZERO, ZERO, 0x9D00027C
9D000250  00000000   NOP
9D000254  3C02BF88   LUI V0, -16504
9D000258  34038000   ORI V1, ZERO, -32768
9D00025C  AC433004   SW V1, 12292(V0)
9D000260  00000000   NOP
9D000264  3C02BF88   LUI V0, -16504
9D000268  8C423000   LW V0, 12288(V0)
9D00026C  7C4203C0   EXT V0, V0, 15, 1
9D000270  304200FF   ANDI V0, V0, 255
9D000274  1440FFFB   BNE V0, ZERO, 0x9D000264
9D000278  00000000   NOP
9D00027C  00000000   NOP
9D000280  03C0E825   OR SP, FP, ZERO
9D000284  8FBE0004   LW FP, 4(SP)
9D000288  27BD0008   ADDIU SP, SP, 8
9D00028C  03E00008   JR RA
9D000290  00000000   NOP
9D000294  27BDFFF0   ADDIU SP, SP, -16
9D000298  AFBE000C   SW FP, 12(SP)
9D00029C  03A0F025   OR FP, SP, ZERO
9D0002A0  3C02BF88   LUI V0, -16504
9D0002A4  8C423000   LW V0, 12288(V0)
9D0002A8  7C420300   EXT V0, V0, 12, 1
9D0002AC  304200FF   ANDI V0, V0, 255
9D0002B0  AFC20000   SW V0, 0(FP)
9D0002B4  8FC20000   LW V0, 0(FP)
9D0002B8  1440000B   BNE V0, ZERO, DmaSuspend
9D0002BC  00000000   NOP
9D0002C0  3C02BF88   LUI V0, -16504
9D0002C4  24031000   ADDIU V1, ZERO, 4096
9D0002C8  AC433008   SW V1, 12296(V0)
9D0002CC  00000000   NOP
9D0002D0  3C02BF88   LUI V0, -16504
9D0002D4  8C423000   LW V0, 12288(V0)
9D0002D8  7C420300   EXT V0, V0, 12, 1
9D0002DC  304200FF   ANDI V0, V0, 255
9D0002E0  1040FFFB   BEQ V0, ZERO, DmaSuspend
9D0002E4  00000000   NOP
9D0002E8  8FC20000   LW V0, 0(FP)
9D0002EC  03C0E825   OR SP, FP, ZERO
9D0002F0  8FBE000C   LW FP, 12(SP)
9D0002F4  27BD0010   ADDIU SP, SP, 16
9D0002F8  03E00008   JR RA
9D0002FC  00000000   NOP
9D000300  27BDFFF0   ADDIU SP, SP, -16
9D000304  AFBE000C   SW FP, 12(SP)
9D000308  03A0F025   OR FP, SP, ZERO
9D00030C  AFC40010   SW A0, 16(FP)
9D000310  8FC20010   LW V0, 16(FP)
9D000314  10400014   BEQ V0, ZERO, DmaResume
9D000318  00000000   NOP
9D00031C  3C02BF88   LUI V0, -16504
9D00032C  AFC20000   SW V0, 0(FP)
9D000330  8FC20000   LW V0, 0(FP)
9D00033C  3C02BF88   LUI V0, -16504
9D000348  3C02BF88   LUI V0, -16504
9D000358  1040FFFB   BEQ V0, ZERO, DmaResume
9D000360  10000004   BEQ ZERO, ZERO, DmaResume
9D000364  00000000   NOP
9D000368  3C02BF88   LUI V0, -16504
9D00036C  24031000   ADDIU V1, ZERO, 4096
9D000370  AC433004   SW V1, 12292(V0)
9D000374  00000000   NOP
9D000378  03C0E825   OR SP, FP, ZERO
9D00037C  8FBE000C   LW FP, 12(SP)
9D000380  27BD0010   ADDIU SP, SP, 16
9D000384  03E00008   JR RA
9D000388  00000000   NOP
9D00038C  27BDFFF8   ADDIU SP, SP, -8
9D000390  AFBE0004   SW FP, 4(SP)
9D000394  03A0F025   OR FP, SP, ZERO
9D000398  AFC40008   SW A0, 8(FP)
9D00039C  3C02BF88   LUI V0, -16504
9D0003A0  8FC30008   LW V1, 8(FP)
9D0003A4  AC433008   SW V1, 12296(V0)
9D0003A8  00000000   NOP
9D0003AC  03C0E825   OR SP, FP, ZERO
9D0003B0  8FBE0004   LW FP, 4(SP)
9D0003B4  27BD0008   ADDIU SP, SP, 8
9D0003B8  03E00008   JR RA
9D0003BC  00000000   NOP
9D0003C0  27BDFFF8   ADDIU SP, SP, -8
9D0003C4  AFBE0004   SW FP, 4(SP)
9D0003C8  03A0F025   OR FP, SP, ZERO
9D0003CC  AFC40008   SW A0, 8(FP)
9D0003D0  3C02BF88   LUI V0, -16504
9D0003D4  8FC30008   LW V1, 8(FP)
9D0003D8  AC433004   SW V1, 12292(V0)
9D0003DC  00000000   NOP
9D0003E0  03C0E825   OR SP, FP, ZERO
9D0003E4  8FBE0004   LW FP, 4(SP)
9D0003E8  27BD0008   ADDIU SP, SP, 8
9D0003EC  03E00008   JR RA
9D0003F0  00000000   NOP
9D0003F4  27BDFFF8   ADDIU SP, SP, -8
9D0003F8  AFBE0004   SW FP, 4(SP)
9D0003FC  03A0F025   OR FP, SP, ZERO
9D000400  AFC40008   SW A0, 8(FP)
9D000404  3C02BF88   LUI V0, -16504
9D000408  8FC30008   LW V1, 8(FP)
9D00040C  AC433000   SW V1, 12288(V0)
9D000410  00000000   NOP
9D000414  03C0E825   OR SP, FP, ZERO
9D000418  8FBE0004   LW FP, 4(SP)
9D00041C  27BD0008   ADDIU SP, SP, 8
9D000420  03E00008   JR RA
9D000424  00000000   NOP
9D000428  27BDFFF8   ADDIU SP, SP, -8
9D00042C  AFBE0004   SW FP, 4(SP)
9D000430  03A0F025   OR FP, SP, ZERO
9D000434  3C02BF88   LUI V0, -16504
9D000438  8C423000   LW V0, 12288(V0)
9D00043C  03C0E825   OR SP, FP, ZERO
9D000440  8FBE0004   LW FP, 4(SP)
9D000444  27BD0008   ADDIU SP, SP, 8
9D000448  03E00008   JR RA
9D00044C  00000000   NOP
9D000450  27BDFFF8   ADDIU SP, SP, -8
9D000454  AFBE0004   SW FP, 4(SP)
9D000458  03A0F025   OR FP, SP, ZERO
9D00045C  24020100   ADDIU V0, ZERO, 256
9D000460  03C0E825   OR SP, FP, ZERO
9D000464  8FBE0004   LW FP, 4(SP)
9D000468  27BD0008   ADDIU SP, SP, 8
9D00046C  03E00008   JR RA
9D000470  00000000   NOP
9D000474  27BDFFF8   ADDIU SP, SP, -8
9D000478  AFBE0004   SW FP, 4(SP)
9D00047C  03A0F025   OR FP, SP, ZERO
9D000480  AFC40008   SW A0, 8(FP)
9D000484  8FC20008   LW V0, 8(FP)
9D000488  10400006   BEQ V0, ZERO, 0x9D0004A4
9D00048C  00000000   NOP
9D000490  3C02BF88   LUI V0, -16504
9D000494  24030080   ADDIU V1, ZERO, 128
9D000498  AC433038   SW V1, 12344(V0)
9D00049C  10000004   BEQ ZERO, ZERO, 0x9D0004B0
9D0004A0  00000000   NOP
9D0004A4  3C02BF88   LUI V0, -16504
9D0004A8  24030080   ADDIU V1, ZERO, 128
9D0004AC  AC433034   SW V1, 12340(V0)
9D0004B0  00000000   NOP
9D0004B4  03C0E825   OR SP, FP, ZERO
9D0004B8  8FBE0004   LW FP, 4(SP)
9D0004BC  27BD0008   ADDIU SP, SP, 8
9D0004C0  03E00008   JR RA
9D0004C4  00000000   NOP
9D0004C8  27BDFFF8   ADDIU SP, SP, -8
9D0004CC  AFBE0004   SW FP, 4(SP)
9D0004D0  03A0F025   OR FP, SP, ZERO
9D0004D4  3C02BF88   LUI V0, -16504
9D0004D8  8C423030   LW V0, 12336(V0)
9D0004DC  7C4201C0   EXT V0, V0, 7, 1
9D0004E0  304200FF   ANDI V0, V0, 255
9D0004E4  03C0E825   OR SP, FP, ZERO
9D0004E8  8FBE0004   LW FP, 4(SP)
9D0004EC  27BD0008   ADDIU SP, SP, 8
9D0004F0  03E00008   JR RA
9D0004F4  00000000   NOP
9D0004F8  27BDFFF8   ADDIU SP, SP, -8
9D0004FC  AFBE0004   SW FP, 4(SP)
9D000500  03A0F025   OR FP, SP, ZERO
9D000504  AFC40008   SW A0, 8(FP)
9D000508  8FC20008   LW V0, 8(FP)
9D00050C  10400006   BEQ V0, ZERO, 0x9D000528
9D000510  00000000   NOP
9D000514  3C02BF88   LUI V0, -16504
9D000518  24030040   ADDIU V1, ZERO, 64
9D00051C  AC433038   SW V1, 12344(V0)
9D000520  10000004   BEQ ZERO, ZERO, 0x9D000534
9D000524  00000000   NOP
9D000528  3C02BF88   LUI V0, -16504
9D00052C  24030040   ADDIU V1, ZERO, 64
9D000530  AC433034   SW V1, 12340(V0)
9D000534  00000000   NOP
9D000538  03C0E825   OR SP, FP, ZERO
9D00053C  8FBE0004   LW FP, 4(SP)
9D000540  27BD0008   ADDIU SP, SP, 8
9D000544  03E00008   JR RA
9D000548  00000000   NOP
9D00054C  27BDFFF8   ADDIU SP, SP, -8
9D000550  AFBE0004   SW FP, 4(SP)
9D000554  03A0F025   OR FP, SP, ZERO
9D000558  3C02BF88   LUI V0, -16504
9D00055C  8C423030   LW V0, 12336(V0)
9D000560  7C420180   EXT V0, V0, 6, 1
9D000564  304200FF   ANDI V0, V0, 255
9D000568  03C0E825   OR SP, FP, ZERO
9D00056C  8FBE0004   LW FP, 4(SP)
9D000570  27BD0008   ADDIU SP, SP, 8
9D000574  03E00008   JR RA
9D000578  00000000   NOP
9D00057C  27BDFFF8   ADDIU SP, SP, -8
9D000580  AFBE0004   SW FP, 4(SP)
9D000584  03A0F025   OR FP, SP, ZERO
9D000588  AFC40008   SW A0, 8(FP)
9D00058C  3C02BF88   LUI V0, -16504
9D000590  24030003   ADDIU V1, ZERO, 3
9D000594  AC433034   SW V1, 12340(V0)
9D000598  3C02BF88   LUI V0, -16504
9D00059C  8FC30008   LW V1, 8(FP)
9D0005A0  AC433038   SW V1, 12344(V0)
9D0005A4  00000000   NOP
9D0005A8  03C0E825   OR SP, FP, ZERO
9D0005AC  8FBE0004   LW FP, 4(SP)
9D0005B0  27BD0008   ADDIU SP, SP, 8
9D0005B4  03E00008   JR RA
9D0005B8  00000000   NOP
9D0005BC  27BDFFF8   ADDIU SP, SP, -8
9D0005C0  AFBE0004   SW FP, 4(SP)
9D0005C4  03A0F025   OR FP, SP, ZERO
9D0005C8  3C02BF88   LUI V0, -16504
9D0005CC  8C423030   LW V0, 12336(V0)
9D0005D0  7C420800   EXT V0, V0, 0, 2
9D0005D4  304200FF   ANDI V0, V0, 255
9D0005D8  03C0E825   OR SP, FP, ZERO
9D0005DC  8FBE0004   LW FP, 4(SP)
9D0005E0  27BD0008   ADDIU SP, SP, 8
9D0005E4  03E00008   JR RA
9D0005E8  00000000   NOP
9D0005EC  27BDFFF8   ADDIU SP, SP, -8
9D0005F0  AFBE0004   SW FP, 4(SP)
9D0005F4  03A0F025   OR FP, SP, ZERO
9D0005F8  AFC40008   SW A0, 8(FP)
9D0005FC  3C02BF88   LUI V0, -16504
9D000600  24030F00   ADDIU V1, ZERO, 3840
9D000604  AC433034   SW V1, 12340(V0)
9D000608  8FC20008   LW V0, 8(FP)
9D00060C  2442FFFF   ADDIU V0, V0, -1
9D000610  00401825   OR V1, V0, ZERO
9D000614  3C02BF88   LUI V0, -16504
9D000618  AC433038   SW V1, 12344(V0)
9D00061C  00000000   NOP
9D000620  03C0E825   OR SP, FP, ZERO
9D000624  8FBE0004   LW FP, 4(SP)
9D000628  27BD0008   ADDIU SP, SP, 8
9D00062C  03E00008   JR RA
9D000630  00000000   NOP
9D000634  27BDFFF8   ADDIU SP, SP, -8
9D000638  AFBE0004   SW FP, 4(SP)
9D00063C  03A0F025   OR FP, SP, ZERO
9D000640  3C02BF88   LUI V0, -16504
9D000644  8C423030   LW V0, 12336(V0)
9D000648  7C421A00   EXT V0, V0, 8, 4
9D00064C  304200FF   ANDI V0, V0, 255
9D000650  24420001   ADDIU V0, V0, 1
9D000654  03C0E825   OR SP, FP, ZERO
9D000658  8FBE0004   LW FP, 4(SP)
9D00065C  27BD0008   ADDIU SP, SP, 8
9D000660  03E00008   JR RA
9D000664  00000000   NOP
9D000668  27BDFFF8   ADDIU SP, SP, -8
9D00066C  AFBE0004   SW FP, 4(SP)
9D000670  03A0F025   OR FP, SP, ZERO
9D000674  AFC40008   SW A0, 8(FP)
9D000678  3C02BF88   LUI V0, -16504
9D00067C  8FC30008   LW V1, 8(FP)
9D000680  AC433050   SW V1, 12368(V0)
9D000684  00000000   NOP
9D000688  03C0E825   OR SP, FP, ZERO
9D00068C  8FBE0004   LW FP, 4(SP)
9D000690  27BD0008   ADDIU SP, SP, 8
9D000694  03E00008   JR RA
9D000698  00000000   NOP
9D00069C  27BDFFF8   ADDIU SP, SP, -8
9D0006A0  AFBE0004   SW FP, 4(SP)
9D0006A4  03A0F025   OR FP, SP, ZERO
9D0006A8  3C02BF88   LUI V0, -16504
9D0006AC  8C423050   LW V0, 12368(V0)
9D0006B0  03C0E825   OR SP, FP, ZERO
9D0006B4  8FBE0004   LW FP, 4(SP)
9D0006B8  27BD0008   ADDIU SP, SP, 8
9D0006BC  03E00008   JR RA
9D0006C0  00000000   NOP
9D0006C4  27BDFFF8   ADDIU SP, SP, -8
9D0006C8  AFBE0004   SW FP, 4(SP)
9D0006CC  03A0F025   OR FP, SP, ZERO
9D0006D0  AFC40008   SW A0, 8(FP)
9D0006D4  3C02BF88   LUI V0, -16504
9D0006D8  8FC30008   LW V1, 8(FP)
9D0006DC  AC433040   SW V1, 12352(V0)
9D0006E0  00000000   NOP
9D0006E4  03C0E825   OR SP, FP, ZERO
9D0006E8  8FBE0004   LW FP, 4(SP)
9D0006EC  27BD0008   ADDIU SP, SP, 8
9D0006F0  03E00008   JR RA
9D0006F4  00000000   NOP
9D0006F8  27BDFFF8   ADDIU SP, SP, -8
9D0006FC  AFBE0004   SW FP, 4(SP)
9D000700  03A0F025   OR FP, SP, ZERO
9D000704  3C02BF88   LUI V0, -16504
9D000708  8C423040   LW V0, 12352(V0)
9D00070C  03C0E825   OR SP, FP, ZERO
9D000710  8FBE0004   LW FP, 4(SP)
9D000714  27BD0008   ADDIU SP, SP, 8
9D000718  03E00008   JR RA
9D00071C  00000000   NOP
9D000740  3C02BF88   LUI V0, -16504
9D000750  AFC20020   SW V0, 32(FP)
9D000754  8FC20020   LW V0, 32(FP)
9D000760  3C02BF88   LUI V0, -16504
9D00076C  3C02BF88   LUI V0, -16504
9D00077C  1040FFFB   BEQ V0, ZERO, OSCSetPBDIV
9D000784  8FC20020   LW V0, 32(FP)
9D00080C  8FC20018   LW V0, 24(FP)
9D000818  3C02BF88   LUI V0, -16504
9D000828  AFC2001C   SW V0, 28(FP)
9D00082C  8FC2001C   LW V0, 28(FP)
9D000838  3C02BF88   LUI V0, -16504
9D000844  3C02BF88   LUI V0, -16504
9D000854  1040FFFB   BEQ V0, ZERO, OSCSetPBDIV
9D000864  3C02BF88   LUI V0, -16504
9D000900  3C02BF88   LUI V0, -16504
9D000910  AFC20020   SW V0, 32(FP)
9D000914  8FC20020   LW V0, 32(FP)
9D000920  3C02BF88   LUI V0, -16504
9D00092C  3C02BF88   LUI V0, -16504
9D00093C  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPB
9D000944  8FC20020   LW V0, 32(FP)
9D0009CC  8FC20028   LW V0, 40(FP)
9D0009D8  3C02BF88   LUI V0, -16504
9D0009E8  AFC2002C   SW V0, 44(FP)
9D0009EC  8FC2002C   LW V0, 44(FP)
9D0009F8  3C02BF88   LUI V0, -16504
9D000A04  3C02BF88   LUI V0, -16504
9D000A14  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPB
9D000A24  3C02BF88   LUI V0, -16504
9D000B60  3C02BF88   LUI V0, -16504
9D000B70  AFC20030   SW V0, 48(FP)
9D000B74  8FC20030   LW V0, 48(FP)
9D000B80  3C02BF88   LUI V0, -16504
9D000B8C  3C02BF88   LUI V0, -16504
9D000B9C  1040FFFB   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D000BA4  8FC20030   LW V0, 48(FP)
9D000C2C  8FC20038   LW V0, 56(FP)
9D000C38  3C02BF88   LUI V0, -16504
9D000C48  AFC2003C   SW V0, 60(FP)
9D000C4C  8FC2003C   LW V0, 60(FP)
9D000C58  3C02BF88   LUI V0, -16504
9D000C64  3C02BF88   LUI V0, -16504
9D000C74  1040FFFB   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D000C84  3C02BF88   LUI V0, -16504
9D000DA0  3C02BF88   LUI V0, -16504
9D000DB0  AFC20034   SW V0, 52(FP)
9D000DB4  8FC20034   LW V0, 52(FP)
9D000DC0  3C02BF88   LUI V0, -16504
9D000DCC  3C02BF88   LUI V0, -16504
9D000DDC  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPerformance
9D000DE4  8FC20034   LW V0, 52(FP)
9D000E6C  8FC2003C   LW V0, 60(FP)
9D000E78  3C02BF88   LUI V0, -16504
9D000E88  AFC20040   SW V0, 64(FP)
9D000E8C  8FC20040   LW V0, 64(FP)
9D000E98  3C02BF88   LUI V0, -16504
9D000EA4  3C02BF88   LUI V0, -16504
9D000EB4  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPerformance
9D000EC4  3C02BF88   LUI V0, -16504
9D0010DC  3C02BF88   LUI V0, -16504
9D0010EC  AFC2003C   SW V0, 60(FP)
9D0010F0  8FC2003C   LW V0, 60(FP)
9D0010FC  3C02BF88   LUI V0, -16504
9D001108  3C02BF88   LUI V0, -16504
9D001118  1040FFFB   BEQ V0, ZERO, 0x9D001108
9D001120  8FC2003C   LW V0, 60(FP)
9D0011A8  8FC20044   LW V0, 68(FP)
9D0011B4  3C02BF88   LUI V0, -16504
9D0011C4  AFC20048   SW V0, 72(FP)
9D0011C8  8FC20048   LW V0, 72(FP)
9D0011D4  3C02BF88   LUI V0, -16504
9D0011E0  3C02BF88   LUI V0, -16504
9D0011F0  1040FFFB   BEQ V0, ZERO, 0x9D0011E0
9D001200  3C02BF88   LUI V0, -16504
9D001574  3C02BF88   LUI V0, -16504
9D001584  AFC2002C   SW V0, 44(FP)
9D001588  8FC2002C   LW V0, 44(FP)
9D001594  3C02BF88   LUI V0, -16504
9D0015A0  3C02BF88   LUI V0, -16504
9D0015B0  1040FFFB   BEQ V0, ZERO, 0x9D0015A0
9D0015B8  8FC2002C   LW V0, 44(FP)
9D001640  8FC20034   LW V0, 52(FP)
9D00164C  3C02BF88   LUI V0, -16504
9D00165C  AFC20038   SW V0, 56(FP)
9D001660  8FC20038   LW V0, 56(FP)
9D00166C  3C02BF88   LUI V0, -16504
9D001678  3C02BF88   LUI V0, -16504
9D001688  1040FFFB   BEQ V0, ZERO, 0x9D001678
9D001698  3C02BF88   LUI V0, -16504
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-reset.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001F68  03E00008   JR RA
9D001F6C  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-bootstrap.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001F70  03E00008   JR RA
9D001F74  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-general-exception-handler.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001DD4  3C020000   LUI V0, 0
9D001DD8  24420000   ADDIU V0, V0, 0
9D001DDC  10400005   BEQ V0, ZERO, 0x9D001DF4
9D001DE0  3C020000   LUI V0, 0
9D001DE4  24420000   ADDIU V0, V0, 0
9D001DE8  10400003   BEQ V0, ZERO, 0x9D001DF8
9D001DEC  3C029D00   LUI V0, -25344
9D001DF0  7000003F   SDBBP 0
9D001DF4  3C029D00   LUI V0, -25344
9D001DF8  24421E64   ADDIU V0, V0, 7780
9D001DFC  10400005   BEQ V0, ZERO, 0x9D001E14
9D001E00  00000000   NOP
9D001E04  27BDFFE8   ADDIU SP, SP, -24
9D001E08  AFBF0014   SW RA, 20(SP)
9D001E0C  0040F809   JALR V0
9D001E10  00000000   NOP
9D001E14  1000FFFF   BEQ ZERO, ZERO, 0x9D001E14
9D001E18  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-bootstrap-exception-handler.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001D8C  3C020000   LUI V0, 0
9D001D90  24420000   ADDIU V0, V0, 0
9D001D94  10400005   BEQ V0, ZERO, 0x9D001DAC
9D001D98  3C020000   LUI V0, 0
9D001D9C  24420000   ADDIU V0, V0, 0
9D001DA0  10400003   BEQ V0, ZERO, 0x9D001DB0
9D001DA4  3C029D00   LUI V0, -25344
9D001DA8  7000003F   SDBBP 0
9D001DAC  3C029D00   LUI V0, -25344
9D001DB0  24421E64   ADDIU V0, V0, 7780
9D001DB4  10400005   BEQ V0, ZERO, 0x9D001DCC
9D001DB8  00000000   NOP
9D001DBC  27BDFFE8   ADDIU SP, SP, -24
9D001DC0  AFBF0014   SW RA, 20(SP)
9D001DC4  0040F809   JALR V0
9D001DC8  00000000   NOP
9D001DCC  1000FFFF   BEQ ZERO, ZERO, 0x9D001DCC
9D001DD0  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/default_vector_dispatch/defaultinterrupt.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001E1C  3C020000   LUI V0, 0
9D001E20  24420000   ADDIU V0, V0, 0
9D001E24  10400007   BEQ V0, ZERO, 0x9D001E44
9D001E28  3C020000   LUI V0, 0
9D001E2C  24420000   ADDIU V0, V0, 0
9D001E30  50400005   BEQL V0, ZERO, 0x9D001E48
9D001E34  3C029D00   LUI V0, -25344
9D001E38  7000003F   SDBBP 0
9D001E3C  03E00008   JR RA
9D001E40  00000000   NOP
9D001E44  3C029D00   LUI V0, -25344
9D001E48  24421E64   ADDIU V0, V0, 7780
9D001E4C  10400003   BEQ V0, ZERO, 0x9D001E5C
9D001E50  00000000   NOP
9D001E54  0040F809   JALR V0
9D001E58  00000000   NOP
9D001E5C  03E00008   JR RA
9D001E60  00000000   NOP
