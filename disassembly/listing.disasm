Disassembly Listing for C32MX_Servo
Generated From:
E:/EDocuments/Code/32MX4/C32MX_Servo.X/dist/Debug/debug/C32MX_Servo.X.debug.elf
Aug 25, 2022 6:03:48 PM

---  e:/edocuments/code/32mx4/c32mx_servo.x/main.c  -----------------------------------------------------
1:                   /* 
2:                    * File:   main.c
3:                    * Author: Chris
4:                    *
5:                    * Created on August 24, 2022, 10:36 PM
6:                    * 
7:                    * This demo will be using a single Injora INJO025-270 servo
8:                    * 330 Hz (3030.3us) pulse: 1500us center, 500us min, 2500us max. 4us dead-zone
9:                    * operating at 4.8-6.0 VDC
10:                   */
11:                  
12:                  #define _SUPPRESS_PLIB_WARNING
13:                  
14:                  #include "Cerebot32MX4.h"
15:                  #include <p32xxxx.h>
16:                  #include <plib.h> 
17:                  //#include <stdint.h>
18:                  
19:                  #include "stdtypes.h"
20:                  
21:                  #define servoPeriod_us 3030
22:                  #define servo_neutral_us 1500
23:                  #define servo_lowest_us 500
24:                  #define servo_highest_us 2500
25:                  
26:                  
27:                  /* ------------------------------------------------------------ */
28:                  /*				Global Variables								*/
29:                  /* ------------------------------------------------------------ */
30:                  volatile int t_chg = 5;
31:                  volatile int chg_cur = 0;
32:                  volatile int m_chg = 20; // The period and mag of the hard-coded
33:                  volatile int m_cur = 0;
34:                  volatile int dt = 1;
35:                  // servo movements, in main
36:                  
37:                  /* ------------------------------------------------------------ */
38:                  /*				Set Up of System Clock							*/
39:                  /* ------------------------------------------------------------ */
40:                  // Configuration Bit settings for System Clock = 80 MHz
41:                  //  Primary Osc w/PLL (XT+,HS+,EC+PLL)
42:                  //  Input Divider	2x Divider
43:                  //	Multiplier		18x Multiplier
44:                  //  WDT disabled
45:                  //  Other options are don't cares
46:                  
47:                  #define F_CPU 80000000L
48:                  
49:                  /* ------------------------------------------------------------ */
50:                  /*				Forward Declarations							*/
51:                  /* ------------------------------------------------------------ */
52:                  void deviceInit(void);
53:                  void appInit(void);
54:                  
55:                  /* ------------------------------------------------------------ */
56:                  /*				Interrupt Service Routines						*/
57:                  
58:                  /* ------------------------------------------------------------ */
59:                  void __ISR(_TIMER_1_VECTOR, ipl7auto) Timer1Handler(void) {
60:                      prtServo1 = (1 << bnServo1);
61:                      if (chg_cur == 0) {
62:                          chg_cur = t_chg;
63:                  
64:                          if ((m_cur >= servo_highest_us) || (m_cur <= servo_lowest_us)) {
65:                              dt *= -1;
66:                          }
67:                  
68:                          m_cur = m_cur + m_chg * dt;
69:                          OC1R = m_cur;
70:                      } else {
71:                          chg_cur--;
72:                      }
73:                  
74:                      IFS0CLR = (1 << 4); // clear interrupt flag for timer 1
75:                  }
76:                  
77:                  void __ISR(_OUTPUT_COMPARE_1_VECTOR, ipl7auto) OC1_IntHandler(void) {
78:                      prtServo1 &= ~(1 << bnServo1);
79:                      IFS0CLR = (1 << 6); // clear interrupt flag for output compare 1	
80:                  }
81:                  
82:                  /*
83:                   *  main
84:                   */
85:                  int main(void) {
86:                  
87:                      deviceInit();
88:                      appInit();
89:                  
90:                      m_cur = servo_neutral_us;
91:                  
92:                      while (1) {
93:                          _nop();
94:                      }
95:                  
96:                      return (EXIT_SUCCESS);
97:                  }
98:                  
99:                  void deviceInit() {
100:                     //    int pbFreq;
101:                 
102:                     // Configure the device for maximum performance.
103:                     // This macro sets flash wait states, PBCLK divider and DRM wait states
104:                     // based on the specified clock frequency.  
105:                     // It also turns on the cache mode if available.  
106:                     // Returns the PB frequency
107:                     //pbFreq = SYSTEMConfigPerformance(F_CPU);
108:                 
109:                     //Microchip recommends typing unused pins to ground
110:                     PORTA = 0;
111:                     PORTB = 0;
112:                     PORTC = 0;
113:                     PORTD = 0;
114:                     PORTE = 0;
115:                     PORTF = 0;
116:                     PORTG = 0;
117:                 
118:                     TRISA = 0;
119:                     TRISB = 0;
120:                     TRISC = 0;
121:                     TRISD = 0;
122:                     TRISE = 0;
123:                     TRISF = 0;
124:                     TRISG = 0;
125:                 
126:                     // Set the LEDs as outputs
127:                     prtLed1_4 &= ~((1 << bnLed1) | (1 << bnLed2) | (1 << bnLed3) | (1 << bnLed4)); //LLV
128:                     trisLed1_4 &= ~((1 << bnLed1) | (1 << bnLed2) | (1 << bnLed3) | (1 << bnLed4)); //output
129:                 
130:                     //Set up the i/o pins we are using for the servo channels
131:                     //as outputs.
132:                     prtServo1 &= ~(1 << bnServo1);
133:                     trisServo1 &= ~(1 << bnServo1);
134:                 }
135:                 
136:                 void appInit() {
137:                     // Set up timer 1 with overflow and output compare
138:                     OC1CON |= (2 << 0); // OCM mode 2, init high, low on compare
139:                     OC1R |= servo_neutral_us; // Start off with the servo in the middle
140:                     IPC1 |= (7 << 2) | (2 << 0) | (7 << 18) | (2 << 16); // Interrupt P7S2 for both
141:                     IFS0 &= ~(1 << 4) | ~(1 << 6); // Clear the int flags for T1 and OC1
142:                     IEC0 |= (1 << 4) | (1 << 6); // Enable ints for T1 and OC1  
143:                 
144:                     T1CON &= ~0xffff; // Clear T1 control reg
145:                     TMR1 = 0x0; // Reset its count
146:                     PR1 = 30303U; // Set the period to 3030.3us (8/FCPU=0.1us)
147:                     T1CON |= (1 << 15); // Enable T1 with no prescale    
148:                 
149:                     // Enable multi-vector interrupts.
150:                     INTEnableSystemMultiVectoredInt();
151:                     return;
152:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001E54  415DE800   RDPGPR SP, SP
9D001E58  401B7000   MFC0 K1, EPC
9D001E5C  401A6002   MFC0 K0, SRSCtl
9D001E60  27BDFFD8   ADDIU SP, SP, -40
9D001E64  401B6000   MFC0 K1, Status
9D001E68  AFBA0020   SW K0, 32(SP)
9D001E6C  AFBB0024   SW K1, 36(SP)
9D001E70  7C1B7844   INS K1, ZERO, 1, 15
9D001E74  377B1C00   ORI K1, K1, 7168
9D001E78  409B6000   MTC0 K1, Status
9D001E7C  AFA30008   SW V1, 8(SP)
9D001E80  AFA20004   SW V0, 4(SP)
9D001E84  8FA30020   LW V1, 32(SP)
9D001E88  3063000F   ANDI V1, V1, 15
9D001E8C  AFBE000C   SW FP, 12(SP)
9D001E90  00000000   NOP
9D001E94  00001012   MFLO V0
9D001E98  AFA20014   SW V0, 20(SP)
9D001E9C  00001810   MFHI V1
9D001EA0  AFA30010   SW V1, 16(SP)
9D001EA4  03A0F025   OR FP, SP, ZERO
9D001EA8  3C02BF88   LUI V0, -16504
9D001EAC  24031000   ADDIU V1, ZERO, 4096
9D001EB0  AC436190   SW V1, 24976(V0)
9D001EB4  8F82801C   LW V0, -32740(GP)
9D001EB8  1440001A   BNE V0, ZERO, 0x9D001F24
9D001EBC  00000000   NOP
9D001EC0  8F828010   LW V0, -32752(GP)
9D001EC4  AF82801C   SW V0, -32740(GP)
9D001EC8  8F828020   LW V0, -32736(GP)
9D001ECC  284209C4   SLTI V0, V0, 2500
9D001ED0  10400005   BEQ V0, ZERO, 0x9D001EE8
9D001ED4  00000000   NOP
9D001ED8  8F828020   LW V0, -32736(GP)
9D001EDC  284201F5   SLTI V0, V0, 501
9D001EE0  10400004   BEQ V0, ZERO, 0x9D001EF4
9D001EE4  00000000   NOP
9D001EE8  8F828018   LW V0, -32744(GP)
9D001EEC  00021023   SUBU V0, ZERO, V0
9D001EF0  AF828018   SW V0, -32744(GP)
9D001EF4  8F838014   LW V1, -32748(GP)
9D001EF8  8F828018   LW V0, -32744(GP)
9D001EFC  70621802   MUL V1, V1, V0
9D001F00  8F828020   LW V0, -32736(GP)
9D001F04  00621021   ADDU V0, V1, V0
9D001F08  AF828020   SW V0, -32736(GP)
9D001F0C  8F828020   LW V0, -32736(GP)
9D001F10  00401825   OR V1, V0, ZERO
9D001F14  3C02BF80   LUI V0, -16512
9D001F18  AC433010   SW V1, 12304(V0)
9D001F1C  10000004   BEQ ZERO, ZERO, 0x9D001F30
9D001F20  00000000   NOP
9D001F24  8F82801C   LW V0, -32740(GP)
9D001F28  2442FFFF   ADDIU V0, V0, -1
9D001F2C  AF82801C   SW V0, -32740(GP)
9D001F30  3C02BF88   LUI V0, -16504
9D001F34  24030010   ADDIU V1, ZERO, 16
9D001F38  AC431034   SW V1, 4148(V0)
9D001F3C  00000000   NOP
9D001F40  03C0E825   OR SP, FP, ZERO
9D001F44  8FA20014   LW V0, 20(SP)
9D001F48  00400013   MTLO V0
9D001F4C  8FA30010   LW V1, 16(SP)
9D001F50  00600011   MTHI V1
9D001F54  8FA20020   LW V0, 32(SP)
9D001F58  3042000F   ANDI V0, V0, 15
9D001F5C  14400004   BNE V0, ZERO, 0x9D001F70
9D001F60  00000000   NOP
9D001F64  8FBE000C   LW FP, 12(SP)
9D001F68  8FA30008   LW V1, 8(SP)
9D001F6C  8FA20004   LW V0, 4(SP)
9D001F70  00000000   NOP
9D001F74  8FBB0024   LW K1, 36(SP)
9D001F78  8FBA0020   LW K0, 32(SP)
9D001F7C  27BD0028   ADDIU SP, SP, 40
9D001F80  409A6002   MTC0 K0, SRSCtl
9D001F84  41DDE800   WRPGPR SP, SP
9D001F88  409B6000   MTC0 K1, Status
9D001F8C  42000018   ERET
9D001F90  415DE800   RDPGPR SP, SP
9D001F94  401B7000   MFC0 K1, EPC
9D001F98  401A6002   MFC0 K0, SRSCtl
9D001F9C  27BDFFE0   ADDIU SP, SP, -32
9D001FA0  401B6000   MFC0 K1, Status
9D001FA4  AFBA0018   SW K0, 24(SP)
9D001FA8  AFBB001C   SW K1, 28(SP)
9D001FAC  7C1B7844   INS K1, ZERO, 1, 15
9D001FB0  377B1C00   ORI K1, K1, 7168
9D001FB4  409B6000   MTC0 K1, Status
9D001FB8  AFA30008   SW V1, 8(SP)
9D001FBC  AFA20004   SW V0, 4(SP)
9D001FC0  8FA30018   LW V1, 24(SP)
9D001FC4  3063000F   ANDI V1, V1, 15
9D001FC8  AFBE000C   SW FP, 12(SP)
9D001FCC  00000000   NOP
9D001FD0  03A0F025   OR FP, SP, ZERO
9D001FD4  3C02BF88   LUI V0, -16504
9D001FD8  8C426190   LW V0, 24976(V0)
9D001FDC  7C026304   INS V0, ZERO, 12, 1
9D001FE0  00401825   OR V1, V0, ZERO
9D001FE4  3C02BF88   LUI V0, -16504
9D001FE8  AC436190   SW V1, 24976(V0)
9D001FEC  3C02BF88   LUI V0, -16504
9D001FF0  24030040   ADDIU V1, ZERO, 64
9D001FF4  AC431034   SW V1, 4148(V0)
9D001FF8  00000000   NOP
9D001FFC  03C0E825   OR SP, FP, ZERO
9D002000  8FA20018   LW V0, 24(SP)
9D002004  3042000F   ANDI V0, V0, 15
9D002008  14400004   BNE V0, ZERO, 0x9D00201C
9D00200C  00000000   NOP
9D002010  8FBE000C   LW FP, 12(SP)
9D002014  8FA30008   LW V1, 8(SP)
9D002018  8FA20004   LW V0, 4(SP)
9D00201C  00000000   NOP
9D002020  8FBB001C   LW K1, 28(SP)
9D002024  8FBA0018   LW K0, 24(SP)
9D002028  27BD0020   ADDIU SP, SP, 32
9D00202C  409A6002   MTC0 K0, SRSCtl
9D002030  41DDE800   WRPGPR SP, SP
9D002034  409B6000   MTC0 K1, Status
9D002038  42000018   ERET
9D00203C  27BDFFE8   ADDIU SP, SP, -24
9D002040  AFBF0014   SW RA, 20(SP)
9D002044  AFBE0010   SW FP, 16(SP)
9D002048  03A0F025   OR FP, SP, ZERO
9D00204C  0F40081C   JAL deviceInit
9D002050  00000000   NOP
9D002054  0F400859   JAL appInit
9D002058  00000000   NOP
9D00205C  240205DC   ADDIU V0, ZERO, 1500
9D002060  AF828020   SW V0, -32736(GP)
9D002064  00000040   SSNOP
9D002068  1000FFFE   BEQ ZERO, ZERO, main
9D00206C  00000000   NOP
9D002070  27BDFFF8   ADDIU SP, SP, -8
9D002074  AFBE0004   SW FP, 4(SP)
9D002078  03A0F025   OR FP, SP, ZERO
9D00207C  3C02BF88   LUI V0, -16504
9D002080  AC406010   SW ZERO, 24592(V0)
9D002084  3C02BF88   LUI V0, -16504
9D002088  AC406050   SW ZERO, 24656(V0)
9D00208C  3C02BF88   LUI V0, -16504
9D002090  AC406090   SW ZERO, 24720(V0)
9D002094  3C02BF88   LUI V0, -16504
9D002098  AC4060D0   SW ZERO, 24784(V0)
9D00209C  3C02BF88   LUI V0, -16504
9D0020A0  AC406110   SW ZERO, 24848(V0)
9D0020A4  3C02BF88   LUI V0, -16504
9D0020A8  AC406150   SW ZERO, 24912(V0)
9D0020AC  3C02BF88   LUI V0, -16504
9D0020B0  AC406190   SW ZERO, 24976(V0)
9D0020B4  3C02BF88   LUI V0, -16504
9D0020B8  AC406000   SW ZERO, 24576(V0)
9D0020BC  3C02BF88   LUI V0, -16504
9D0020C0  AC406040   SW ZERO, 24640(V0)
9D0020C4  3C02BF88   LUI V0, -16504
9D0020C8  AC406080   SW ZERO, 24704(V0)
9D0020CC  3C02BF88   LUI V0, -16504
9D0020D0  AC4060C0   SW ZERO, 24768(V0)
9D0020D4  3C02BF88   LUI V0, -16504
9D0020D8  AC406100   SW ZERO, 24832(V0)
9D0020DC  3C02BF88   LUI V0, -16504
9D0020E0  AC406140   SW ZERO, 24896(V0)
9D0020E4  3C02BF88   LUI V0, -16504
9D0020E8  AC406180   SW ZERO, 24960(V0)
9D0020EC  3C02BF88   LUI V0, -16504
9D0020F0  8C426050   LW V0, 24656(V0)
9D0020F4  7C026A84   INS V0, ZERO, 10, 4
9D0020F8  00401825   OR V1, V0, ZERO
9D0020FC  3C02BF88   LUI V0, -16504
9D002100  AC436050   SW V1, 24656(V0)
9D002104  3C02BF88   LUI V0, -16504
9D002108  8C426040   LW V0, 24640(V0)
9D00210C  7C026A84   INS V0, ZERO, 10, 4
9D002110  00401825   OR V1, V0, ZERO
9D002114  3C02BF88   LUI V0, -16504
9D002118  AC436040   SW V1, 24640(V0)
9D00211C  3C02BF88   LUI V0, -16504
9D002120  8C426190   LW V0, 24976(V0)
9D002124  7C026304   INS V0, ZERO, 12, 1
9D002128  00401825   OR V1, V0, ZERO
9D00212C  3C02BF88   LUI V0, -16504
9D002130  AC436190   SW V1, 24976(V0)
9D002134  3C02BF88   LUI V0, -16504
9D002138  8C426180   LW V0, 24960(V0)
9D00213C  7C026304   INS V0, ZERO, 12, 1
9D002140  00401825   OR V1, V0, ZERO
9D002144  3C02BF88   LUI V0, -16504
9D002148  AC436180   SW V1, 24960(V0)
9D00214C  00000000   NOP
9D002150  03C0E825   OR SP, FP, ZERO
9D002154  8FBE0004   LW FP, 4(SP)
9D002158  27BD0008   ADDIU SP, SP, 8
9D00215C  03E00008   JR RA
9D002160  00000000   NOP
9D002164  27BDFFE8   ADDIU SP, SP, -24
9D002168  AFBF0014   SW RA, 20(SP)
9D00216C  AFBE0010   SW FP, 16(SP)
9D002170  03A0F025   OR FP, SP, ZERO
9D002174  3C02BF80   LUI V0, -16512
9D002178  8C423000   LW V0, 12288(V0)
9D00217C  34430002   ORI V1, V0, 2
9D002180  3C02BF80   LUI V0, -16512
9D002184  AC433000   SW V1, 12288(V0)
9D002188  3C02BF80   LUI V0, -16512
9D00218C  8C423010   LW V0, 12304(V0)
9D002190  344305DC   ORI V1, V0, 1500
9D002194  3C02BF80   LUI V0, -16512
9D002198  AC433010   SW V1, 12304(V0)
9D00219C  3C02BF88   LUI V0, -16504
9D0021A0  8C4310A0   LW V1, 4256(V0)
9D0021A4  3C02001E   LUI V0, 30
9D0021A8  3442001E   ORI V0, V0, 30
9D0021AC  00621825   OR V1, V1, V0
9D0021B0  3C02BF88   LUI V0, -16504
9D0021B4  AC4310A0   SW V1, 4256(V0)
9D0021B8  3C02BF88   LUI V0, -16504
9D0021BC  8C431030   LW V1, 4144(V0)
9D0021C0  3C02BF88   LUI V0, -16504
9D0021C4  AC431030   SW V1, 4144(V0)
9D0021C8  3C02BF88   LUI V0, -16504
9D0021CC  8C421060   LW V0, 4192(V0)
9D0021D0  34430050   ORI V1, V0, 80
9D0021D4  3C02BF88   LUI V0, -16504
9D0021D8  AC431060   SW V1, 4192(V0)
9D0021DC  3C02BF80   LUI V0, -16512
9D0021E0  8C420600   LW V0, 1536(V0)
9D0021E4  7C027804   INS V0, ZERO, 0, 16
9D0021E8  00401825   OR V1, V0, ZERO
9D0021EC  3C02BF80   LUI V0, -16512
9D0021F0  AC430600   SW V1, 1536(V0)
9D0021F4  3C02BF80   LUI V0, -16512
9D0021F8  AC400610   SW ZERO, 1552(V0)
9D0021FC  3C02BF80   LUI V0, -16512
9D002200  2403765F   ADDIU V1, ZERO, 30303
9D002204  AC430620   SW V1, 1568(V0)
9D002208  3C02BF80   LUI V0, -16512
9D00220C  8C420600   LW V0, 1536(V0)
9D002210  34438000   ORI V1, V0, -32768
9D002214  3C02BF80   LUI V0, -16512
9D002218  AC430600   SW V1, 1536(V0)
9D00221C  0F4009AB   JAL INTEnableSystemMultiVectoredInt
9D002220  00000000   NOP
9D002224  00000000   NOP
9D002228  03C0E825   OR SP, FP, ZERO
9D00222C  8FBF0014   LW RA, 20(SP)
9D002230  8FBE0010   LW FP, 16(SP)
9D002234  27BD0018   ADDIU SP, SP, 24
9D002238  03E00008   JR RA
9D00223C  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/uart.h  --------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                  	volatile UINT	reg;
92:                  	volatile UINT	clr;
93:                  	volatile UINT	set;
94:                  	volatile UINT	inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                  	volatile REG_SET	mode;
100:                 	volatile REG_SET	sta;
101:                 	volatile REG_SET    tx;
102:                 	volatile REG_SET	rx;
103:                 	volatile REG_SET	brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                 	#define PERIPHERAL_CLOCK    10000000
628:                 	#define DESIRED_DATA_RATE   19200
629:                 	
630:                 	UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                 	#define PERIPHERAL_CLOCK    10000000
673:                 	
674:                 	UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 	
749:                 	lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 	
798:                 	data = 'a';
799:                 	
800:                 	if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                 	unsigned char data;
841:                 	
842:                 	data = 'a';
843:                 	
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 	
890:                 	if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                 	if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 	
973:                 	if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                	
1015:                	if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                	
1055:                	if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                	
1105:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                	
1147:                	// Set the address, but don't enable the watch until later,
1148:                	// UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                	// methods to detect a Break.
1233:                	
1234:                    if (breakDetected && useAutoRateDetect) 
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                	transmitting data while it is trying to detect RX baud rate, see the 
1247:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                	
1281:                	UINT32 currentRate;
1282:                	
1283:                	if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                	at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001B08  27BDFFF8   ADDIU SP, SP, -8
9D001B0C  AFBE0004   SW FP, 4(SP)
9D001B10  03A0F025   OR FP, SP, ZERO
9D001B14  AFC40008   SW A0, 8(FP)
9D001B18  3C029D00   LUI V0, -25344
9D001B1C  8FC30008   LW V1, 8(FP)
9D001B20  00031880   SLL V1, V1, 2
9D001B24  24422834   ADDIU V0, V0, 10292
9D001B28  00621021   ADDU V0, V1, V0
9D001B2C  8C420000   LW V0, 0(V0)
9D001B30  8C420010   LW V0, 16(V0)
9D001B34  3042031F   ANDI V0, V0, 799
9D001B38  03C0E825   OR SP, FP, ZERO
9D001B3C  8FBE0004   LW FP, 4(SP)
9D001B40  27BD0008   ADDIU SP, SP, 8
9D001B44  03E00008   JR RA
9D001B48  00000000   NOP
9D001B4C  27BDFFF8   ADDIU SP, SP, -8
9D001B50  AFBE0004   SW FP, 4(SP)
9D001B54  03A0F025   OR FP, SP, ZERO
9D001B58  AFC40008   SW A0, 8(FP)
9D001B5C  3C029D00   LUI V0, -25344
9D001B60  8FC30008   LW V1, 8(FP)
9D001B64  00031880   SLL V1, V1, 2
9D001B68  24422834   ADDIU V0, V0, 10292
9D001B6C  00621021   ADDU V0, V1, V0
9D001B70  8C420000   LW V0, 0(V0)
9D001B74  8C420010   LW V0, 16(V0)
9D001B78  30420200   ANDI V0, V0, 512
9D001B7C  2C420001   SLTIU V0, V0, 1
9D001B80  304200FF   ANDI V0, V0, 255
9D001B84  03C0E825   OR SP, FP, ZERO
9D001B88  8FBE0004   LW FP, 4(SP)
9D001B8C  27BD0008   ADDIU SP, SP, 8
9D001B90  03E00008   JR RA
9D001B94  00000000   NOP
9D001B98  27BDFFF8   ADDIU SP, SP, -8
9D001B9C  AFBE0004   SW FP, 4(SP)
9D001BA0  03A0F025   OR FP, SP, ZERO
9D001BA4  AFC40008   SW A0, 8(FP)
9D001BA8  00A01025   OR V0, A1, ZERO
9D001BAC  A3C2000C   SB V0, 12(FP)
9D001BB0  3C029D00   LUI V0, -25344
9D001BB4  8FC30008   LW V1, 8(FP)
9D001BB8  00031880   SLL V1, V1, 2
9D001BBC  24422834   ADDIU V0, V0, 10292
9D001BC0  00621021   ADDU V0, V1, V0
9D001BC4  8C420000   LW V0, 0(V0)
9D001BC8  93C3000C   LBU V1, 12(FP)
9D001BCC  AC430020   SW V1, 32(V0)
9D001BD0  00000000   NOP
9D001BD4  03C0E825   OR SP, FP, ZERO
9D001BD8  8FBE0004   LW FP, 4(SP)
9D001BDC  27BD0008   ADDIU SP, SP, 8
9D001BE0  03E00008   JR RA
9D001BE4  00000000   NOP
9D001BE8  27BDFFF8   ADDIU SP, SP, -8
9D001BEC  AFBE0004   SW FP, 4(SP)
9D001BF0  03A0F025   OR FP, SP, ZERO
9D001BF4  AFC40008   SW A0, 8(FP)
9D001BF8  A7C5000C   SH A1, 12(FP)
9D001BFC  97C4000C   LHU A0, 12(FP)
9D001C00  3C029D00   LUI V0, -25344
9D001C04  8FC30008   LW V1, 8(FP)
9D001C08  00031880   SLL V1, V1, 2
9D001C0C  24422834   ADDIU V0, V0, 10292
9D001C10  00621021   ADDU V0, V1, V0
9D001C14  8C420000   LW V0, 0(V0)
9D001C18  00801825   OR V1, A0, ZERO
9D001C1C  AC430020   SW V1, 32(V0)
9D001C20  00000000   NOP
9D001C24  03C0E825   OR SP, FP, ZERO
9D001C28  8FBE0004   LW FP, 4(SP)
9D001C2C  27BD0008   ADDIU SP, SP, 8
9D001C30  03E00008   JR RA
9D001C34  00000000   NOP
9D001C38  27BDFFF8   ADDIU SP, SP, -8
9D001C3C  AFBE0004   SW FP, 4(SP)
9D001C40  03A0F025   OR FP, SP, ZERO
9D001C44  AFC40008   SW A0, 8(FP)
9D001C48  3C029D00   LUI V0, -25344
9D001C4C  8FC30008   LW V1, 8(FP)
9D001C50  00031880   SLL V1, V1, 2
9D001C54  24422834   ADDIU V0, V0, 10292
9D001C58  00621021   ADDU V0, V1, V0
9D001C5C  8C420000   LW V0, 0(V0)
9D001C60  8C420010   LW V0, 16(V0)
9D001C64  30420100   ANDI V0, V0, 256
9D001C68  38420100   XORI V0, V0, 256
9D001C6C  2C420001   SLTIU V0, V0, 1
9D001C70  304200FF   ANDI V0, V0, 255
9D001C74  03C0E825   OR SP, FP, ZERO
9D001C78  8FBE0004   LW FP, 4(SP)
9D001C7C  27BD0008   ADDIU SP, SP, 8
9D001C80  03E00008   JR RA
9D001C84  00000000   NOP
9D001C88  27BDFFF8   ADDIU SP, SP, -8
9D001C8C  AFBE0004   SW FP, 4(SP)
9D001C90  03A0F025   OR FP, SP, ZERO
9D001C94  AFC40008   SW A0, 8(FP)
9D001C98  3C029D00   LUI V0, -25344
9D001C9C  8FC30008   LW V1, 8(FP)
9D001CA0  00031880   SLL V1, V1, 2
9D001CA4  24422834   ADDIU V0, V0, 10292
9D001CA8  00621021   ADDU V0, V1, V0
9D001CAC  8C420000   LW V0, 0(V0)
9D001CB0  8C420010   LW V0, 16(V0)
9D001CB4  30420001   ANDI V0, V0, 1
9D001CB8  38420001   XORI V0, V0, 1
9D001CBC  2C420001   SLTIU V0, V0, 1
9D001CC0  304200FF   ANDI V0, V0, 255
9D001CC4  03C0E825   OR SP, FP, ZERO
9D001CC8  8FBE0004   LW FP, 4(SP)
9D001CCC  27BD0008   ADDIU SP, SP, 8
9D001CD0  03E00008   JR RA
9D001CD4  00000000   NOP
9D001CD8  27BDFFF8   ADDIU SP, SP, -8
9D001CDC  AFBE0004   SW FP, 4(SP)
9D001CE0  03A0F025   OR FP, SP, ZERO
9D001CE4  AFC40008   SW A0, 8(FP)
9D001CE8  3C029D00   LUI V0, -25344
9D001CEC  8FC30008   LW V1, 8(FP)
9D001CF0  00031880   SLL V1, V1, 2
9D001CF4  24422834   ADDIU V0, V0, 10292
9D001CF8  00621021   ADDU V0, V1, V0
9D001CFC  8C420000   LW V0, 0(V0)
9D001D00  8C420030   LW V0, 48(V0)
9D001D04  304200FF   ANDI V0, V0, 255
9D001D08  03C0E825   OR SP, FP, ZERO
9D001D0C  8FBE0004   LW FP, 4(SP)
9D001D10  27BD0008   ADDIU SP, SP, 8
9D001D14  03E00008   JR RA
9D001D18  00000000   NOP
9D001D1C  27BDFFF0   ADDIU SP, SP, -16
9D001D20  AFBE000C   SW FP, 12(SP)
9D001D24  03A0F025   OR FP, SP, ZERO
9D001D28  AFC40010   SW A0, 16(FP)
9D001D2C  AFC50014   SW A1, 20(FP)
9D001D30  3C029D00   LUI V0, -25344
9D001D34  8FC30014   LW V1, 20(FP)
9D001D38  00031880   SLL V1, V1, 2
9D001D3C  24422834   ADDIU V0, V0, 10292
9D001D40  00621021   ADDU V0, V1, V0
9D001D44  8C420000   LW V0, 0(V0)
9D001D48  8C420030   LW V0, 48(V0)
9D001D4C  3042FFFF   ANDI V0, V0, -1
9D001D50  A7C20000   SH V0, 0(FP)
9D001D54  8FC20010   LW V0, 16(FP)
9D001D58  97C30000   LHU V1, 0(FP)
9D001D5C  A4430000   SH V1, 0(V0)
9D001D60  8FC20010   LW V0, 16(FP)
9D001D64  03C0E825   OR SP, FP, ZERO
9D001D68  8FBE000C   LW FP, 12(SP)
9D001D6C  27BD0010   ADDIU SP, SP, 16
9D001D70  03E00008   JR RA
9D001D74  00000000   NOP
9D001D78  27BDFFF8   ADDIU SP, SP, -8
9D001D7C  AFBE0004   SW FP, 4(SP)
9D001D80  03A0F025   OR FP, SP, ZERO
9D001D84  AFC40008   SW A0, 8(FP)
9D001D88  3C029D00   LUI V0, -25344
9D001D8C  8FC30008   LW V1, 8(FP)
9D001D90  00031880   SLL V1, V1, 2
9D001D94  24422834   ADDIU V0, V0, 10292
9D001D98  00621021   ADDU V0, V1, V0
9D001D9C  8C420000   LW V0, 0(V0)
9D001DA0  24030800   ADDIU V1, ZERO, 2048
9D001DA4  AC430018   SW V1, 24(V0)
9D001DA8  00000000   NOP
9D001DAC  03C0E825   OR SP, FP, ZERO
9D001DB0  8FBE0004   LW FP, 4(SP)
9D001DB4  27BD0008   ADDIU SP, SP, 8
9D001DB8  03E00008   JR RA
9D001DBC  00000000   NOP
9D001DC0  27BDFFF8   ADDIU SP, SP, -8
9D001DC4  AFBE0004   SW FP, 4(SP)
9D001DC8  03A0F025   OR FP, SP, ZERO
9D001DCC  AFC40008   SW A0, 8(FP)
9D001DD0  3C029D00   LUI V0, -25344
9D001DD4  8FC30008   LW V1, 8(FP)
9D001DD8  00031880   SLL V1, V1, 2
9D001DDC  24422834   ADDIU V0, V0, 10292
9D001DE0  00621021   ADDU V0, V1, V0
9D001DE4  8C420000   LW V0, 0(V0)
9D001DE8  24030020   ADDIU V1, ZERO, 32
9D001DEC  AC430008   SW V1, 8(V0)
9D001DF0  00000000   NOP
9D001DF4  03C0E825   OR SP, FP, ZERO
9D001DF8  8FBE0004   LW FP, 4(SP)
9D001DFC  27BD0008   ADDIU SP, SP, 8
9D001E00  03E00008   JR RA
9D001E04  00000000   NOP
9D001E08  27BDFFF8   ADDIU SP, SP, -8
9D001E0C  AFBE0004   SW FP, 4(SP)
9D001E10  03A0F025   OR FP, SP, ZERO
9D001E14  AFC40008   SW A0, 8(FP)
9D001E18  3C029D00   LUI V0, -25344
9D001E1C  8FC30008   LW V1, 8(FP)
9D001E20  00031880   SLL V1, V1, 2
9D001E24  24422834   ADDIU V0, V0, 10292
9D001E28  00621021   ADDU V0, V1, V0
9D001E2C  8C420000   LW V0, 0(V0)
9D001E30  8C420000   LW V0, 0(V0)
9D001E34  30420020   ANDI V0, V0, 32
9D001E38  2C420001   SLTIU V0, V0, 1
9D001E3C  304200FF   ANDI V0, V0, 255
9D001E40  03C0E825   OR SP, FP, ZERO
9D001E44  8FBE0004   LW FP, 4(SP)
9D001E48  27BD0008   ADDIU SP, SP, 8
9D001E4C  03E00008   JR RA
9D001E50  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/system.h  ------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0010FC  27BDFFC0   ADDIU SP, SP, -64
9D001100  AFBF003C   SW RA, 60(SP)
9D001104  AFBE0038   SW FP, 56(SP)
9D001108  03A0F025   OR FP, SP, ZERO
9D00110C  AFC40040   SW A0, 64(FP)
9D001110  8FC20040   LW V0, 64(FP)
9D001114  AFC20014   SW V0, 20(FP)
9D001118  8FC30040   LW V1, 64(FP)
9D00111C  3C0204C4   LUI V0, 1220
9D001120  3442B401   ORI V0, V0, -19455
9D001124  0062102B   SLTU V0, V1, V0
9D001128  14400008   BNE V0, ZERO, SYSTEMConfigPB
9D00112C  00000000   NOP
9D001130  3C020008   LUI V0, 8
9D001134  AFC20010   SW V0, 16(FP)
9D001138  8FC20014   LW V0, 20(FP)
9D00113C  00021042   SRL V0, V0, 1
9D001140  AFC20014   SW V0, 20(FP)
9D001144  10000002   BEQ ZERO, ZERO, SYSTEMConfigPB
9D001148  00000000   NOP
9D00114C  AFC00010   SW ZERO, 16(FP)
9D001150  8FC20010   LW V0, 16(FP)
9D001154  AFC20018   SW V0, 24(FP)
9D0012A0  8FC20014   LW V0, 20(FP)
9D0012A4  03C0E825   OR SP, FP, ZERO
9D0012A8  8FBF003C   LW RA, 60(SP)
9D0012AC  8FBE0038   LW FP, 56(SP)
9D0012B0  27BD0040   ADDIU SP, SP, 64
9D0012B4  03E00008   JR RA
9D0012B8  00000000   NOP
9D0012BC  27BDFFE0   ADDIU SP, SP, -32
9D0012C0  AFBF001C   SW RA, 28(SP)
9D0012C4  AFBE0018   SW FP, 24(SP)
9D0012C8  03A0F025   OR FP, SP, ZERO
9D0012CC  AFC40020   SW A0, 32(FP)
9D0012D0  AFC00010   SW ZERO, 16(FP)
9D0012D4  10000009   BEQ ZERO, ZERO, SYSTEMConfigWaitStates
9D0012D8  00000000   NOP
9D0012DC  8FC20010   LW V0, 16(FP)
9D0012E0  24420001   ADDIU V0, V0, 1
9D0012E4  AFC20010   SW V0, 16(FP)
9D0012E8  8FC30020   LW V1, 32(FP)
9D0012EC  3C02FE36   LUI V0, -458
9D0012F0  34423C80   ORI V0, V0, 15488
9D0012F4  00621021   ADDU V0, V1, V0
9D0012F8  AFC20020   SW V0, 32(FP)
9D0012FC  8FC30020   LW V1, 32(FP)
9D001300  3C0201C9   LUI V0, 457
9D001304  3442C381   ORI V0, V0, -15487
9D001308  0062102B   SLTU V0, V1, V0
9D00130C  1040FFF3   BEQ V0, ZERO, SYSTEMConfigWaitStates
9D001310  00000000   NOP
9D001314  0F400A0B   JAL INTDisableInterrupts
9D001318  00000000   NOP
9D00131C  AFC20014   SW V0, 20(FP)
9D001320  3C02BF88   LUI V0, -16504
9D001324  8FC30010   LW V1, 16(FP)
9D001328  AC434000   SW V1, 16384(V0)
9D00132C  8FC40014   LW A0, 20(FP)
9D001330  0F4009E5   JAL INTRestoreInterrupts
9D001334  00000000   NOP
9D001338  00000000   NOP
9D00133C  03C0E825   OR SP, FP, ZERO
9D001340  8FBF001C   LW RA, 28(SP)
9D001344  8FBE0018   LW FP, 24(SP)
9D001348  27BD0020   ADDIU SP, SP, 32
9D00134C  03E00008   JR RA
9D001350  00000000   NOP
9D001354  27BDFFB0   ADDIU SP, SP, -80
9D001358  AFBF004C   SW RA, 76(SP)
9D00135C  AFBE0048   SW FP, 72(SP)
9D001360  03A0F025   OR FP, SP, ZERO
9D001364  AFC40050   SW A0, 80(FP)
9D001368  8FC20050   LW V0, 80(FP)
9D00136C  AFC2001C   SW V0, 28(FP)
9D001370  8FC2001C   LW V0, 28(FP)
9D001378  8FC3001C   LW V1, 28(FP)
9D001390  3C020008   LUI V0, 8
9D001398  8FC20020   LW V0, 32(FP)
9D0013AC  AFC00024   SW ZERO, 36(FP)
9D001500  8FC20020   LW V0, 32(FP)
9D001504  AFC20014   SW V0, 20(FP)
9D001508  AFC00010   SW ZERO, 16(FP)
9D00150C  10000009   BEQ ZERO, ZERO, SYSTEMConfigWaitStatesAndPB
9D001510  00000000   NOP
9D001514  8FC20010   LW V0, 16(FP)
9D001518  24420001   ADDIU V0, V0, 1
9D00151C  AFC20010   SW V0, 16(FP)
9D001520  8FC30050   LW V1, 80(FP)
9D001524  3C02FE36   LUI V0, -458
9D001528  34423C80   ORI V0, V0, 15488
9D00152C  00621021   ADDU V0, V1, V0
9D001530  AFC20050   SW V0, 80(FP)
9D001534  8FC30050   LW V1, 80(FP)
9D001538  3C0201C9   LUI V0, 457
9D00153C  3442C381   ORI V0, V0, -15487
9D001540  0062102B   SLTU V0, V1, V0
9D001544  1040FFF3   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D001548  00000000   NOP
9D00154C  0F400A0B   JAL INTDisableInterrupts
9D001550  00000000   NOP
9D001554  AFC20018   SW V0, 24(FP)
9D001558  3C02BF88   LUI V0, -16504
9D00155C  8FC30010   LW V1, 16(FP)
9D001560  AC434000   SW V1, 16384(V0)
9D001564  8FC40018   LW A0, 24(FP)
9D001568  0F4009E5   JAL INTRestoreInterrupts
9D00156C  00000000   NOP
9D001570  8FC20014   LW V0, 20(FP)
9D001574  03C0E825   OR SP, FP, ZERO
9D001578  8FBF004C   LW RA, 76(SP)
9D00157C  8FBE0048   LW FP, 72(SP)
9D001580  27BD0050   ADDIU SP, SP, 80
9D001584  03E00008   JR RA
9D001588  00000000   NOP
9D00158C  27BDFFA0   ADDIU SP, SP, -96
9D001590  AFBF005C   SW RA, 92(SP)
9D001594  AFBE0058   SW FP, 88(SP)
9D001598  03A0F025   OR FP, SP, ZERO
9D00159C  AFC40060   SW A0, 96(FP)
9D0015A0  8FC20060   LW V0, 96(FP)
9D0015A4  AFC2001C   SW V0, 28(FP)
9D0015A8  8FC2001C   LW V0, 28(FP)
9D0015AC  AFC20020   SW V0, 32(FP)
9D0015B0  8FC20020   LW V0, 32(FP)
9D0015B8  8FC30020   LW V1, 32(FP)
9D0015D0  3C020008   LUI V0, 8
9D0015D8  8FC20024   LW V0, 36(FP)
9D0015EC  AFC00028   SW ZERO, 40(FP)
9D001740  8FC20024   LW V0, 36(FP)
9D001744  AFC20044   SW V0, 68(FP)
9D001748  AFC00048   SW ZERO, 72(FP)
9D001754  8FC20048   LW V0, 72(FP)
9D001760  8FC3001C   LW V1, 28(FP)
9D001774  8FC3001C   LW V1, 28(FP)
9D00178C  0F400A0B   JAL INTDisableInterrupts
9D001798  3C02BF88   LUI V0, -16504
9D0017A4  8FC4004C   LW A0, 76(FP)
9D0017B0  8FC20044   LW V0, 68(FP)
9D0017B4  AFC20010   SW V0, 16(FP)
9D0017B8  0F400A0B   JAL INTDisableInterrupts
9D0017BC  00000000   NOP
9D0017C0  AFC20014   SW V0, 20(FP)
9D0017C4  3C02BF88   LUI V0, -16504
9D0017C8  24030040   ADDIU V1, ZERO, 64
9D0017CC  AC432004   SW V1, 8196(V0)
9D0017D0  3C02BF88   LUI V0, -16504
9D0017D4  8C424000   LW V0, 16384(V0)
9D0017D8  AFC20018   SW V0, 24(FP)
9D0017DC  8FC20018   LW V0, 24(FP)
9D0017E0  34420030   ORI V0, V0, 48
9D0017E4  AFC20018   SW V0, 24(FP)
9D0017E8  3C02BF88   LUI V0, -16504
9D0017EC  8FC30018   LW V1, 24(FP)
9D0017F0  AC434000   SW V1, 16384(V0)
9D0017F4  0F4009FE   JAL CheKseg0CacheOn
9D0017F8  00000000   NOP
9D0017FC  8FC40014   LW A0, 20(FP)
9D001800  0F4009E5   JAL INTRestoreInterrupts
9D001804  00000000   NOP
9D001808  8FC20010   LW V0, 16(FP)
9D00180C  03C0E825   OR SP, FP, ZERO
9D001810  8FBF005C   LW RA, 92(SP)
9D001814  8FBE0058   LW FP, 88(SP)
9D001818  27BD0060   ADDIU SP, SP, 96
9D00181C  03E00008   JR RA
9D001820  00000000   NOP
9D001824  27BDFFA8   ADDIU SP, SP, -88
9D001828  AFBF0054   SW RA, 84(SP)
9D00182C  AFBE0050   SW FP, 80(SP)
9D001830  03A0F025   OR FP, SP, ZERO
9D001834  AFC40058   SW A0, 88(FP)
9D001838  AFC5005C   SW A1, 92(FP)
9D00183C  0F400A0B   JAL INTDisableInterrupts
9D001840  00000000   NOP
9D001844  AFC20010   SW V0, 16(FP)
9D001848  3C02BF88   LUI V0, -16504
9D00184C  24030040   ADDIU V1, ZERO, 64
9D001850  AC432004   SW V1, 8196(V0)
9D001854  8FC2005C   LW V0, 92(FP)
9D001858  30420001   ANDI V0, V0, 1
9D00185C  1040001D   BEQ V0, ZERO, 0x9D0018D4
9D001860  00000000   NOP
9D001864  8FC20058   LW V0, 88(FP)
9D001868  AFC2001C   SW V0, 28(FP)
9D00186C  AFC00020   SW ZERO, 32(FP)
9D001878  8FC20020   LW V0, 32(FP)
9D001884  8FC3001C   LW V1, 28(FP)
9D001898  8FC3001C   LW V1, 28(FP)
9D0018B0  0F400A0B   JAL INTDisableInterrupts
9D0018BC  3C02BF88   LUI V0, -16504
9D0018C8  8FC40024   LW A0, 36(FP)
9D0018D4  8FC2005C   LW V0, 92(FP)
9D0018D8  30420002   ANDI V0, V0, 2
9D0018DC  10400067   BEQ V0, ZERO, 0x9D001A7C
9D0018E0  00000000   NOP
9D0018E4  8FC20058   LW V0, 88(FP)
9D0018E8  AFC20028   SW V0, 40(FP)
9D0018EC  8FC20028   LW V0, 40(FP)
9D0018F4  8FC30028   LW V1, 40(FP)
9D00190C  3C020008   LUI V0, 8
9D001914  8FC2002C   LW V0, 44(FP)
9D001928  AFC00030   SW ZERO, 48(FP)
9D001A7C  8FC2005C   LW V0, 92(FP)
9D001A80  30420004   ANDI V0, V0, 4
9D001A84  1040000C   BEQ V0, ZERO, 0x9D001AB8
9D001A88  00000000   NOP
9D001A8C  3C02BF88   LUI V0, -16504
9D001A90  8C424000   LW V0, 16384(V0)
9D001A94  AFC20014   SW V0, 20(FP)
9D001A98  8FC20014   LW V0, 20(FP)
9D001A9C  34420030   ORI V0, V0, 48
9D001AA0  AFC20014   SW V0, 20(FP)
9D001AA4  3C02BF88   LUI V0, -16504
9D001AA8  8FC30014   LW V1, 20(FP)
9D001AAC  AC434000   SW V1, 16384(V0)
9D001AB0  0F4009FE   JAL CheKseg0CacheOn
9D001AB4  00000000   NOP
9D001AB8  8FC20058   LW V0, 88(FP)
9D001ABC  AFC20018   SW V0, 24(FP)
9D001AC0  3C02BF81   LUI V0, -16511
9D001AC4  8C42F000   LW V0, -4096(V0)
9D001AC8  7C420CC0   EXT V0, V0, 19, 2
9D001ACC  304200FF   ANDI V0, V0, 255
9D001AD0  00401825   OR V1, V0, ZERO
9D001AD4  8FC20018   LW V0, 24(FP)
9D001AD8  00621006   SRLV V0, V0, V1
9D001ADC  AFC20018   SW V0, 24(FP)
9D001AE0  8FC40010   LW A0, 16(FP)
9D001AE4  0F4009E5   JAL INTRestoreInterrupts
9D001AE8  00000000   NOP
9D001AEC  8FC20018   LW V0, 24(FP)
9D001AF0  03C0E825   OR SP, FP, ZERO
9D001AF4  8FBF0054   LW RA, 84(SP)
9D001AF8  8FBE0050   LW FP, 80(SP)
9D001AFC  27BD0058   ADDIU SP, SP, 88
9D001B00  03E00008   JR RA
9D001B04  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/spi_3xx_4xx.h  -------------
1:                   /*********************************************************************
2:                    *
3:                    *                  SPI Library definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Spi.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB XC32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the “Company”) for its PIC Microcontroller is intended
18:                   * and supplied to you, the Company’s customer, for use solely and
19:                   * exclusively on Microchip PIC Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id: Spi.h,v 1.3 2006/11/11 00:11:04 C12878 Exp $
36:                   * $Name:  $
37:                   *
38:                   ********************************************************************/
39:                  
40:                  #ifndef _SPI_H_
41:                  #define _SPI_H_
42:                  
43:                  #include <xc.h>
44:                  
45:                  /*
46:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
47:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
48:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
49:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
50:                  */
51:                  #ifndef _SUPPRESS_PLIB_WARNING
52:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
53:                  #endif
54:                  
55:                  
56:                  /* Detect the number of supported SPI channels.
57:                   * The number of supported SPI channels is variant specific and it's
58:                   * defined in the specific processor header file.
59:                  */
60:                  
61:                  
62:                  #undef  _SPI_DEF_CHN_       // symbol used for SPI channel detection/definition
63:                  
64:                  #if defined(_SPI1)
65:                      #define _SPI_DEF_CHN_       1
66:                  #elif defined(_SPI2)
67:                      #define _SPI_DEF_CHN_       2
68:                  #endif  // getting a valid SPI channel definition
69:                  
70:                  
71:                  
72:                  #ifdef _SPI_DEF_CHN_
73:                  
74:                  // SPI channels definition
75:                  // this enumerated value can be used in any function that requires
76:                  // an SPI channel as an input parameter
77:                  
78:                  
79:                  typedef enum
80:                  {
81:                  #if defined(_SPI1)
82:                      SPI_CHANNEL1    = 1,
83:                  #endif  // _SPI1
84:                  #if defined(_SPI2)
85:                      SPI_CHANNEL2    = 2,
86:                  #endif  // _SPI2
87:                          SPI_CHANNELS    = 0
88:                  #if defined(_SPI1)
89:                                          + 1
90:                  #endif
91:                  #if defined(_SPI2)
92:                                          + 1
93:                  #endif
94:                  }SpiChannel;
95:                  
96:                  // macros to translate internal SPI register definition to more user friendly interface definitions
97:                  #define _SPI_CON_MASK_(x, m)        _SPI ## x ## CON_ ## m
98:                  #define X_SPI_CON_MASK_(x, m)       _SPI_CON_MASK_(x, m)            // concatenation macro
99:                  #define _SPIxCON_MASK_(m)       X_SPI_CON_MASK_(_SPI_DEF_CHN_, m)
100:                 
101:                 #define _SPI_STAT_MASK_(x, m)       _SPI ## x ## STAT_ ## m
102:                 #define X_SPI_STAT_MASK_(x, m)      _SPI_STAT_MASK_(x, m)           // concatenation macro
103:                 #define _SPIxSTAT_MASK_(m)      X_SPI_STAT_MASK_(_SPI_DEF_CHN_, m)
104:                 
105:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
106:                      (__PIC32_FEATURE_SET__ == 350) || \
107:                      (__PIC32_FEATURE_SET__ == 370) || \
108:                      (__PIC32_FEATURE_SET__ == 430) || \
109:                      (__PIC32_FEATURE_SET__ == 450) || \
110:                      (__PIC32_FEATURE_SET__ == 470))
111:                 #define _SPI_CON2_MASK_(x, m)    _SPI ## x ## CON2_ ## m
112:                 #define X_SPI_CON2_MASK_(x, m)   _SPI_CON2_MASK_(x, m)            // concatenation macro
113:                 #define _SPIxCON2_MASK_(m)       X_SPI_CON2_MASK_(_SPI_DEF_CHN_, m)
114:                 #endif
115:                 
116:                 /********************
117:                  * Channel functions.
118:                  * Defined only if there's at least one valid SPI channel
119:                  * *********************************/
120:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
121:                      (__PIC32_FEATURE_SET__ == 350) || \
122:                      (__PIC32_FEATURE_SET__ == 370) || \
123:                      (__PIC32_FEATURE_SET__ == 430) || \
124:                      (__PIC32_FEATURE_SET__ == 450) || \
125:                      (__PIC32_FEATURE_SET__ == 470))
126:                 // open flags
127:                 typedef enum
128:                 {
129:                     // master opening mode
130:                     SPI_OPEN_MSTEN =        _SPIxCON_MASK_(MSTEN_MASK), // set the Master mode
131:                     SPI_OPEN_SMP_END =      _SPIxCON_MASK_(SMP_MASK),   // Master Sample Phase for the input bit at the end of the data out time. Otherwise data is sampled in the middle.
132:                     SPI_OPEN_MSSEN =        _SPIxCON_MASK_(MSSEN_MASK), // enable the driving of the Slave Select (SS) output pin by the Master
133:                     SPI_OPEN_MSSEN_HIGH =   _SPIxCON_MASK_(FRMPOL_MASK),    // Master driven SS output active high. Otherwise low.
134:                 
135:                     // slave opening mode
136:                     SPI_OPEN_SLVEN =        0,              // set the Slave mode
137:                     SPI_OPEN_SSEN =         _SPIxCON_MASK_(SSEN_MASK),  // enable the SS input pin.
138:                 
139:                 	SPI_OPEN_MCLKSEL = 		_SPIxCON_MASK_(MCLKSEL_MASK),
140:                 
141:                     // clocking opening mode
142:                     SPI_OPEN_CKP_HIGH = _SPIxCON_MASK_(CKP_MASK),  // set the clock polarity to (idle-high, active-low). Otherwise is (idle-low, active-high).
143:                     SPI_OPEN_CKE_REV  = _SPIxCON_MASK_(CKE_MASK), // set the Clock Edge reversed: transmit from active to idle. Otherwise transmit when clock goes from idle to active
144:                 
145:                     // data characters opening mode
146:                     SPI_OPEN_MODE8 =        0,              // set 8 bits/char
147:                     SPI_OPEN_MODE16 =       _SPIxCON_MASK_(MODE16_MASK),    // set 16 bits/char
148:                     SPI_OPEN_MODE32 =       _SPIxCON_MASK_(MODE32_MASK),    // set 32 bits/char
149:                 
150:                     // framed mode opening mode
151:                     SPI_OPEN_FRMEN =        _SPIxCON_MASK_(FRMEN_MASK), // Enable the Framed SPI support. Otherwise the Framed SPI is disabled.
152:                     SPI_OPEN_FSP_IN =       _SPIxCON_MASK_(FRMSYNC_MASK),   // Frame Sync Pulse (FSP) direction set to input (Frame Slave).
153:                                                         // Otherwise the FSP is output and the SPI channel operates as a Frame Master.
154:                     SPI_OPEN_FSP_HIGH =     _SPIxCON_MASK_(FRMPOL_MASK),    // FSP polarity set active high. Otherwise the FSP is active low.
155:                     SPI_OPEN_FSP_CLK1 =     _SPIxCON_MASK_(SPIFE_MASK), // Set the FSP to coincide with the 1st bit clock.
156:                                                         // Otherwise the FSP precedes the 1st bit clock
157:                     SPI_OPEN_FSP_WIDE =     _SPIxCON_MASK_(FRMSYPW_MASK),   // set the FSP one character wide. Otherwise the FSP is one clock wide.
158:                 
159:                     SPI_OPEN_FRM_CNT1 =     (0 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the number of characters per frame (Frame Counter) to 1 (default)
160:                     SPI_OPEN_FRM_CNT2 =     (1 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 2
161:                     SPI_OPEN_FRM_CNT4 =     (2 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 4
162:                     SPI_OPEN_FRM_CNT8 =     (3 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 8
163:                     SPI_OPEN_FRM_CNT16 =    (4 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 16
164:                     SPI_OPEN_FRM_CNT32 =    (5 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 32
165:                 
166:                     // enhanced buffer (FIFO) opening mode
167:                     SPI_OPEN_ENHBUF =       _SPIxCON_MASK_(ENHBUF_MASK),    // enable the enhanced buffer mode
168:                 
169:                     SPI_OPEN_TBE_NOT_FULL =   (3 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer not full (at least one slot empty)
170:                     SPI_OPEN_TBE_HALF_EMPTY = (2 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer >= 1/2 empty
171:                     SPI_OPEN_TBE_EMPTY =      (1 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer completely empty
172:                     SPI_OPEN_TBE_SR_EMPTY =   (0 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when the last character is shifted out of the internal Shift Register
173:                                                             // and the transmit is complete
174:                 
175:                     SPI_OPEN_RBF_FULL =      (3 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is full
176:                     SPI_OPEN_RBF_HALF_FULL = (2 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is >= 1/2 full
177:                     SPI_OPEN_RBF_NOT_EMPTY = (1 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is not empty
178:                     SPI_OPEN_RBF_EMPTY =     (0 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is empty (the last character in the buffer is read).
179:                 
180:                     // general opening mode
181:                     SPI_OPEN_DISSDO = _SPIxCON_MASK_(DISSDO_MASK), // disable the usage of the SDO pin by the SPI
182:                     SPI_OPEN_DISSDI = _SPIxCON_MASK_(DISSDI_MASK), // disable the usage of the SDI pin by the SPI
183:                     SPI_OPEN_SIDL =   _SPIxCON_MASK_(SIDL_MASK  ), // enable the Halt in the CPU Idle mode. Otherwise the SPI will be still active when the CPU is in Idle mode.
184:                     SPI_OPEN_ON =     _SPIxCON_MASK_(ON_MASK    ), // turn ON the SPI (not used in SpiChnOpen)
185:                 }SpiOpenFlags;  // open flags that can be used with SpiChnOpen. Defined in the processor header file.
186:                 
187:                 typedef enum {
188:                     SPI_OPEN2_SPISGNEXT = _SPIxCON2_MASK_(SPISGNEXT_MASK), // Sign Extend Read Data from the RX FIFO bit
189:                     SPI_OPEN2_FRMERREN  = _SPIxCON2_MASK_(FRMERREN_MASK),  // Enable Interrupt Events via FRMERR bit
190:                     SPI_OPEN2_SPIROVEN  = _SPIxCON2_MASK_(SPIROVEN_MASK),  // Enable Interrupt Events via SPIROV bit
191:                     SPI_OPEN2_SPITUREN  = _SPIxCON2_MASK_(SPITUREN_MASK),  // Enable Interrupt Events via SPITUR bit
192:                     SPI_OPEN2_IGNROV    = _SPIxCON2_MASK_(IGNROV_MASK),    // Ignore Receive Overflow bit (for Audio Data Transmissions):
193:                     SPI_OPEN2_IGNTUR    = _SPIxCON2_MASK_(IGNTUR_MASK),    // Ignore Transmit Underrun bit (for Audio Data Transmissions)
194:                     SPI_OPEN2_AUDEN     = _SPIxCON2_MASK_(AUDEN_MASK),     // Enable Audio CODEC Support bit
195:                     SPI_OPEN2_AUDMONO   = _SPIxCON2_MASK_(AUDMONO_MASK),   // Transmit monoaural, i.e. left channel = right channel
196:                     SPI_OPEN2_AUDMOD    = _SPIxCON2_MASK_(AUDMOD_MASK),    // Audio Protocol Mode bits
197:                     SPI_OPEN2_AUDMOD_DSP =  _SPIxCON2_MASK_(AUDMOD_MASK),    // Audio Protocol Mode bits = 11 => PCM/DSP mode
198:                     SPI_OPEN2_AUDMOD0   = _SPIxCON2_MASK_(AUDMOD0_MASK),   // Audio Protocol Mode bits, Bit 0
199:                     SPI_OPEN2_AUDMOD_LJ = _SPIxCON2_MASK_(AUDMOD0_MASK),   // Audio Protocol Mode bits, Bit 0 = 1 => Left Justified mode
200:                     SPI_OPEN2_AUDMOD1   = _SPIxCON2_MASK_(AUDMOD1_MASK),   // Audio Protocol Mode bits, Bit 1
201:                     SPI_OPEN2_AUDMOD_RJ = _SPIxCON2_MASK_(AUDMOD1_MASK),   // Audio Protocol Mode bits, Bit 1 = 1 => Right Justified mode
202:                     SPI_OPEN2_AUDMOD_I2S = 0x0,                            // Audio Protocol Mode bits = 0x0 => I2S mode
203:                 } SpiOpen2Flags;
204:                 
205:                 typedef enum
206:                 {
207:                     SPI_STAT_SPIRBF =  _SPIxSTAT_MASK_(SPIRBF_MASK),   // receive buffer full
208:                     SPI_STAT_SPITBF =  _SPIxSTAT_MASK_(SPITBF_MASK),   // transmit buffer full
209:                     SPI_STAT_SPITBE =  _SPIxSTAT_MASK_(SPITBE_MASK),   // transmit buffer empty
210:                     SPI_STAT_SPIRBE =  _SPIxSTAT_MASK_(SPIRBE_MASK),   // receive buffer empty
211:                     SPI_STAT_FRMERR =  _SPIxSTAT_MASK_(FRMERR_MASK),   // receive buffer empty
212:                     SPI_STAT_SPIROV =  _SPIxSTAT_MASK_(SPIROV_MASK),   // receive overflow
213:                     SPI_STAT_SPISRMT = _SPIxSTAT_MASK_(SRMT_MASK),     // shift register empty
214:                     SPI_STAT_SPITUR =  _SPIxSTAT_MASK_(SPITUR_MASK),   // transmit underrun
215:                     SPI_STAT_SPIBUSY = _SPIxSTAT_MASK_(SPIBUSY_MASK),  // busy with transaction
216:                 }SpiStatusFlags;        // possible SPI status flags
217:                 
218:                 #else
219:                 
220:                 // open flags
221:                 typedef enum
222:                 {
223:                     // master opening mode
224:                     SPI_OPEN_MSTEN =        _SPIxCON_MASK_(MSTEN_MASK), // set the Master mode
225:                     SPI_OPEN_SMP_END =      _SPIxCON_MASK_(SMP_MASK),   // Master Sample Phase for the input bit at the end of the data out time. Otherwise data is sampled in the middle.
226:                 
227:                     // slave opening mode
228:                     SPI_OPEN_SLVEN =        0,              // set the Slave mode
229:                     SPI_OPEN_SSEN =         _SPIxCON_MASK_(SSEN_MASK),  // enable the SS (Slave Select) input pin.
230:                 
231:                     // clocking opening mode
232:                     SPI_OPEN_CKP_HIGH =         _SPIxCON_MASK_(CKP_MASK),   // set the clock polarity to (idle-high, active-low). Otherwise is (idle-low, active-high).
233:                     SPI_OPEN_CKE_REV =      _SPIxCON_MASK_(CKE_MASK),   // set the Clock Edge reversed: transmit from active to idle. Otherwise transmit when clock goes from idle to active
234:                 
235:                     // data characters opening mode
236:                     SPI_OPEN_MODE8 =        0,              // set 8 bits/char
237:                     SPI_OPEN_MODE16 =       _SPIxCON_MASK_(MODE16_MASK),    // set 16 bits/char
238:                     SPI_OPEN_MODE32 =       _SPIxCON_MASK_(MODE32_MASK),    // set 32 bits/char
239:                 
240:                     // framed mode opening mode
241:                     SPI_OPEN_FRMEN =        _SPIxCON_MASK_(FRMEN_MASK), // Enable the Framed SPI support. Otherwise the Framed SPI is disabled.
242:                     SPI_OPEN_FSP_IN =       _SPIxCON_MASK_(FRMSYNC_MASK),   // Frame Sync Pulse (FSP) direction set to input (Frame Slave).
243:                                                         // Otherwise the FSP is output and the SPI channel operates as a Frame Master.
244:                     SPI_OPEN_FSP_HIGH =         _SPIxCON_MASK_(FRMPOL_MASK),    // FSP polarity set active high. Otherwise the FSP is active low.
245:                     SPI_OPEN_FSP_CLK1 =         _SPIxCON_MASK_(SPIFE_MASK), // Set the Frame Sync Pulse (FSP) to coincide with the 1st bit clock.
246:                                                     // Otherwise the FSP precedes the 1st bit clock
247:                 
248:                     // general opening mode
249:                     SPI_OPEN_DISSDO =       _SPIxCON_MASK_(DISSDO_MASK),    // disable the usage of the SDO pin by the SPI
250:                 //  SPI_OPEN_DISSDI =       _SPIxCON_MASK_(DISSDIO_MASK),   // disable the usage of the SDI pin by the SPI
251:                     SPI_OPEN_SIDL =         _SPIxCON_MASK_(SIDL_MASK),  // enable the Halt in the CPU Idle mode. Otherwise the SPI will be still active when the CPU is in Idle mode.
252:                     SPI_OPEN_ON =           _SPIxCON_MASK_(ON_MASK),    // turn ON the SPI (not used in SpiChnOpen)
253:                 }SpiOpenFlags;  // open flags that can be used with SpiChnOpen. Defined in the processor header file.
254:                 
255:                 
256:                 typedef enum
257:                 {
258:                     SPI_STAT_SPIRBF =       _SPIxSTAT_MASK_(SPIRBF_MASK),   // receive buffer full
259:                     SPI_STAT_SPITBE =       _SPIxSTAT_MASK_(SPITBE_MASK),   // transmit buffer empty
260:                     SPI_STAT_SPIROV =       _SPIxSTAT_MASK_(SPIROV_MASK),   // receive overflow
261:                     SPI_STAT_SPIBUSY =      _SPIxSTAT_MASK_(SPIBUSY_MASK),  // busy with transaction
262:                 }SpiStatusFlags;        // possible SPI status flags
263:                 
264:                 #endif
265:                 
266:                 
267:                 
268:                 /*********************************************************************
269:                  * Function:        void SpiChnOpen(SpiChannel chn, SpiOpenFlags oFlags, unsigned int srcClkDiv)
270:                  *
271:                  * PreCondition:    srcClkDiv  - valid value between 2 and 1024
272:                  *                  chn        - a valid SPI channel number
273:                  *
274:                  * Input:           chn    - the channel to set
275:                  *                  oFlags - any of the values from SpiOpenFlags:
276:                  *                             master slave opening mode: SPI_OPEN_MSTEN, SPI_OPEN_SLVEN, SPI_OPEN_SSEN
277:                  *                             clocking and character opening mode: SPI_OPEN_CKP_HIGH, SPI_OPEN_CKE_REV, SPI_OPEN_SMP_END, SPI_OPEN_MODE8, SPI_OPEN_MODE16, SPI_OPEN_MODE32
278:                  *                             framed mode opening mode: SPI_OPEN_FSP_CLK1, SPI_OPEN_FSP_HIGH, SPI_OPEN_FSP_IN, SPI_OPEN_FRMEN
279:                  *                             general opening mode: SPI_OPEN_DISSDO, SPI_OPEN_SIDL, SPI_OPEN_ON
280:                  *                  srcClkDiv - Source Clock divisor to extract the bitrate=srcClk/srcClkDiv.
281:                  *
282:                  * Output:          None
283:                  *
284:                  * Side Effects:    None
285:                  *
286:                  * Overview:        This function opens the SPI channel: turns the channel on and initializes it according to the oFlags input parameter.
287:                  *                  After that the channel is enabled.
288:                  *                  It also sets the brg register.
289:                  *                  The SPI bitrate is given by: bitrate=srcClk/(2*(SPIBRG+1))
290:                  *                  The input parametes srcClkDiv specifies the srcClk divisor term (2*(SPIBRG+1)),
291:                  *                  so the BRG is calculated as SPIBRG=srcClkDiv/2-1.
292:                  *
293:                  * Note:            - The channel is turned off, the pending interrupts are cleared, interrupts are disabled. After that it is configured
294:                  *                  - The bitrate is always obtained by dividing the srcClk by srcClkDiv, an even number
295:                  *                  between 2 and 1024.
296:                  *                  - For a specific SPI bitrate, the srcClkDiv that has to be passed is:
297:                  *                  srcClkDiv=srcClk/bitrate;
298:                  *                  - When selecting the number of bits per character, SPI_OPEN_MODE32 has the highest priority.
299:                  *                  If SPI_OPEN_MODE32 is not set, then SPI_OPEN_MODE16 selects the character width.
300:                  *                  - The function properly sets the SPI pins as digital i/o pins.
301:                  *                  - The SS pin is set as a digital pin only if in frame mnode or if the SPI_OPEN_SSEN is set.
302:                  *                  Even in master mode the library will properly se the SS pin as an digital output
303:                  *                  if the SPI_OPEN_SSEN is set.
304:                  *                  - The SPI channel is turned ON after it is configured. The use of SPI_OPEN_ON is not needed.
305:                  *                  - For PIC32MX the srcClk is the peripheral bus clock.
306:                  *
307:                  * Example:        int srcClk=GetPBusFrequency(); SpiChnOpen(SPI_CHANNEL1, SPI_OPEN_MSTEN|SPI_OPEN_SMP_END|SPI_OPEN_MODE32, srcClk/20000000);
308:                  *                 will open the SPI1 and set the bit rate to 20MHz.
309:                  ********************************************************************/
310:                 void    SpiChnOpen(SpiChannel chn, SpiOpenFlags oFlags, unsigned int srcClkDiv);
311:                 
312:                 
313:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
314:                      (__PIC32_FEATURE_SET__ == 350) || \
315:                      (__PIC32_FEATURE_SET__ == 370) || \
316:                      (__PIC32_FEATURE_SET__ == 430) || \
317:                      (__PIC32_FEATURE_SET__ == 450) || \
318:                      (__PIC32_FEATURE_SET__ == 470))
319:                 /*********************************************************************
320:                  * Function:        void    SpiChnOpenEx(SpiChannel chn, SpiOpenFlags oFlags, SpiOpen2Flags oFlags2, unsigned int srcClkDiv)
321:                  *
322:                  * PreCondition:    srcClkDiv  - valid value between 2 and 1024
323:                  *                  chn        - a valid SPI channel number
324:                  *
325:                  * Input:           chn    - the channel to set
326:                  *                  oFlags - any of the values from SpiOpenFlags:
327:                  *                             master slave opening mode: SPI_OPEN_MSTEN, SPI_OPEN_SLVEN, SPI_OPEN_SSEN
328:                  *                             clocking and character opening mode: SPI_OPEN_CKP_HIGH, SPI_OPEN_CKE_REV, SPI_OPEN_SMP_END, SPI_OPEN_MODE8, SPI_OPEN_MODE16, SPI_OPEN_MODE32
329:                  *                             framed mode opening mode: SPI_OPEN_FSP_CLK1, SPI_OPEN_FSP_HIGH, SPI_OPEN_FSP_IN, SPI_OPEN_FRMEN
330:                  *                             general opening mode: SPI_OPEN_DISSDO, SPI_OPEN_SIDL, SPI_OPEN_ON
331:                  *					oFlags2 - any of the values from SpiOpen2Flags
332:                  *                  srcClkDiv - Source Clock divisor to extract the bitrate=srcClk/srcClkDiv.
333:                  *
334:                  * Output:          None
335:                  *
336:                  * Side Effects:    None
337:                  *
338:                  * Overview:        This function opens the SPI channel: turns the channel on and initializes it according to the oFlags input parameter.
339:                  *                  After that the channel is enabled.
340:                  *                  It also sets the brg register.
341:                  *                  The SPI bitrate is given by: bitrate=srcClk/(2*(SPIBRG+1))
342:                  *                  The input parametes srcClkDiv specifies the srcClk divisor term (2*(SPIBRG+1)),
343:                  *                  so the BRG is calculated as SPIBRG=srcClkDiv/2-1.
344:                  *
345:                  * Note:            - The channel is turned off, the pending interrupts are cleared, interrupts are disabled. After that it is configured
346:                  *                  - The bitrate is always obtained by dividing the srcClk by srcClkDiv, an even number
347:                  *                  between 2 and 1024.
348:                  *                  - For a specific SPI bitrate, the srcClkDiv that has to be passed is:
349:                  *                  srcClkDiv=srcClk/bitrate;
350:                  *                  - When selecting the number of bits per character, SPI_OPEN_MODE32 has the highest priority.
351:                  *                  If SPI_OPEN_MODE32 is not set, then SPI_OPEN_MODE16 selects the character width.
352:                  *                  - The function properly sets the SPI pins as digital i/o pins.
353:                  *                  - The SS pin is set as a digital pin only if in frame mnode or if the SPI_OPEN_SSEN is set.
354:                  *                  Even in master mode the library will properly se the SS pin as an digital output
355:                  *                  if the SPI_OPEN_SSEN is set.
356:                  *                  - The SPI channel is turned ON after it is configured. The use of SPI_OPEN_ON is not needed.
357:                  *                  - For PIC32MX the srcClk is the peripheral bus clock.
358:                  *
359:                  * Example:        int srcClk=GetPBusFrequency(); SpiChnOpen(SPI_CHANNEL1, SPI_OPEN_MSTEN|SPI_OPEN_SMP_END|SPI_OPEN_MODE32, SPI_OPEN2_AUDEN|SPI_OPEN2_AUDMOD_I2S, srcClk/20000000);
360:                  *                 will open the SPI1 and set the bit rate to 20MHz.
361:                  ********************************************************************/
362:                 void    SpiChnOpenEx(SpiChannel chn, SpiOpenFlags oFlags, SpiOpen2Flags oFlags2, unsigned int srcClkDiv);
363:                 #endif
364:                 
365:                 
366:                 /*********************************************************************
367:                  * Function:        void SpiChnClose(SpiChannel chn)
368:                  *
369:                  * PreCondition:    chn - a valid SPI channel number
370:                  *
371:                  * Input:           chn     - the channel to close
372:                  *
373:                  * Output:          None
374:                  *
375:                  * Side Effects:    None
376:                  *
377:                  * Overview:        This function closes the SPI channel. Some previous error conditions are cleared.
378:                  *                  Channel interrupts are disabled.
379:                  *
380:                  * Note:        - The I/O pins used by the SPI module are returned to their reset configuration.
381:                  *          - The SPI_OPEN_SSEN is used to decide if the SS pin has to be returned to the reset state.
382:                  *
383:                  * Example:         SpiChnClose(SPI_CHANNEL2);
384:                  ********************************************************************/
385:                 void    SpiChnClose(SpiChannel chn);
386:                 
387:                 
388:                 /*********************************************************************
389:                  * Function:        void SpiChnChangeMode(SpiChannel chn, int isMaster, int isFrmMaster, int waitBusy)
390:                  *
391:                  * PreCondition:    None
392:                  *
393:                  * Input:           chn         - the channel to set
394:                  *                  isMaster    - master/slave mode
395:                  *                  isFrmMaster - frame master/slave mode
396:                  *                  waitBusy    - boolean to wait/no wait for the current transfer to finish
397:                  *
398:                  * Output:          None
399:                  *
400:                  * Side Effects:    None
401:                  *
402:                  * Overview:        This function changes the SPI channel mode on the fly.
403:                  *
404:                  * Note:            - If waitBusy is TRUE, the function blocks until the current transfer, if any, is completed.
405:                  *                    Due to a bug in the PIC32_3XX_4xx SPI implementation, the SPIBUSY is set one spi_clk earlier.
406:                  *                    What it means is that the data is not available in the SPIRxBUFF at the moment that SPIBUSY is cleared.
407:                  *                    The function will wait for the SPIBUSY to be cleared.
408:                  *                    For high SPIxBRG and PBDIV values note that the number of CPU clock cycles that have to be spent in this function could be significant.
409:                  *                  - If waitBusy is FALSE, the function performs the mode switching immediately. It assumes that no transfer is currently on.
410:                  *                    The caller must make sure that the current transfer, if any, is completed.
411:                  *                  - isFrmMaster is relevant only if the SPI channel is operating in frame mode
412:                  *                  - The SCK is properly configured as an digital I/O pin
413:                  *                  - The SS is configured as a digital pin only if in frame mode or if the SSEN configuration bit is set.
414:                  *
415:                  * Example:         SpiChnChangeMode(SPI_CHANNEL2A, TRUE, TRUE, TRUE);
416:                  ********************************************************************/
417:                 void    SpiChnChangeMode(SpiChannel chn, int isMaster, int isFrmMaster, int waitBusy);
418:                 
419:                 
420:                 
421:                 /*********************************************************************
422:                  * Function:        int SpiChnDataRdy(SpiChannel chn)
423:                  *
424:                  * PreCondition:    None
425:                  *
426:                  * Input:           chn         - the channel to check
427:                  *
428:                  * Output:          TRUE        - if data available
429:                  *                  FALSE       otherwise
430:                  *
431:                  * Side Effects:    None
432:                  *
433:                  * Overview:        This function reads the SPI channel data ready condition.
434:                  *
435:                  * Note:            None
436:                  *
437:                  * Example:         int isDataAvlbl=SpiChnDataRdy(SPI_CHANNEL1);
438:                  ********************************************************************/
439:                 int     SpiChnDataRdy(SpiChannel chn);
440:                 
441:                 
442:                 /*********************************************************************
443:                  * Function:        unsigned int SpiChnReadC(SpiChannel chn)
444:                  *
445:                  * PreCondition:    None
446:                  *
447:                  * Input:           chn - the channel to use
448:                  *
449:                  * Output:          data available in the SPI rx buffer
450:                  *
451:                  * Side Effects:    None
452:                  *
453:                  * Overview:        This function returns immediately the data from the SPI buffer.
454:                  *                  It does not check if there's any new data available.
455:                  *
456:                  * Note:            When a new data word has been shifted into shift register SPIxSR and
457:                  *                  the previous contents of receive register SPIxRXB have not been read
458:                  *                  then the Rx Overflow (SPIROV) bit will be set.
459:                  *                  The module will not transfer the received data from SPIxSR to the SPIxRXB.
460:                  *                  Further data reception is disabled until the SPIROV bit is cleared.
461:                  *                  The SPIROV bit is not cleared automatically by the module and must be
462:                  *                  cleared by the user software (using SpiChnGetRov()).
463:                  *
464:                  * Example:         unsigned int newData=SpiChnReadC(SPI_CHANNEL2);
465:                  ********************************************************************/
466:                 unsigned int        SpiChnReadC(SpiChannel chn);
467:                 
468:                 
469:                 /*********************************************************************
470:                  * Function:        unsigned int SpiChnGetC(SpiChannel chn)
471:                  *
472:                  * PreCondition:    None
473:                  *
474:                  * Input:           chn         - the channel to check
475:                  *
476:                  * Output:          data available in the SPI rx buffer
477:                  *
478:                  * Side Effects:    None
479:                  *
480:                  * Overview:        This function waits for data to be available and returns it.
481:                  *
482:                  * Note:            When a new data word has been shifted into shift register SPIxSR and
483:                  *                  the previous contents of receive register SPIxRXB have not been read
484:                  *                  by the user software, then SPIROV bit will be set.
485:                  *                  The module will not transfer the received data from SPIxSR to the SPIxRXB.
486:                  *                  Further data reception is disabled until the SPIROV bit is cleared.
487:                  *                  The SPIROV bit is not cleared automatically by the module and must be
488:                  *                  cleared by the user software (using SpiChnGetRov()).
489:                  *
490:                  * Example:         int newData=SpiChnGetC(SPI_CHANNEL2);
491:                  ********************************************************************/
492:                 unsigned int        SpiChnGetC(SpiChannel chn);
493:                 
494:                 
495:                 /*********************************************************************
496:                  * Function:        void SpiChnGetS(SpiChannel chn, unsigned int *pBuff, unsigned int nChars)
497:                  *
498:                  * PreCondition:    pBuff has to be a valid pointer to a buffer large enough to store all the received characters
499:                  *
500:                  * Input:           chn             - the SPI channel
501:                  *                  pBuff           - address of buffer to store data
502:                  *                  nChars          - number of characters expected
503:                  *
504:                  * Output:          None
505:                 
506:                  * Side Effects:    None
507:                  *
508:                  * Overview:        This routine reads a buffer of characters from the corresponding SPI channel receive buffer.
509:                  *                  The number of byte/hword/word to be read is determined by parameter nChars.
510:                  *                  Waits for RX data available for each character.
511:                  *
512:                  * Note:            - pBuff is considered to be 8/16/32 bits data pointer, according to the
513:                  *                  current SPI mode!
514:                  *                  - The function blocks waiting for the whole buffer to be received.
515:                  *
516:                  *                  When a new data word has been shifted into shift register SPIxSR and
517:                  *                  the previous contents of receive register SPIxRXB have not been read
518:                  *                  by the user software, then SPIROV bit will be set.
519:                  *                  The module will not transfer the received data from SPIxSR to the SPIxRXB.
520:                  *                  Further data reception is disabled until the SPIROV bit is cleared.
521:                  *                  The SPIROV bit is not cleared automatically by the module and must be
522:                  *                  cleared by the user software (using SpiChnGetRov()).
523:                  *
524:                  * Example:         unsigned short myBuff[100]; SpiChnGetS(SPI_CHANNEL2, myBuff, sizeof(myBuff)/sizeof(*myBuff));   // receive 16 bit characters
525:                  ********************************************************************/
526:                 void    SpiChnGetS(SpiChannel chn, unsigned int *pBuff, unsigned int nChars);
527:                 
528:                 
529:                 /*********************************************************************
530:                  * Function:        int SpiChnTxBuffEmpty(SpiChannel chn)
531:                  *
532:                  * PreCondition:    None
533:                  *
534:                  * Input:           chn         - the channel to check
535:                  *
536:                  * Output:          TRUE        - if transmit buffer empty
537:                  *                  FALSE       otherwise
538:                  *
539:                  * Side Effects:    None
540:                  *
541:                  * Overview:        This function reads the SPI channel transmit buffer empty condition.
542:                  *
543:                  * Note:            None
544:                  *
545:                  * Example:         int canTransmit=SpiChnTxBuffEmpty(SPI_CHANNEL1);
546:                  ********************************************************************/
547:                 int     SpiChnTxBuffEmpty(SpiChannel chn);
548:                 
549:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
550:                      (__PIC32_FEATURE_SET__ == 350) || \
551:                      (__PIC32_FEATURE_SET__ == 370) || \
552:                      (__PIC32_FEATURE_SET__ == 430) || \
553:                      (__PIC32_FEATURE_SET__ == 450) || \
554:                      (__PIC32_FEATURE_SET__ == 470))
555:                 /*********************************************************************
556:                  * Function:        int SpiChnRxBuffEmpty(SpiChannel chn)
557:                  *
558:                  * PreCondition:    None
559:                  *
560:                  * Input:           chn - the channel to check
561:                  *
562:                  * Output:          TRUE - if the RX buffer is empty
563:                  *                  FALSE otherwise
564:                  *
565:                  * Side Effects:    None
566:                  *
567:                  * Overview:        This function returns the SPI channel RX Buffer empty condition.
568:                  *
569:                  * Note:            Valid only in enhanced buffer (FIFO) mode.
570:                  *
571:                  * Example:         int isRxEmpty=SpiChnRxBuffEmpty(SPI_CHANNEL1);
572:                  ********************************************************************/
573:                 int     SpiChnRxBuffEmpty(SpiChannel chn);
574:                 #endif
575:                 
576:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
577:                      (__PIC32_FEATURE_SET__ == 350) || \
578:                      (__PIC32_FEATURE_SET__ == 370) || \
579:                      (__PIC32_FEATURE_SET__ == 430) || \
580:                      (__PIC32_FEATURE_SET__ == 450) || \
581:                      (__PIC32_FEATURE_SET__ == 470))
582:                 /*********************************************************************
583:                  * Function:        int SpiChnRxBuffFull(SpiChannel chn)
584:                  *
585:                  * PreCondition:    None
586:                  *
587:                  * Input:           chn - the channel to check
588:                  *
589:                  * Output:          TRUE - if the RX buffer is full
590:                  *                  FALSE otherwise
591:                  *
592:                  * Side Effects:    None
593:                  *
594:                  * Overview:        This function returns the SPI channel RX Buffer full condition.
595:                  *
596:                  * Note:            Valid in both standard and enhanced buffer (FIFO) mode.
597:                  *                  In enhanced buffer mode it signals that the whole FIFO is full.
598:                  *
599:                  * Example:         int isRxFull=SpiChnRxBuffFull(SPI_CHANNEL1);
600:                  ********************************************************************/
601:                 int     SpiChnRxBuffFull(SpiChannel chn);
602:                 #endif
603:                 
604:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
605:                      (__PIC32_FEATURE_SET__ == 350) || \
606:                      (__PIC32_FEATURE_SET__ == 370) || \
607:                      (__PIC32_FEATURE_SET__ == 430) || \
608:                      (__PIC32_FEATURE_SET__ == 450) || \
609:                      (__PIC32_FEATURE_SET__ == 470))
610:                 /*********************************************************************
611:                  * Function:        int SpiChnRxBuffCount(SpiChannel chn)
612:                  *
613:                  * PreCondition:    None
614:                  *
615:                  * Input:           chn - the channel to check
616:                  *
617:                  * Output:          the number of characters available in the RX buffer
618:                  *
619:                  * Side Effects:    None
620:                  *
621:                  * Overview:        This function returns the number of characters available in the SPI channel RX Buffer.
622:                  *
623:                  * Note:            Valid only in enhanced buffer (FIFO) mode.
624:                  *
625:                  * Example:         int nCharsAvlbl=SpiChnRxBuffCount(SPI_CHANNEL1);
626:                  ********************************************************************/
627:                 int     SpiChnRxBuffCount(SpiChannel chn);
628:                 #endif
629:                 
630:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
631:                      (__PIC32_FEATURE_SET__ == 350) || \
632:                      (__PIC32_FEATURE_SET__ == 370) || \
633:                      (__PIC32_FEATURE_SET__ == 430) || \
634:                      (__PIC32_FEATURE_SET__ == 450) || \
635:                      (__PIC32_FEATURE_SET__ == 470))
636:                 /*********************************************************************
637:                  * Function:        int SpiChnTxBuffCount(SpiChannel chn)
638:                  *
639:                  * PreCondition:    None
640:                  *
641:                  * Input:           chn - the channel to check
642:                  *
643:                  * Output:          the number of characters available in the TX buffer
644:                  *
645:                  * Side Effects:    None
646:                  *
647:                  * Overview:        This function returns the number of characters in the SPI channel TX Buffer.
648:                  *
649:                  * Note:            Valid only in enhanced buffer (FIFO) mode.
650:                  *
651:                  * Example:         int nCharsToTx=SpiChnTxBuffCount(SPI_CHANNEL1);
652:                  ********************************************************************/
653:                 int     SpiChnTxBuffCount(SpiChannel chn);
654:                 #endif
655:                 
656:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
657:                      (__PIC32_FEATURE_SET__ == 350) || \
658:                      (__PIC32_FEATURE_SET__ == 370) || \
659:                      (__PIC32_FEATURE_SET__ == 430) || \
660:                      (__PIC32_FEATURE_SET__ == 450) || \
661:                      (__PIC32_FEATURE_SET__ == 470))
662:                 /*********************************************************************
663:                  * Function:        int SpiChnIsSrEmpty(SpiChannel chn)
664:                  *
665:                  * PreCondition:    None
666:                  *
667:                  * Input:           chn   - the channel to check
668:                  *
669:                  * Output:          TRUE  - if the channel shift register is empty
670:                  *                  FALSE - otherwise
671:                  *
672:                  * Side Effects:    None
673:                  *
674:                  * Overview:        This function returns the SPI channel shift register condition (SRMT).
675:                  *                  Whenever the transmit shift register is empty, the SRMT status bit will be set.
676:                  *
677:                  * Note:            None
678:                  *
679:                  * Example:         int isEmpty=SpiChnIsSrEmpty(SPI_CHANNEL1);
680:                  ********************************************************************/
681:                 int     SpiChnIsSrEmpty(SpiChannel chn);
682:                 #endif
683:                 
684:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
685:                      (__PIC32_FEATURE_SET__ == 350) || \
686:                      (__PIC32_FEATURE_SET__ == 370) || \
687:                      (__PIC32_FEATURE_SET__ == 430) || \
688:                      (__PIC32_FEATURE_SET__ == 450) || \
689:                      (__PIC32_FEATURE_SET__ == 470))
690:                 /*********************************************************************
691:                  * Function:        int SpiChnGetTur(SpiChannel chn)
692:                  *
693:                  * PreCondition:    None
694:                  *
695:                  * Input:           chn   - the channel to check
696:                  *
697:                  * Output:          TRUE  - if channel transmit underrun occurred
698:                  *                  FALSE - otherwise
699:                  *
700:                  * Side Effects:    None
701:                  *
702:                  * Overview:        This function returns the SPI channel transmit underrun condition.
703:                  *                  This condition can occur only in framed mode when there's more than 1 characters per frame.
704:                  *                  If the SPI channel has to transmit another character for the current frame and the character is not available,
705:                  *                  a TX underrun condition occurs.
706:                  *
707:                  * Note:            The Tx Underrun condition must be cleared by disabling /re-enabling the Spi channel.
708:                  *                  No transmission can further occur once this condition is set.
709:                  *
710:                  * Example:         int isUnderrun=SpiChnGetTur(SPI_CHANNEL1);
711:                  ********************************************************************/
712:                 int     SpiChnGetTur(SpiChannel chn);
713:                 #endif
714:                 
715:                 /*********************************************************************
716:                  * Function:        void SpiChnWriteC(SpiChannel chn, unsigned int data)
717:                  *
718:                  * PreCondition:    None
719:                  *
720:                  * Input:           chn  - the channel to use
721:                  *                  data - the data to be written to the port
722:                  *
723:                  * Output:          None
724:                  *
725:                  * Side Effects:    None
726:                  *
727:                  * Overview:        This routine writes inmmediately a character (byte/half word/word) to the SPI buffer register.
728:                  *
729:                  * Note:            byte/hword/word accesses will perform correctly.
730:                  *
731:                  * Example:         SpiChnWriteC(SPI_CHANNEL1, 0x1b);       // send an ESC character
732:                  ********************************************************************/
733:                 void        SpiChnWriteC(SpiChannel chn, unsigned int data);
734:                 
735:                 /*********************************************************************
736:                  * Function:        void SpiChnPutC(SpiChannel chn, unsigned int data)
737:                  *
738:                  * PreCondition:    None
739:                  *
740:                  * Input:           chn         - the channel to check
741:                  *                  data    - the data to be written to the port
742:                  *
743:                  * Output:          None
744:                  *
745:                  * Side Effects:    None
746:                  *
747:                  * Overview:        This routine writes a single byte/half word/word to the SPI bus.
748:                  *                  It waits for TX buffer empty, so that it doesn't overwrite the previous untransmitted data.
749:                  *
750:                  * Note:            byte/hword/word accesses will perform correctly.
751:                  *
752:                  * Example:         SpiChnPutC(SPI_CHANNEL1, 0x1b);     // send an ESC character
753:                  ********************************************************************/
754:                 void        SpiChnPutC(SpiChannel chn, unsigned int data);
755:                 
756:                 /*********************************************************************
757:                  * Function:        void SpiChnPutS(SpiChannel chn, unsigned int* pBuff, unsigned int nChars)
758:                  *
759:                  * PreCondition:    None
760:                  *
761:                  * Input:           chn     - the SPI channel
762:                  *                  pBuff   - address of buffer storing the data to be transmitted.
763:                  *                  nChars  - number of characters to be transmitted
764:                 
765:                  * Output:          None
766:                 
767:                  * Side Effects:    None
768:                 
769:                  * Overview:        This function writes the specified number of 8/16/32 bit characters
770:                  *                  from the specified buffer.
771:                  *                  It waits for Tx buffer empty so the characters are not overwritten.
772:                 
773:                  * Note:            pBuff is considered to be 8/16/32 bits data pointer, according to the
774:                  *                  current SPI mode!
775:                  *
776:                  * Example:         SpiChnPutS(SPI_CHANNEL1, myBuff, 100);
777:                  ********************************************************************/
778:                 void        SpiChnPutS(SpiChannel chn, unsigned int* pBuff, unsigned int nChars);
779:                 
780:                 /*********************************************************************
781:                  * Function:        int SpiChnGetRov(SpiChannel chn, int clear)
782:                  *
783:                  * PreCondition:    None
784:                  *
785:                  * Input:           chn         - the channel to check
786:                  *                  clear       - if TRUE, the overflow condition has to be cleared, if present
787:                  *
788:                  * Output:          TRUE        - if overflow
789:                  *                  FALSE       otherwise
790:                  *
791:                  * Side Effects:    None
792:                  *
793:                  * Overview:        This function reads the SPI channel overflow condition (SPIROV bit)
794:                  *                  and clears it, if required.
795:                  *
796:                  * Note:            None
797:                  *
798:                  * Example:         int isOvfl=SpiChnGetRov(SPI_CHANNEL1, FALSE);
799:                  ********************************************************************/
800:                 int     SpiChnGetRov(SpiChannel chn, int clear);
801:                 
802:                 /*********************************************************************
803:                  * Function:        int SpiChnIsBusy(SpiChannel chn)
804:                  *
805:                  * PreCondition:    None
806:                  *
807:                  * Input:           chn   - the channel to check
808:                  *
809:                  * Output:          TRUE  - if channel is busy with a transaction
810:                  *                  FALSE - otherwise
811:                  *
812:                  * Side Effects:    None
813:                  *
814:                  * Overview:        This function returns the SPI channel busy condition (SPIBUSY).
815:                  *                  Whenever there is an ongoing transaction, the SPIBUSY status bit will be set.
816:                  *
817:                  * Note:            None
818:                  *
819:                  * Example:         int isBusy=SpiChnIsBusy(SPI_CHANNEL1);
820:                  ********************************************************************/
821:                 int     SpiChnIsBusy(SpiChannel chn);
822:                 
823:                 
824:                 /*********************************************************************
825:                  * Function:        int SpiChnGetStatus(SpiChannel chn)
826:                  *
827:                  * PreCondition:    None
828:                  *
829:                  * Input:           chn   - the channel to check
830:                  *
831:                  * Output:          the current value of the SPI status
832:                  *
833:                  * Side Effects:    None
834:                  *
835:                  * Overview:        This function returns the complete SPI channel status in one single call.
836:                  *
837:                  * Note:            None
838:                  *
839:                  * Example:         SpiStatusFlags chnStat=SpiChnGetStatus(SPI_CHANNEL1);
840:                  ********************************************************************/
841:                 SpiStatusFlags      SpiChnGetStatus(SpiChannel chn);
842:                 
843:                 
844:                 /*********************************************************************
845:                  * Function:        volatile void* SpiChnBuffer(SpiChannel chn)
846:                  *
847:                  * PreCondition:    None
848:                  *
849:                  * Input:           chn   - the required channel
850:                  *
851:                  * Output:          the address of the SPI buffer associated to the selected channel.
852:                  *
853:                  * Side Effects:    None
854:                  *
855:                  * Overview:        This function returns the address of the SPI channel buffer.
856:                  *
857:                  * Note:            The same address is valid for both read and write operations.
858:                  *
859:                  *                  The function is useful when the corresponding SPI channel
860:                  *                  has to be used as the source or destination of a DMA transfer.
861:                  *
862:                  * Example:         volatile unsigned short* spiBuffAdd=(unsigned short*)SpiChnBuffer(SPI_CHANNEL1);
863:                  ********************************************************************/
864:                 volatile void*       SpiChnBuffer(SpiChannel chn);
865:                 
866:                 
867:                 
868:                 /********************************************************************
869:                  * Low Level SPI functions
870:                  * Direct configuration and Clock/bitrate helpers.
871:                  ********************************************************************/
872:                 #if ((__PIC32_FEATURE_SET__ == 330) || \
873:                      (__PIC32_FEATURE_SET__ == 350) || \
874:                      (__PIC32_FEATURE_SET__ == 370) || \
875:                      (__PIC32_FEATURE_SET__ == 430) || \
876:                      (__PIC32_FEATURE_SET__ == 450) || \
877:                      (__PIC32_FEATURE_SET__ == 470))
878:                 // configuration flags
879:                 typedef enum
880:                 {
881:                     // master configuration
882:                     SPI_CONFIG_MSTEN =      _SPIxCON_MASK_(MSTEN_MASK), // set the Master mode
883:                     SPI_CONFIG_SMP_END =    _SPIxCON_MASK_(SMP_MASK),   // Master Sample Phase for the input bit at the end of the data out time. Otherwise data is sampled in the middle.
884:                     SPI_CONFIG_MSSEN =      _SPIxCON_MASK_(MSSEN_MASK), // enable the driving of the Slave Select (SS) output pin by the Master
885:                     SPI_CONFIG_MSSEN_HIGH = _SPIxCON_MASK_(FRMPOL_MASK),// Master driven SS output active high. Otherwise low.
886:                 
887:                     // slave configuration
888:                     SPI_CONFIG_SLVEN = 0,              // set the Slave mode
889:                     SPI_CONFIG_SSEN  = _SPIxCON_MASK_(SSEN_MASK),  // enable the SS input pin.
890:                 
891:                     // clocking configuration
892:                     SPI_CONFIG_CKP_HIGH = _SPIxCON_MASK_(CKP_MASK),   // set the clock polarity to (idle-high, active-low). Otherwise is (idle-low, active-high).
893:                     SPI_CONFIG_CKE_REV  = _SPIxCON_MASK_(CKE_MASK),   // set the Clock Edge reversed: transmit from active to idle. Otherwise transmit when clock goes from idle to active
894:                 
895:                     // data characters configuration
896:                     SPI_CONFIG_MODE8 =      0,              // set 8 bits/char
897:                     SPI_CONFIG_MODE16 = _SPIxCON_MASK_(MODE16_MASK),    // set 16 bits/char
898:                     SPI_CONFIG_MODE32 = _SPIxCON_MASK_(MODE32_MASK),    // set 32 bits/char
899:                 
900:                     // framed mode configuration
901:                     SPI_CONFIG_FRMEN =   _SPIxCON_MASK_(FRMEN_MASK), // Enable the Framed SPI support. Otherwise the Framed SPI is disabled.
902:                     SPI_CONFIG_FSP_IN =  _SPIxCON_MASK_(FRMSYNC_MASK),   // Frame Sync Pulse (FSP) direction set to input (Frame Slave).
903:                                                         // Otherwise the FSP is output and the SPI channel operates as a Frame Master.
904:                     SPI_CONFIG_FSP_HIGH = _SPIxCON_MASK_(FRMPOL_MASK),    // FSP polarity set active high. Otherwise the FSP is active low.
905:                     SPI_CONFIG_FSP_CLK1 = _SPIxCON_MASK_(SPIFE_MASK), // Set the FSP to coincide with the 1st bit clock.
906:                                                   // Otherwise the FSP precedes the 1st bit clock
907:                     SPI_CONFIG_FSP_WIDE = _SPIxCON_MASK_(FRMSYPW_MASK),   // set the FSP one character wide. Otherwise the FSP is one clock wide.
908:                 
909:                     SPI_CONFIG_FRM_CNT1 =  (0 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the number of characters per frame (Frame Counter) to 1 (default)
910:                     SPI_CONFIG_FRM_CNT2 =  (1 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 2
911:                     SPI_CONFIG_FRM_CNT4 =  (2 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 4
912:                     SPI_CONFIG_FRM_CNT8 =  (3 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 8
913:                     SPI_CONFIG_FRM_CNT16 = (4 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 16
914:                     SPI_CONFIG_FRM_CNT32 = (5 << _SPIxCON_MASK_(FRMCNT_POSITION)), // set the Frame Counter to 32
915:                 
916:                     // enhanced buffer (FIFO) configuration
917:                     SPI_CONFIG_ENHBUF =         _SPIxCON_MASK_(ENHBUF_MASK),    // enable the enhanced buffer mode
918:                 
919:                     SPI_CONFIG_TBE_NOT_FULL =   (3 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer not full (at least one slot empty)
920:                     SPI_CONFIG_TBE_HALF_EMPTY = (2 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer >= 1/2 empty
921:                     SPI_CONFIG_TBE_EMPTY =      (1 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when Tx buffer completely empty
922:                     SPI_CONFIG_TBE_SR_EMPTY =   (0 << _SPIxCON_MASK_(STXISEL_POSITION)),    // Tx Buffer event issued when the last character is shifted out of the internal Shift Register
923:                                                             // and the transmit is complete
924:                 
925:                     SPI_CONFIG_RBF_FULL =       (3 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is full
926:                     SPI_CONFIG_RBF_HALF_FULL =  (2 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is >= 1/2 full
927:                     SPI_CONFIG_RBF_NOT_EMPTY =  (1 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is not empty
928:                     SPI_CONFIG_RBF_EMPTY =      (0 << _SPIxCON_MASK_(SRXISEL_POSITION)),    // Rx Buffer event issued when RX buffer is empty (the last character in the buffer is read).
929:                 
930:                     // general configuration
931:                     SPI_CONFIG_DISSDO = _SPIxCON_MASK_(DISSDO_MASK), // disable the usage of the SDO pin by the SPI
932:                     SPI_CONFIG_DISSDI = _SPIxCON_MASK_(DISSDI_MASK), // disable the usage of the SDI pin by the SPI
933:                     SPI_CONFIG_SIDL =   _SPIxCON_MASK_(SIDL_MASK),   // enable the Halt in the CPU Idle mode. Otherwise the SPI will be still active when the CPU is in Idle mode.
934:                     SPI_CONFIG_ON =     _SPIxCON_MASK_(ON_MASK),     // turn ON the SPI (not used in SpiChnOpen)
935:                 } SpiConfigFlags;    // configuration flags that can be used with SpiChnConfigure. Defined in the processor header file.
936:                 
937:                 typedef enum {
938:                     SPI_CONFIG2_SPISGNEXT = _SPIxCON2_MASK_(SPISGNEXT_MASK), // Sign Extend Read Data from the RX FIFO bit
939:                     SPI_CONFIG2_FRMERREN  = _SPIxCON2_MASK_(FRMERREN_MASK),  // Enable Interrupt Events via FRMERR bit
940:                     SPI_CONFIG2_SPIROVEN  = _SPIxCON2_MASK_(SPIROVEN_MASK),  // Enable Interrupt Events via SPIROV bit
941:                     SPI_CONFIG2_SPITUREN  = _SPIxCON2_MASK_(SPITUREN_MASK),  // Enable Interrupt Events via SPITUR bit
942:                     SPI_CONFIG2_IGNROV    = _SPIxCON2_MASK_(IGNROV_MASK),    // Ignore Receive Overflow bit (for Audio Data Transmissions):
943:                     SPI_CONFIG2_IGNTUR    = _SPIxCON2_MASK_(IGNTUR_MASK),    // Ignore Transmit Underrun bit (for Audio Data Transmissions)
944:                     SPI_CONFIG2_AUDEN     = _SPIxCON2_MASK_(AUDEN_MASK),     // Enable Audio CODEC Support bit
945:                     SPI_CONFIG2_AUDMONO   = _SPIxCON2_MASK_(AUDMONO_MASK),   // Transmit monoaural, i.e. left channel = right channel
946:                     SPI_CONFIG2_AUDMOD    = _SPIxCON2_MASK_(AUDMOD_MASK),    // Audio Protocol Mode bits
947:                     SPI_CONFIG2_AUDMOD_DSP =
948:                                           _SPIxCON2_MASK_(AUDMOD_MASK),    // Audio Protocol Mode bits = 11 => PCM/DSP mode
949:                     SPI_CONFIG2_AUDMOD0   = _SPIxCON2_MASK_(AUDMOD0_MASK),   // Audio Protocol Mode bits, Bit 0
950:                     SPI_CONFIG2_AUDMOD_LJ = _SPIxCON2_MASK_(AUDMOD0_MASK),   // Audio Protocol Mode bits, Bit 0 = 1 => Left Justified mode
951:                     SPI_CONFIG2_AUDMOD1   = _SPIxCON2_MASK_(AUDMOD1_MASK),   // Audio Protocol Mode bits, Bit 1
952:                     SPI_CONFIG2_AUDMOD_RJ = _SPIxCON2_MASK_(AUDMOD1_MASK),   // Audio Protocol Mode bits, Bit 1 = 1 => Right Justified mode
953:                     SPI_CONFIG2_AUDMOD_I2S = 0x0,                            // Audio Protocol Mode bits = 0x0 => I2S mode
954:                 } SpiConfig2Flags;
955:                 
956:                 #else
957:                 
958:                 // configuration flags
959:                 typedef enum
960:                 {
961:                     // master configuration
962:                     SPI_CONFIG_MSTEN =      _SPIxCON_MASK_(MSTEN_MASK), // set the Master mode
963:                     SPI_CONFIG_SMP_END =        _SPIxCON_MASK_(SMP_MASK),   // Master Sample Phase for the input bit at the end of the data out time. Otherwise data is sampled in the middle.
964:                 
965:                     // slave configuration
966:                     SPI_CONFIG_SLVEN =      0,              // set the Slave mode
967:                     SPI_CONFIG_SSEN =       _SPIxCON_MASK_(SSEN_MASK),  // enable the SS (Slave Select) input pin.
968:                 
969:                     // clocking configuration
970:                     SPI_CONFIG_CKP_HIGH =       _SPIxCON_MASK_(CKP_MASK),   // set the clock polarity to (idle-high, active-low). Otherwise is (idle-low, active-high).
971:                     SPI_CONFIG_CKE_REV =        _SPIxCON_MASK_(CKE_MASK),   // set the Clock Edge reversed: transmit from active to idle. Otherwise transmit when clock goes from idle to active
972:                 
973:                     // data characters configuration
974:                     SPI_CONFIG_MODE8 =      0,              // set 8 bits/char
975:                     SPI_CONFIG_MODE16 =         _SPIxCON_MASK_(MODE16_MASK),    // set 16 bits/char
976:                     SPI_CONFIG_MODE32 =         _SPIxCON_MASK_(MODE32_MASK),    // set 32 bits/char
977:                 
978:                     // framed mode configuration
979:                     SPI_CONFIG_FRMEN =      _SPIxCON_MASK_(FRMEN_MASK), // Enable the Framed SPI support. Otherwise the Framed SPI is disabled.
980:                     SPI_CONFIG_FSP_IN =     _SPIxCON_MASK_(FRMSYNC_MASK),   // Frame Sync Pulse (FSP) direction set to input (Frame Slave).
981:                                                         // Otherwise the FSP is output and the SPI channel operates as a Frame Master.
982:                     SPI_CONFIG_FSP_HIGH =       _SPIxCON_MASK_(FRMPOL_MASK),    // FSP polarity set active high. Otherwise the FSP is active low.
983:                     SPI_CONFIG_FSP_CLK1 =       _SPIxCON_MASK_(SPIFE_MASK), // Set the Frame Sync Pulse (FSP) to coincide with the 1st bit clock.
984:                                                     // Otherwise the FSP precedes the 1st bit clock
985:                 
986:                     // general configuration
987:                     SPI_CONFIG_DISSDO =         _SPIxCON_MASK_(DISSDO_MASK),    // disable the usage of the SDO pin by the SPI
988:                 //  SPI_CONFIG_DISSDI =         _SPIxCON_MASK_(DISSDI_MASK),    // disable the usage of the SDIO pin by the SPI
989:                     SPI_CONFIG_SIDL =       _SPIxCON_MASK_(SIDL_MASK),  // enable the Halt in the CPU Idle mode. Otherwise the SPI will be still active when the CPU is in Idle mode.
990:                     SPI_CONFIG_ON =         _SPIxCON_MASK_(ON_MASK),    // turn ON the SPI (not used in SpiChnOpen)
991:                 }SpiConfigFlags;    // configuration flags that can be used with SpiChnConfigure. Defined in the processor header file.
992:                 
993:                 #endif
994:                 
995:                 /*********************************************************************
996:                  * Function:        void SpiChnConfigure(SpiChannel chn, SpiConfigFlags config)
997:                  *
998:                  * PreCondition:    chn        - a valid SPI channel number
999:                  *
1000:                 * Input:           chn    - the channel to set
1001:                 *                  config - any of the values from SpiConfigFlags:
1002:                 *                             master slave configure: SPI_CONFIG_MSTEN, SPI_CONFIG_SLVEN, SPI_CONFIG_SSEN
1003:                 *                             clocking and character configuration: SPI_CONFIG_CKP, SPI_CONFIG_CKE, SPI_CONFIG_SMP_END, SPI_CONFIG_MODE8, SPI_CONFIG_MODE16, SPI_CONFIG_MODE32
1004:                 *                             framed mode configuration: SPI_CONFIG_SPIFE, SPI_CONFIG_FRMPOL, SPI_CONFIG_FRMSYNC, SPI_CONFIG_FRMEN
1005:                 *                             general configuration: SPI_CONFIG_DISSDO, SPI_CONFIG_SIDL, SPI_CONFIG_ON
1006:                 *
1007:                 * Output:          None
1008:                 *
1009:                 * Side Effects:    None
1010:                 *
1011:                 * Overview:        This function is an alternative to SpiChnOpen. The application can first configure and then turn ON the channel.
1012:                 *                  The function performs the configuration of the SPI channel according to the config input parameter.
1013:                 *
1014:                 * Note:            - The channel is NOT turned off by this function; It should be turned off before calling this function.
1015:                 *                  - The pending interrupts are NOT cleared or disabled.
1016:                 *                  - The function does NOT set the SPI pins as digital i/o pins.
1017:                 *                  - The SPI channel is configured but NOT turned ON. Use SpiChnEnable(chn, 1) to turn ON the channel.
1018:                 *                  - When selecting the number of bits per character, SPI_CONFIG_MODE32 has the highest priority.
1019:                 *                  If SPI_CONFIG_MODE32 is not set, then SPI_CONFIG_MODE16 selects the character width.
1020:                 *
1021:                 * Example:        SpiChnEnable(SPI_CHANNEL1, 0);
1022:                 *                 SpiChnConfigure(SPI_CHANNEL1, SPI_CONFIG_MSTEN|SPI_CONFIG_SMP_END|SPI_CONFIG_MODE32);
1023:                 *                 SpiChnEnable(SPI_CHANNEL1, 1);
1024:                 *                 will configure and then enable the SPI1.
1025:                 ********************************************************************/
1026:                void    SpiChnConfigure(SpiChannel chn, SpiConfigFlags config);
1027:                
1028:                #if ((__PIC32_FEATURE_SET__ == 330) || \
1029:                     (__PIC32_FEATURE_SET__ == 350) || \
1030:                     (__PIC32_FEATURE_SET__ == 370) || \
1031:                     (__PIC32_FEATURE_SET__ == 430) || \
1032:                     (__PIC32_FEATURE_SET__ == 450) || \
1033:                     (__PIC32_FEATURE_SET__ == 470))
1034:                /*********************************************************************
1035:                 * Function:        void SpiChnConfigureEx(SpiChannel chn, SpiConfigFlags config, SpiConfig2Flags config)
1036:                 *
1037:                 * PreCondition:    chn        - a valid SPI channel number
1038:                 *
1039:                 * Input:           chn    - the channel to set
1040:                 *                  config - any of the values from SpiConfigFlags:
1041:                 *                             master slave configure: SPI_CONFIG_MSTEN, SPI_CONFIG_SLVEN, SPI_CONFIG_SSEN
1042:                 *                             clocking and character configuration: SPI_CONFIG_CKP, SPI_CONFIG_CKE, SPI_CONFIG_SMP_END, SPI_CONFIG_MODE8, SPI_CONFIG_MODE16, SPI_CONFIG_MODE32
1043:                 *                             framed mode configuration: SPI_CONFIG_SPIFE, SPI_CONFIG_FRMPOL, SPI_CONFIG_FRMSYNC, SPI_CONFIG_FRMEN
1044:                 *                             general configuration: SPI_CONFIG_DISSDO, SPI_CONFIG_SIDL, SPI_CONFIG_ON
1045:                 *					config2 - any of the values from SpiConfig2Flags
1046:                 *
1047:                 * Output:          None
1048:                 *
1049:                 * Side Effects:    None
1050:                 *
1051:                 * Overview:        This function is an alternative to SpiChnOpen. The application can first configure and then turn ON the channel.
1052:                 *                  The function performs the configuration of the SPI channel according to the config input parameter.
1053:                 *
1054:                 * Note:            - The channel is NOT turned off by this function; It should be turned off before calling this function.
1055:                 *                  - The pending interrupts are NOT cleared or disabled.
1056:                 *                  - The function does NOT set the SPI pins as digital i/o pins.
1057:                 *                  - The SPI channel is configured but NOT turned ON. Use SpiChnEnable(chn, 1) to turn ON the channel.
1058:                 *                  - When selecting the number of bits per character, SPI_CONFIG_MODE32 has the highest priority.
1059:                 *                  If SPI_CONFIG_MODE32 is not set, then SPI_CONFIG_MODE16 selects the character width.
1060:                 *
1061:                 * Example:        SpiChnEnable(SPI_CHANNEL1, 0);
1062:                 *                 SpiChnConfigureEx(SPI_CHANNEL1, SPI_CONFIG_MSTEN|SPI_CONFIG_SMP_END|SPI_CONFIG_MODE32, SPI_CONFIG2_AUDEN|SPI_CONFIG2_AUDMOD_I2S);
1063:                 *                 SpiChnEnable(SPI_CHANNEL1, 1);
1064:                 *                 will configure and then enable the SPI1.
1065:                 ********************************************************************/
1066:                void    SpiChnConfigureEx(SpiChannel chn, SpiConfigFlags config, SpiConfig2Flags config2);
1067:                #endif
1068:                
1069:                
1070:                /*********************************************************************
1071:                 * Function:        void SpiChnEnable(SpiChannel chn, int enable)
1072:                 *
1073:                 * PreCondition:    chn        - a valid SPI channel number
1074:                 *
1075:                 * Input:           chn    - the channel to enable/disable
1076:                 *                  enable - boolean to enable/disable the channel
1077:                 *
1078:                 * Output:          None
1079:                 *
1080:                 * Side Effects:    None
1081:                 *
1082:                 * Overview:        This function enables or disables the SPI channel.
1083:                 *
1084:                 * Note:            - Before enabling the channel, proper configuration should be done.
1085:                 *
1086:                 * Example:        SpiChnConfigure(SPI_CHANNEL1, SPI_CONFIG_MSTEN|SPI_CONFIG_SMP_END|SPI_CONFIG_MODE32);
1087:                 *                 SpiChnEnable(SPI_CHANNEL1, 1);
1088:                 *                 will configure and enable the SPI1 channel.
1089:                 ********************************************************************/
1090:                void    SpiChnEnable(SpiChannel chn, int enable);
1091:                
1092:                
1093:                /*********************************************************************
1094:                 * Function:        unsigned int SpiChnSetBitRate(SpiChannel chn, unsigned int srcClk, unsigned int spiClk)
1095:                 *
1096:                 * PreCondition:    srcClk/1024 <= spiClk <= srcClk/2;
1097:                 *                  chn        - a valid SPI channel number
1098:                 *
1099:                 * Input:           chn    - the channel to set the bitrate for
1100:                 *                  srcClk - the SPI module Source Clock, Hz
1101:                 *                  spiClk - the desired SPI bitrate frequency, Hz
1102:                 *
1103:                 * Output:          the actual selected bitrate, Hz
1104:                 *
1105:                 * Side Effects:    None
1106:                 *
1107:                 * Overview:        This function configures the SPI channel with a desired bitrate.
1108:                 *                  The SPI bitrate is given by: spiClk=srcClk/(2*(SPIBRG+1))
1109:                 *                  The proper SPIBRG value is calculated as SPIBRG=(srcClk/spiClk)/2-1.
1110:                 *
1111:                 * Note:            - The channel has to be first configured with a valid bitrate and then enabled.
1112:                 *                  The bitrate can be changed dynamically, when no transaction is in progress.
1113:                 *                  - The bitrate is irrelevant for the Slave operation mode since the clock is provided externally, by the Master.
1114:                 *                  - For PIC32MX the srcClk is the peripheral bus clock.
1115:                 *
1116:                 * Example:        SpiChnEnable(SPI_CHANNEL1, 0);
1117:                 *                 SpiChnConfigure(SPI_CHANNEL1, SPI_CONFIG_MSTEN|SPI_CONFIG_SMP_END|SPI_CONFIG_MODE32);
1118:                 *                 SpiChnSetBitRate(SPI_CHANNEL1, GetPBusFrequency(), 20000000);
1119:                 *                 SpiChnEnable(SPI_CHANNEL1, 1);
1120:                 *                 will configure the SPI1, set the bitrate to 20MHz.
1121:                 ********************************************************************/
1122:                unsigned int    SpiChnSetBitRate(SpiChannel chn, unsigned int srcClk, unsigned int spiClk);
1123:                
1124:                
1125:                /*********************************************************************
1126:                 * Function:        void SpiChnSetBrg(SpiChannel chn, unsigned int brg)
1127:                 *
1128:                 * PreCondition:    None
1129:                 *
1130:                 * Input:           chn     - the channel to set
1131:                 *                  brg     - value for the brg register
1132:                 *
1133:                 * Output:          None
1134:                 *
1135:                 * Side Effects:    None
1136:                 *
1137:                 * Overview:        This function updates the values for the SPI channel brg/prescalers.
1138:                 *
1139:                 * Note:            None
1140:                 *
1141:                 * Example:         SpiChnSetBrg(SPI_CHANNEL1, 0x12);
1142:                 ********************************************************************/
1143:                void    SpiChnSetBrg(SpiChannel chn, unsigned int brg);
1144:                
1145:                
1146:                /******************************************************************************
1147:                 * Function:        unsigned int SpiBrgVal(unsigned int srcClk, unsigned int spiClk)
1148:                 *
1149:                 * Description:     Calculates the BRG values needed for the SPI configuration
1150:                 *
1151:                 * PreCondition:    srcClk/1024 <= spiClk <= srcClk/2;
1152:                 *
1153:                 * Inputs:          srcClk:   - the source clock to the SPI module, Hz
1154:                 *                  spiClk:   - the desired SPI clock frequency, Hz
1155:                 *
1156:                 * Output:          The proper BRG value.
1157:                 *                  For PIC32MX the srcClk is the Peripheral bus clock value.
1158:                 *
1159:                 * Example:         SpiChnSetBrg(SPI_CHANNEL1, SpiBrgVal(72000000, 9000000));
1160:                 *
1161:                 *****************************************************************************/
1162:                extern __inline__ unsigned int __attribute__((always_inline))   SpiBrgVal(unsigned int srcClk, unsigned int spiClk)
1163:                {
1164:                    return (srcClk / (2 * spiClk)) - 1;
1165:                }
1166:                
1167:                
1168:                
1169:                /********************************************************************
1170:                 * Include legacy SPI functions
1171:                 * New projects should not use them!
1172:                 * Note that interrupt functions are no longer provided.
1173:                 * The functions in the int.h should be used instead.
1174:                 ********************************************************************/
1175:                #ifndef _PLIB_DISABLE_LEGACY
1176:                    #include <peripheral/legacy/spi_legacy.h>
1177:                #endif
1178:                
1179:                
1180:                #endif      // _SPI_DEF_CHN_
1181:                
1182:                #endif /*_SPI_H_*/
1183:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000F3C  27BDFFF8   ADDIU SP, SP, -8
9D000F40  AFBE0004   SW FP, 4(SP)
9D000F44  03A0F025   OR FP, SP, ZERO
9D000F48  AFC40008   SW A0, 8(FP)
9D000F4C  AFC5000C   SW A1, 12(FP)
9D000F50  8FC2000C   LW V0, 12(FP)
9D000F54  00021040   SLL V0, V0, 1
9D000F58  8FC30008   LW V1, 8(FP)
9D000F5C  0062001B   DIVU V1, V0
9D000F60  004001F4   TEQ V0, ZERO
9D000F64  00001010   MFHI V0
9D000F68  00001012   MFLO V0
9D000F6C  2442FFFF   ADDIU V0, V0, -1
9D000F70  03C0E825   OR SP, FP, ZERO
9D000F74  8FBE0004   LW FP, 4(SP)
9D000F78  27BD0008   ADDIU SP, SP, 8
9D000F7C  03E00008   JR RA
9D000F80  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/rtcc.h  --------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  RTCC Lib definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Rtcc.h
7:                    * Dependencies:	xc.h
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB XC32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the “Company”) for its PIC32 Microcontroller is intended
18:                   * and supplied to you, the Company’s customer, for use solely and
19:                   * exclusively on Microchip PIC32 Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id: Rtcc.h,v 1.10 2007/01/16 20:30:43 C12878 Exp $
36:                   * $Name:  $
37:                   *
38:                   ********************************************************************/
39:                  
40:                  
41:                  #ifndef _RTCC_H_
42:                  #define _RTCC_H_
43:                  
44:                  /*
45:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
46:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
47:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
48:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
49:                  */
50:                  #ifndef _SUPPRESS_PLIB_WARNING
51:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
52:                  #endif
53:                  
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/lock.h>
57:                  #ifdef __cplusplus
58:                  extern "C"
59:                    {
60:                  #endif
61:                  #ifdef _RTCC
62:                  
63:                  // RTCC definitions
64:                  
65:                  // union/structure for read/write of time into the RTCC device
66:                  typedef union
67:                  {
68:                  	struct
69:                  	{
70:                  		unsigned char	rsvd;		// reserved for future use. should be 0
71:                  		unsigned char	sec;		// BCD codification for seconds, 00-59
72:                  		unsigned char	min;		// BCD codification for minutes, 00-59
73:                  		unsigned char	hour;		// BCD codification for hours, 00-24
74:                  	};								// field access
75:                  	unsigned char		b[4];		// byte access
76:                  	unsigned short		w[2];		// 16 bits access
77:                  	unsigned long		l;			// 32 bits access
78:                  }rtccTime;
79:                  
80:                  // union/structure for read/write of date into the RTCC device
81:                  typedef union
82:                  {
83:                  	struct
84:                  	{
85:                  		unsigned char	wday;		// BCD codification for day of the week, 00-06
86:                  		unsigned char	mday;		// BCD codification for day of the month, 01-31
87:                  		unsigned char	mon;		// BCD codification for month, 01-12
88:                  		unsigned char	year;		// BCD codification for years, 00-99
89:                  	};								// field access
90:                  	unsigned char		b[4];		// byte access
91:                  	unsigned short		w[2];		// 16 bits access
92:                  	unsigned long		l;			// 32 bits access
93:                  }rtccDate;
94:                  
95:                  // valid values of alarm repetition for the RTCC device
96:                  typedef enum
97:                  {
98:                  	RTCC_RPT_HALF_SEC,		// repeat alarm every half second
99:                  	RTCC_RPT_SEC,			// repeat alarm every second
100:                 	RTCC_RPT_TEN_SEC,		// repeat alarm every ten seconds
101:                 	RTCC_RPT_MIN,			// repeat alarm every minute
102:                 	RTCC_RPT_TEN_MIN,		// repeat alarm every ten minutes
103:                 	RTCC_RPT_HOUR,			// repeat alarm every hour
104:                 	RTCC_RPT_DAY,			// repeat alarm every day
105:                 	RTCC_RPT_WEEK,			// repeat alarm every week
106:                 	RTCC_RPT_MON,			// repeat alarm every month
107:                 	RTCC_RPT_YEAR			// repeat alarm every year (except when configured for Feb 29th.)
108:                 }rtccRepeat;
109:                 
110:                 // results returned by initialization functions
111:                 typedef enum
112:                 {
113:                 	RTCC_CLK_ON,			// success, clock is running
114:                 	RTCC_SOSC_NRDY,			// SOSC not running
115:                 	RTCC_CLK_NRDY,			// RTCC clock not running
116:                 	RTCC_WR_DSBL,			// WR is disabled
117:                 }rtccRes;
118:                 
119:                 // RTCC interface functions
120:                 
121:                 
122:                 // high level control functions
123:                 
124:                 /*********************************************************************
125:                  * Function:        rtccRes RtccInit(void)
126:                  *
127:                  * PreCondition:    None
128:                  *
129:                  * Input:           None
130:                  *
131:                  * Output:          RTCC_CLK_ON if the RTCC clock is actually running
132:                  * 					a clock status code otherwise
133:                  *
134:                  * Side Effects:    None
135:                  *
136:                  * Overview:        The function initializes the RTCC device. It starts the RTCC clock,
137:                  * 					enables the RTCC and disables RTCC write. Disables the Alarm and the OE.
138:                  * 					Clears the alarm interrupt flag and disables the alarm interrupt.
139:                  *
140:                  * Note:            It usually takes 4x256 clock cycles (approx 31.2 ms) for the oscillator signal to be available
141:                  * 					to the RTCC. The user must make sure that the clock is actually running using RtccGetClkStat()
142:                  * 					before expecting the RTCC to count.
143:                  *
144:                  * Example:			rtccRes res=RtccInit();
145:                  ********************************************************************/
146:                 rtccRes		RtccInit(void);
147:                 
148:                 /*********************************************************************
149:                  * Function:        rtccRes RtccOpen((unsigned long tm, unsigned long dt, int drift)
150:                  *
151:                  * PreCondition:    tm an unsigned long containing the fields of a valid rtccTime structure:
152:                  * 						- sec:	BCD codification, 00-59
153:                  * 						- min:  BCD codification, 00-59
154:                  * 						- hour: BCD codification, 00-24
155:                  * 			dt is an unsigned long conatining the valid fields of a rtccDate structure:
156:                  * 						- wday:	BCD codification, 00-06
157:                  * 						- mday: BCD codification, 01-31
158:                  * 						- mon: BCD codification, 01-12
159:                  * 						- year: BCD codification, 00-99
160:                  * 			drift has to fit into signed 10 bits representation
161:                  *
162:                  * Input:           	tm - the time value to be set
163:                  * 			dt - the date value to be set
164:                  * 			drift	- value to be added/subtracted to perform calibration
165:                  *
166:                  * Output:          RTCC_CLK_ON if the RTCC clock is actually running
167:                  * 					a clock status code otherwise
168:                  *
169:                  * Side Effects:    None
170:                  *
171:                  * Overview:        The function initializes the RTCC device. It starts the RTCC clock, sets the desired time and calibration
172:                  * 					and enables the RTCC. Disables the Alarm and the OE and further RTCC writes.
173:                  * 					Clears the alarm interrupt flag and disables the alarm interrupt.
174:                  *
175:                  * Note:            It usually takes 4x256 clock cycles (approx 31.2 ms) for the oscillator signal to be available
176:                  * 					to the RTCC. The user must make sure that the clock is actually running using RtccGetClkStat()
177:                  * 					before expecting the RTCC to count.
178:                  *
179:                  * Example:		rtccDate dt; dt.wday=05; dt.mday=0x28; dt.mon=0x2; dt.year=0;
180:                  * 			rtccTime tm; tm.sec=0x15; tm.min=0x30; tm.hour=01;
181:                  * 			rtccRes res=RtccOpen(tm.l, dt.l, 10);
182:                  * 					or
183:                  * 			rtccRes res=RtccOpen(0x01301500, 0x00022805, 10);
184:                  ********************************************************************/
185:                 rtccRes		RtccOpen(unsigned long tm, unsigned long dt, int drift);
186:                 
187:                 /*********************************************************************
188:                  * Function:        void RtccShutdown(void)
189:                  *
190:                  * PreCondition:    None
191:                  *
192:                  * Input:           None
193:                  *
194:                  * Output:          None
195:                  *
196:                  * Side Effects:    None
197:                  *
198:                  * Overview:        The function shutdowns the RTCC device. It stops the RTCC clock,
199:                  * 					sets the RTCC Off and disables RTCC write. Disables the Alarm and the OE.
200:                  * 					Clears the alarm interrupt flag and disables the alarm interrupt.
201:                  *
202:                  * Note:            None
203:                  *
204:                  * Example:			RtccShutdown();
205:                  ********************************************************************/
206:                 void		RtccShutdown(void);
207:                 
208:                 
209:                 // time and alarm functions
210:                 
211:                 /*********************************************************************
212:                  * Function:        void RtccSetTime(unsigned long tm)
213:                  *
214:                  * PreCondition:    tm an unsigned long containing the fields of a valid rtccTime structure:
215:                  * 						- sec:	BCD codification, 00-59
216:                  * 						- min:  BCD codification, 00-59
217:                  * 						- hour: BCD codification, 00-24
218:                  *
219:                  * Input:           tm - the time value to be set
220:                  *
221:                  * Output:          None
222:                  *
223:                  * Side Effects:    None
224:                  *
225:                  * Overview:        The function sets the current time in the RTCC device.
226:                  *
227:                  * Note:            - The write is successful only if Wr Enable is set.
228:                  * 					The function will enable the write itself, if needed.
229:                  * 					- The device could be stopped in order
230:                  * 					to safely perform the update of the RTC time register.
231:                  * 					However, the device status will be restored but	the routine won't wait
232:                  * 					for the CLK to be running before returning. User has to check RtccGetClkStat() (will take approx 30us).
233:                  * 					- The routine could disable the interrupts for a very short time to be able
234:                  * 					to update the time and date registers.
235:                  *
236:                  * Example:			rtccTime tm; tm.sec=0x15; tm.min=0x30; tm.hour=01; RtccSetTime(tm.l);
237:                  * 					or
238:                  * 					RtccSetTime(0x01301500);
239:                  *
240:                  ********************************************************************/
241:                 void		RtccSetTime(unsigned long tm);
242:                 
243:                 /*********************************************************************
244:                  * Function:        unsigned long RtccGetTime(void)
245:                  *
246:                  * PreCondition:    None
247:                  *
248:                  * Input:           None
249:                  *
250:                  * Output:          The current value of the time which can be safely casted to an rtccTime structure.
251:                  *
252:                  * Side Effects:    None
253:                  *
254:                  * Overview:        The function returns the current time of the RTCC device.
255:                  *
256:                  * Note:            - The function makes sure that the read value is valid.
257:                  * 					It avoids waiting for the RTCSYNC to be clear by
258:                  * 					performing successive reads.
259:                  *
260:                  * Example:			rtccTime tm; tm.l=RtccGetTime();
261:                  ********************************************************************/
262:                 extern __inline__ unsigned long __attribute__((always_inline))	RtccGetTime(void)
263:                 {
264:                 	unsigned int	t0, t1;
265:                 	do
266:                 	{
267:                 		t0=RTCTIME;
268:                 		t1=RTCTIME;
269:                 	}while(t0!=t1);
270:                 	return t0;
271:                 }
272:                 
273:                 /*********************************************************************
274:                  * Function:        void RtccSetDate(unsigned long dt)
275:                  *
276:                  * PreCondition:    dt is an unsigned long conatining the valid fields of a rtccDate structure:
277:                  * 						- wday:	BCD codification, 00-06
278:                  * 						- mday: BCD codification, 01-31
279:                  * 						- mon: BCD codification, 01-12
280:                  * 						- year: BCD codification, 00-99
281:                  *
282:                  * Input:           dt - the date value to be set
283:                  *
284:                  * Output:          None
285:                  *
286:                  * Side Effects:    None
287:                  *
288:                  * Overview:        The function sets the current date in the RTCC device.
289:                  *
290:                  * Note:            - The write is successful only if Wr Enable is set.
291:                  * 					The function will enable the write itself, if needed.
292:                  * 					- The device could be stopped in order
293:                  * 					to safely perform the update of the RTC time register.
294:                  * 					However, the device status will be restored but	the routine won't wait
295:                  * 					for the CLK to be running before returning. User has to check RtccGetClkStat() (will take approx 30us).
296:                  * 					- The routine could disable the interrupts for a very short time to be able
297:                  * 					to update the time and date registers.
298:                  *
299:                  * Example:			rtccDate dt; dt.wday=05; dt.mday=0x28; dt.mon=0x2; dt.year=0; RtccSetDate(dt.l);
300:                  * 					or
301:                  * 					RtccSetDate(0x00022805);
302:                  ********************************************************************/
303:                 void		RtccSetDate(unsigned long dt);
304:                 
305:                 /*********************************************************************
306:                  * Function:        unsigned long RtccGetDate(void)
307:                  *
308:                  * PreCondition:    pDt a valid pointer
309:                  *
310:                  * Input:           None
311:                  *
312:                  * Output:          an unsigned long representing the current date.
313:                  *
314:                  * Side Effects:    None
315:                  *
316:                  * Overview:        The function returns the current date of the RTCC device. Can be safely cast into rtccDate.
317:                  *
318:                  * Note:            The function makes sure that the read value is valid.
319:                  * 					It avoids waiting for the RTCSYNC to be clear by
320:                  * 					performing successive reads.
321:                  *
322:                  * Example:			rtccDate dt; dt.l=RtccGetDate();
323:                  ********************************************************************/
324:                 extern __inline__ unsigned long __attribute__((always_inline))	RtccGetDate(void)
325:                 {
326:                 	unsigned int	d0, d1;
327:                 	do
328:                 	{
329:                 		d0=RTCDATE;
330:                 		d1=RTCDATE;
331:                 	}while(d0!=d1);
332:                 
333:                 	return d0;
334:                 }
335:                 
336:                 /*********************************************************************
337:                  * Function:        void RtccSetTimeDate(unsigned long tm, unsigned long dt)
338:                  *
339:                  * PreCondition:    tm a valid rtccTime structure having proper halues:
340:                  * 						- sec:	BCD codification, 00-59
341:                  * 						- min:  BCD codification, 00-59
342:                  * 						- hour: BCD codification, 00-24
343:                  * 					date a valid rtccDate structure having proper values
344:                  * 						- wday:	BCD codification, 00-06
345:                  * 						- mday: BCD codification, 01-31
346:                  * 						- mon: BCD codification, 01-12
347:                  * 						- year: BCD codification, 00-99
348:                  *
349:                  * Input:           tm - the time value to be set
350:                  * 					dt - the date value to be set
351:                  *
352:                  * Output:          None
353:                  *
354:                  * Side Effects:    None
355:                  *
356:                  * Overview:        The function sets the current time and date in the RTCC device.
357:                  *
358:                  * Note:            - The write is successful only if Wr Enable is set.
359:                  * 					The function will enable the write itself, if needed.
360:                  * 					- The device could be stopped in order
361:                  * 					to safely perform the update of the RTC time register.
362:                  * 					However, the device status will be restored but	the routine won't wait
363:                  * 					for the CLK to be running before returning. User has to check RtccGetClkStat() (will take approx 30us).
364:                  * 					- The routine could disable the interrupts for a very short time to be able
365:                  * 					to update the time and date registers.
366:                  *
367:                  * Example:			rtccTime tm; tm.sec=0x15; tm.min=0x59; tm.hour=0x23;
368:                  * 					rtccDate dt; dt.wday=05; dt.mday=0x28; dt.mon=0x2; dt.year=0;
369:                  * 					RtccSetTimeDate(tm, dt);
370:                  * 					or
371:                  * 					RtccSetTimeDate(0x23591500, 0x00022805);
372:                  ********************************************************************/
373:                 void		RtccSetTimeDate(unsigned long tm, unsigned long dt);
374:                 
375:                 /*********************************************************************
376:                  * Function:        void RtccGetTimeDate(rtccTime* pTm, rtccDate* pDt)
377:                  *
378:                  * PreCondition:    pTm, pDt valid pointers
379:                  *
380:                  * Input:           pTm - pointer to a rtccTime union to store the current time
381:                  * 					pDt - pointer to a rtccDate union to store the current date
382:                  *
383:                  * Output:          None
384:                  *
385:                  * Side Effects:    None
386:                  *
387:                  * Overview:        The function updates the user supplied union/structures with
388:                  * 					the current time and date of the RTCC device.
389:                  *
390:                  * Note:            - The function makes sure that the read value is valid.
391:                  * 					It avoids waiting for the RTCSYNC to be clear by
392:                  * 					performing successive reads.
393:                  *
394:                  * Example:			rtccTime tm; rtccDate dt; RtccGetTimeDate(&tm, &dt);
395:                  ********************************************************************/
396:                 extern __inline__ void __attribute__((always_inline))	RtccGetTimeDate(rtccTime* pTm, rtccDate* pDt)
397:                 {
398:                 	rtccTime	t0;
399:                 	rtccDate	d0;
400:                 	do
401:                 	{
402:                 		d0.l=RTCDATE;
403:                 		t0.l=RTCTIME;
404:                 		pTm->l=RTCTIME;
405:                 		pDt->l=RTCDATE;
406:                 	}while((d0.l!=pDt->l) || (t0.l!=pTm->l));		// update the user requested data
407:                 }
408:                 
409:                 
410:                 /*********************************************************************
411:                  * Function:        void RtccSetAlarmTime(unsigned long tm)
412:                  *
413:                  * PreCondition:    tm a valid rtccTime structure having proper values:
414:                  * 						- sec:	BCD codification, 00-59
415:                  * 						- min:  BCD codification, 00-59
416:                  * 						- hour: BCD codification, 00-24
417:                  *
418:                  * Input:           tm - the alarm time to be set
419:                  *
420:                  * Output:          None
421:                  *
422:                  * Side Effects:    None
423:                  *
424:                  * Overview:        The function sets the current alarm time in the RTCC device.
425:                  *
426:                  * Note:            - The function might wait for the proper Alarm window
427:                  * 					to safely perform the update of the ALRMTIME register.
428:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
429:                  *
430:                  * Example:			rtccTime tm; tm.sec=0x15; tm.min=0x59; tm.hour=0x23; RtccSetAlarmTime(tm.l);
431:                  * 					or
432:                  * 					RtccSetAlarmTime(0x23591500);
433:                  ********************************************************************/
434:                 void		RtccSetAlarmTime(unsigned long tm);
435:                 
436:                 /*********************************************************************
437:                  * Function:        unsigned long RtccGetAlarmTime(void)
438:                  *
439:                  * PreCondition:    None
440:                  *
441:                  * Input:           None
442:                  *
443:                  * Output:          the current alarm time
444:                  *
445:                  * Side Effects:    None
446:                  *
447:                  * Overview:        The function returns the current alarm time of the RTCC device.
448:                  *
449:                  * Note:            None
450:                  *
451:                  * Example:         rtccTime tm; tm.l=RtccGetAlarmTime();
452:                  ********************************************************************/
453:                 extern __inline__ unsigned long __attribute__((always_inline))	RtccGetAlarmTime(void)
454:                 {
455:                 	return	ALRMTIME;
456:                 }
457:                 
458:                 
459:                 /*********************************************************************
460:                  * Function:        void RtccSetAlarmDate(unsigned long dt)
461:                  *
462:                  * PreCondition:    dt a valid rtccDate formatted structure having proper values:
463:                  * 						- wday:	BCD codification, 00-06
464:                  * 						- mday: BCD codification, 01-31
465:                  * 						- mon: BCD codification, 01-12
466:                  *
467:                  * Input:           dt - value of the alarm date
468:                  *
469:                  * Output:          None
470:                  *
471:                  * Side Effects:    None
472:                  *
473:                  * Overview:        The function sets the alarm date in the RTCC device.
474:                  *
475:                  * Note:            - The function might wait for the proper Alarm window
476:                  * 					to safely perform the update of the ALRMDATE register.
477:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
478:                  * 					- Note that the alarm date does not contain a year field.
479:                  *
480:                  * Example:			rtccDate dt; dt.wday=0; dt.mday=0x12; dt.mon=0x12; RtccSetAlarmDate(dt.l);
481:                  * 					or
482:                  * 					RtccSetAlarmDate(0x121200);
483:                  ********************************************************************/
484:                 void		RtccSetAlarmDate(unsigned long dt);
485:                 
486:                 /*********************************************************************
487:                  * Function:        unsigned long RtccGetAlarmDate(void)
488:                  *
489:                  * PreCondition:    None
490:                  *
491:                  * Input:           None
492:                  *
493:                  * Output:          The current alarm date. Can be safely cast into an rtccDate.
494:                  *
495:                  * Side Effects:    None
496:                  *
497:                  * Overview:        The function returns the current alarm date of the RTCC device.
498:                  *
499:                  * Note:            None
500:                  *
501:                  * Example:         rtccDate dt; dt.l=RtccGetAlarmDate();
502:                  ********************************************************************/
503:                 extern __inline__ unsigned long __attribute__((always_inline))	RtccGetAlarmDate(void)
504:                 {
505:                 	return	ALRMDATE;
506:                 }
507:                 
508:                 
509:                 /*********************************************************************
510:                  * Function:        void RtccSetAlarmTimeDate(unsigned long tm, unsigned long dt)
511:                  *
512:                  * PreCondition:    tm a valid rtccTime structure having proper values:
513:                  * 						- sec:	BCD codification, 00-59
514:                  * 						- min:  BCD codification, 00-59
515:                  * 						- hour: BCD codification, 00-24
516:                  * 					dt a valid rtccDate structure having proper values:
517:                  * 						- wday:	BCD codification, 00-06
518:                  * 						- mday: BCD codification, 01-31
519:                  * 						- mon: BCD codification, 01-12
520:                  *
521:                  * Input:           tm - the alarm time to be set
522:                  * 					dt - the alarm date to be set
523:                  *
524:                  * Output:          None
525:                  *
526:                  * Side Effects:    None
527:                  *
528:                  * Overview:        The function sets the current alarm time and date in the RTCC device.
529:                  *
530:                  * Note:            - The function might wait for the proper Alarm window
531:                  * 					to safely perform the update of the ALRMTIME, ALRMDATE registers.
532:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
533:                  * 					- Note that the alarm time does not contain a year field.
534:                  *
535:                  * Example:			rtccTime tm; tm.sec=0; tm.min=0x59; tm.hour-0x23;
536:                  * 					rtccDate dt; dt.wday=0; dt.mday=0x12; dt.mon=0x12;
537:                  * 					RtccSetAlarmTimeDate(tm.l, dt.l);
538:                  * 					or
539:                  * 					RtccSetAlarmTimeDate(0x235900, 0x121200);
540:                  ********************************************************************/
541:                 void		RtccSetAlarmTimeDate(unsigned long tm, unsigned long dt);
542:                 
543:                 /*********************************************************************
544:                  * Function:        void RtccGetAlarmTimeDate(rtccTime* pTm, rtccDate* pDt)
545:                  *
546:                  * PreCondition:    pTm, pDt valid pointers
547:                  *
548:                  * Input:           pTm - pointer to a rtccTime union to store the alarm time
549:                  * 					pDt - pointer to a rtccDate union to store the alarm date
550:                  *
551:                  * Output:          None
552:                  *
553:                  * Side Effects:    None
554:                  *
555:                  * Overview:        The function updates the user supplied union/structures with
556:                  * 					the current alarm time and date of the RTCC device.
557:                  *
558:                  * Note:            None
559:                  *
560:                  * Example:			rtccTime tm; rtccDate dt; RtccGetAlarmTimeDate(&tm, &dt);
561:                  ********************************************************************/
562:                 extern __inline__ void __attribute__((always_inline))	RtccGetAlarmTimeDate(rtccTime* pTm, rtccDate* pDt)
563:                 {
564:                 	pTm->l=ALRMTIME;
565:                 	pDt->l=ALRMDATE;
566:                 }
567:                 
568:                 /*********************************************************************
569:                  * Function:        void RtccAlarmEnable(void)
570:                  *
571:                  * PreCondition:    None
572:                  *
573:                  * Input:           None
574:                  *
575:                  * Output:          None
576:                  *
577:                  * Side Effects:    None
578:                  *
579:                  * Overview:        The function enables the alarm of the RTCC device.
580:                  *
581:                  * Note:            - The function might wait for the proper Alarm window
582:                  * 					to safely perform the update of the RTCALRM register.
583:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
584:                  *
585:                  * Example:			RtccAlarmEnable();
586:                  ********************************************************************/
587:                  void		RtccAlarmEnable(void);
588:                 
589:                 
590:                 /*********************************************************************
591:                  * Function:        void RtccAlarmDisable(void)
592:                  *
593:                  * PreCondition:    None
594:                  *
595:                  * Input:           None
596:                  *
597:                  * Output:          None
598:                  *
599:                  * Side Effects:    None
600:                  *
601:                  * Overview:        The function disables the alarm of the RTCC device.
602:                  *
603:                  * Note:            - The function might wait for the proper Alarm window
604:                  * 					to safely perform the update of the RTCALRM register.
605:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
606:                  *
607:                  * Example:			RtccAlarmDisable();
608:                  ********************************************************************/
609:                  void		RtccAlarmDisable(void);
610:                 
611:                 
612:                 /*********************************************************************
613:                  * Function:        int RtccGetAlarmEnable(void)
614:                  *
615:                  * PreCondition:    None
616:                  *
617:                  * Input:           None
618:                  *
619:                  * Output:          curent status of the RTCC alarm
620:                  *
621:                  * Side Effects:    None
622:                  *
623:                  * Overview:        The function returns the alarm status of the RTCC device.
624:                  *
625:                  * Note:            None
626:                  *
627:                  * Example:			int isAlrmEnabled=RtccGetAlarmEnable();
628:                  ********************************************************************/
629:                 extern __inline__ int __attribute__((always_inline)) RtccGetAlarmEnable(void)
630:                 {
631:                 	int	isAlrm0, isAlrm1;
632:                 	do
633:                 	{
634:                 		isAlrm0=RTCALRMbits.ALRMEN;
635:                 		isAlrm1=RTCALRMbits.ALRMEN;
636:                 	}while(isAlrm0!=isAlrm1);
637:                 
638:                 	return isAlrm0;
639:                 }
640:                 
641:                 
642:                 /*********************************************************************
643:                  * Function:        void RtccChimeEnable(void)
644:                  *
645:                  * PreCondition:    None
646:                  *
647:                  * Input:           None
648:                  *
649:                  * Output:          None
650:                  *
651:                  * Side Effects:    None
652:                  *
653:                  * Overview:        The function enables the chime alarm of the RTCC device.
654:                  *
655:                  * Note:            - The function might wait for the proper Alarm window
656:                  * 					to safely perform the update of the RTCALRM register.
657:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
658:                  *
659:                  * Example:			RtccChimeEnable();
660:                  ********************************************************************/
661:                 void		RtccChimeEnable(void);
662:                 
663:                 /*********************************************************************
664:                  * Function:        void RtccChimeDisable(void)
665:                  *
666:                  * PreCondition:    None
667:                  *
668:                  * Input:           None
669:                  *
670:                  * Output:          None
671:                  *
672:                  * Side Effects:    None
673:                  *
674:                  * Overview:        The function disables the chime alarm of the RTCC device.
675:                  *
676:                  * Note:            - The function might wait for the proper Alarm window
677:                  * 					to safely perform the update of the RTCALRM register.
678:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
679:                  *
680:                  * Example:			RtccChimeDisable();
681:                  ********************************************************************/
682:                 void		RtccChimeDisable(void);
683:                 
684:                 
685:                 /*********************************************************************
686:                  * Function:        int RtccGetChimeEnable(void)
687:                  *
688:                  * PreCondition:    None
689:                  *
690:                  * Input:           None
691:                  *
692:                  * Output:          current status of the alarm chime
693:                  *
694:                  * Side Effects:    None
695:                  *
696:                  * Overview:        The function returns the chime alarm of the RTCC device.
697:                  *
698:                  * Note:            None
699:                  *
700:                  * Example:			int isChimeEnabled=RtccGetChimeEnable();
701:                  ********************************************************************/
702:                 extern __inline__ int __attribute__((always_inline)) RtccGetChimeEnable(void)
703:                 {
704:                 	int	ch0, ch1;
705:                 	do
706:                 	{
707:                 		ch0=RTCALRMbits.CHIME;
708:                 		ch1=RTCALRMbits.CHIME;
709:                 	}while(ch0!=ch1);
710:                 
711:                 	return ch0;
712:                 
713:                 }
714:                 
715:                 /*********************************************************************
716:                  * Function:        void RtccSetAlarmRpt(rtccRepeat rpt)
717:                  *
718:                  * PreCondition:    rpt has to be a proper rtccRepeat enumeration value
719:                  * Input:           rpt 		- value of the desired alarm repeat rate
720:                  *
721:                  *
722:                  * Output:          None
723:                  *
724:                  * Side Effects:    None
725:                  *
726:                  * Overview:        The function sets the RTCC alarm repeat rate.
727:                  *
728:                  * Note:            - The function might wait for the proper Alarm window
729:                  * 					to safely perform the update of the RTCALRM register.
730:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
731:                  *
732:                  * Example:			RtccSetAlarmRpt(RTCC_RPT_MIN);
733:                  ********************************************************************/
734:                 void		RtccSetAlarmRpt(rtccRepeat rpt);
735:                 
736:                 /*********************************************************************
737:                  * Function:        rtccRepeat RtccGetAlarmRpt(void)
738:                  *
739:                  * PreCondition:    None
740:                  *
741:                  * Input:           None
742:                  *
743:                  * Output:          The value of the current alarm repeat rate.
744:                  *
745:                  * Side Effects:    None
746:                  *
747:                  * Overview:        The function returns the current RTCC alarm repeat rate.
748:                  *
749:                  * Note:            None
750:                  *
751:                  * Example:			rtccRepeat rptAlrm=RtccGetAlarmRpt();
752:                  ********************************************************************/
753:                 extern __inline__ rtccRepeat __attribute__((always_inline)) RtccGetAlarmRpt(void)
754:                 {
755:                 	rtccRepeat	r0, r1;
756:                 
757:                 	do
758:                 	{
759:                 		r0=(rtccRepeat)(RTCALRM&_RTCALRM_AMASK_MASK);
760:                 		r1=(rtccRepeat)(RTCALRM&_RTCALRM_AMASK_MASK);
761:                 	}while(r0!=r1);
762:                 
763:                 	return (rtccRepeat)(r0>>_RTCALRM_AMASK_POSITION);
764:                 }
765:                 
766:                 /*********************************************************************
767:                  * Function:        void RtccSetAlarmRptCount(int rptCnt)
768:                  *
769:                  * PreCondition:    rptCnt has to be a value less then 256
770:                  *
771:                  * Input:           rpt 		- value of the desired alarm repeat rate
772:                  *
773:                  * Output:          None
774:                  *
775:                  * Side Effects:    None
776:                  *
777:                  * Overview:        The function sets the RTCC alarm repeat count.
778:                  * 					The number of alarm triggers will be rptCnt+1:
779:                  * 						- one alarm trigger if rptCnt==0
780:                  * 						- ....
781:                  * 						- 256 alarm triggers if rptCnt=255
782:                  *
783:                  * Note:            - rptCnt will be truncated to fit into 8 bit representation.
784:                  * 		            - The function might wait for the proper Alarm window
785:                  * 					to safely perform the update of the RTCALRM register.
786:                  * 					- Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
787:                  * 					- If rptCnt is 0, there will be one alarm trigger.
788:                  *
789:                  * Example:			RtccSetAlarmRptCount(10);
790:                  ********************************************************************/
791:                 void		RtccSetAlarmRptCount(int rptCnt);
792:                 
793:                 /*********************************************************************
794:                  * Function:        int RtccGetAlarmRptCount(void)
795:                  *
796:                  * PreCondition:    None
797:                  *
798:                  * Input:           None
799:                  *
800:                  * Output:          the current alarm repeat count
801:                  *
802:                  * Side Effects:    None
803:                  *
804:                  * Overview:        The function reads the RTCC alarm repeat counter.
805:                  *
806:                  * Note:            The reading is affected by the sttatus of RTCALRM.ALRMSYNC bit.
807:                  * 					Double readings are performed.
808:                  *
809:                  * Example:			int alrmRptCnt=RtccGetAlarmRptCount();
810:                  ********************************************************************/
811:                 extern __inline__ int __attribute__((always_inline)) RtccGetAlarmRptCount(void)
812:                 {
813:                 	int	rpt0, rpt1;
814:                 	do
815:                 	{
816:                 		rpt0=RTCALRMbits.ARPT;
817:                 		rpt1=RTCALRMbits.ARPT;
818:                 	}while(rpt0!=rpt1);
819:                 
820:                 	return rpt0;
821:                 }
822:                 
823:                 /*********************************************************************
824:                  * Function:        int	RtccWeekDay(int year, int month, int day)
825:                  *
826:                  * PreCondition:    Date greater than 14 Sep 1752.
827:                  *
828:                  * Input:           year	- year value
829:                  * 					month	- month value, 1-12
830:                  * 					day		- day value, 1-31
831:                  *
832:                  * Output:          the week of the day, 0 for Sun, 1 for Mon and so on
833:                  *
834:                  * Side Effects:    None
835:                  *
836:                  * Overview:        The algorithm calculates the week of the day for new style
837:                  * 					dates, beginning at 14 Sep 1752.
838:                  * 					Based on an algorithm by Lewis Carroll.
839:                  *
840:                  * Note:            None
841:                  *
842:                  * Example:			int weekDay=RtccWeekDay(2004, 02, 28);
843:                  ********************************************************************/
844:                 int			RtccWeekDay(int year, int month, int day);
845:                 
846:                 
847:                 // low level control functions
848:                 
849:                 /*********************************************************************
850:                  * Function:        rtccRes RtccEnable(void)
851:                  *
852:                  * PreCondition:    None
853:                  *
854:                  * Input:           None
855:                  *
856:                  * Output:          RTCC_CLK_ON if the RTCC was enabled and the RTCC clock is running,
857:                  * 					a clock status code otherwise
858:                  *
859:                  * Side Effects:    None
860:                  *
861:                  * Overview:        The function enables the RTCC.
862:                  *
863:                  * Note:            - The write operations have to be enabled in order to be able to toggle the ON control bit.
864:                  * 					Otherwise the function will fail.
865:                  * 					See RtccWrEnable() function.
866:                  * 					- The function doesn't wait for the RTC clock to be on.
867:                  *
868:                  * Example:			rtccRes clkStat=RtccEnable();
869:                  ********************************************************************/
870:                 rtccRes		RtccEnable(void);
871:                 
872:                 
873:                 /*********************************************************************
874:                  * Function:        int RtccDisable(void)
875:                  *
876:                  * PreCondition:    None
877:                  *
878:                  * Input:           None
879:                  *
880:                  * Output:          TRUE if the RTCC was disabled,
881:                  * 					FALSE otherwise
882:                  *
883:                  * Side Effects:    None
884:                  *
885:                  * Overview:        The function disables the RTCC.
886:                  *
887:                  * Note:            1. The write operations have to be enabled in order to be able to toggle the ON control bit.
888:                  * 					Otherwise the function will fail.
889:                  * 					See RtccWrEnable() function.
890:                  * 					2. When ON control bit is set to 0, RTCCON.RTCSYNC, RTCCON.HALFSEC and
891:                  * 					RTCCON.RTCOE are asynchronously reset.
892:                  * 					- The function waits for the RTC clock to be off.
893:                  *
894:                  * Example:			RtccDisable();
895:                  ********************************************************************/
896:                 int		RtccDisable(void);
897:                 
898:                 /*********************************************************************
899:                  * Function:        int RtccGetEnable(void)
900:                  *
901:                  * PreCondition:    None
902:                  *
903:                  * Input:           None
904:                  *
905:                  * Output:          the current enabled/disabled status of the RTCC module.
906:                  *
907:                  * Side Effects:    None
908:                  *
909:                  * Overview:        The function returns the RTCCON.ON bit anded with RTCCLKON.
910:                  *
911:                  * Note:            None
912:                  *
913:                  * Example:         int isEnabled=RtccGetEnable();
914:                  ********************************************************************/
915:                 extern __inline__ int __attribute__((always_inline))	RtccGetEnable(void)
916:                 {
917:                 	return	(RTCCON&(_RTCCON_ON_MASK|_RTCCON_RTCCLKON_MASK));
918:                 }
919:                 
920:                 /*********************************************************************
921:                  * Function:        rtccRes RtccGetClkStat(void)
922:                  *
923:                  * PreCondition:    None
924:                  *
925:                  * Input:           None
926:                  *
927:                  * Output:          RTCC_CLK_ON if the RTCC clock is running (the oscillator output is presented to the RTCC module).
928:                  * 					an clock status otherwise
929:                  *
930:                  * Side Effects:    None
931:                  *
932:                  * Overview:        The function returns the RTCCON.ON bit anded with RTCCLKON.
933:                  *
934:                  * Note:            None
935:                  *
936:                  * Example:			int isClkOn=RtccGetClkStat();
937:                  ********************************************************************/
938:                 extern __inline__ rtccRes __attribute__((always_inline)) RtccGetClkStat(void)
939:                 {
940:                 
941:                 	if( (!(OSCCONbits.SOSCEN)) || (!(OSCCONbits.SOSCRDY)) )
942:                 	{
943:                 		return RTCC_SOSC_NRDY;
944:                 	}
945:                 	else if(!(RTCCONbits.RTCCLKON))
946:                 	{
947:                 		return RTCC_CLK_NRDY;
948:                 	}
949:                 
950:                 	return RTCC_CLK_ON;
951:                 }
952:                 
953:                 
954:                 /*********************************************************************
955:                  * Function:        void RtccSetCalibration(int drift)
956:                  *
957:                  * PreCondition:    drift has to fit into signed 10 bits representation
958:                  *
959:                  * Input:           drift	- value to be added/subtracted to perform calibration
960:                  *
961:                  * Output:          None
962:                  *
963:                  * Side Effects:    None
964:                  *
965:                  * Overview:        The function updates the value that the RTCC uses in the
966:                  * 					auto-adjust feature, once every minute.
967:                  * 					The drift value acts as a signed value, [-512, +511], 0 not having
968:                  * 					any effect.
969:                  *
970:                  * Note:            - Writes to the RTCCON.CAL[9:0] register should  only occur when the timer
971:                  * 					is turned off or immediately or after the edge of the seconds pulse
972:                  * 					(except when SECONDS=00 - due to the possibility of the auto-adjust event).
973:                  * 					In order to speed-up the process, the API function performs the reading
974:                  * 					of the HALFSEC field.
975:                  * 					- The function may block for half a second, worst case, when called
976:                  * 					at the start of the minute.
977:                  * 					- A write to the SECONDS value resets the state of the calibration and the prescaler.
978:                  * 					If calibration just occurred, it will occur again at the prescaler rollover.
979:                  * 					- Interrupts can not be disabled for such a long period. However, long interrupt routines
980:                  * 					can interfere with the proper functioning of the device. Care must be taken.
981:                  *
982:                  * Example:			RtccSetCalibration(10);
983:                  ********************************************************************/
984:                 void		RtccSetCalibration(int drift);
985:                 
986:                 /*********************************************************************
987:                  * Function:        int RtccGetCalibration(void)
988:                  *
989:                  * PreCondition:    None
990:                  *
991:                  * Input:           None
992:                  *
993:                  * Output:          Current value of the RTCC calibration field.
994:                  *
995:                  * Side Effects:    None
996:                  *
997:                  * Overview:        The function returns the value that the RTCC uses in the
998:                  * 					auto-adjust feature, once every minute.
999:                  * 					The calibration value is a signed 10 bits value, [-512, +511].
1000:                 *
1001:                 * Note:            None
1002:                 *
1003:                 * Example:         int currCal=RtccGetCalibration();
1004:                 ********************************************************************/
1005:                extern __inline__ int __attribute__((always_inline))	RtccGetCalibration(void)
1006:                {
1007:                	return	RTCCONbits.CAL;
1008:                }
1009:                
1010:                /*********************************************************************
1011:                 * Function:        void RtccWrEnable(int enable)
1012:                 *
1013:                 * PreCondition:    None
1014:                 *
1015:                 * Input:           enable - boolean to enable/disable the RTCC updates.
1016:                 *
1017:                 * Output:          None.
1018:                 *
1019:                 * Side Effects:    None
1020:                 *
1021:                 * Overview:        The function enables the updates to the RTCC
1022:                 *                  time registers and ON control bit.
1023:                 *
1024:                 * Note:            - The write can be enabled by performing a specific unlock sequence.
1025:                 *                  In order to succeed, this sequence need not be interrupted by other memory accesses
1026:                 *                  (DMA transfers, interrupts, etc).
1027:                 *                  - Interrupts and DMA transfers that might disrupt the write unlock sequence are disabled
1028:                 *                  shortly for properly unlocking the device.
1029:                 *
1030:                 * Example:        RtccWrEnable(1);
1031:                 ********************************************************************/
1032:                extern __inline__ void __attribute__((always_inline))	RtccWrEnable(int enable)
1033:                {
1034:                	if(enable)
1035:                	{
1036:                		mSysUnlockOpLock(RTCCONSET=_RTCCON_RTCWREN_MASK);
1037:                	}
1038:                	else
1039:                	{
1040:                		RTCCONCLR=_RTCCON_RTCWREN_MASK;
1041:                	}
1042:                }
1043:                
1044:                
1045:                /*********************************************************************
1046:                 * Function:        int RtccGetWrEnable(void)
1047:                 *
1048:                 * PreCondition:    None
1049:                 *
1050:                 * Input:           None
1051:                 *
1052:                 * Output:          TRUE if the RTCC is unlocked, FALSE if locked
1053:                 *
1054:                 * Side Effects:    None
1055:                 *
1056:                 * Overview:        The function returns the current status of the RTCC write enable bit.
1057:                 *
1058:                 * Note:            None
1059:                 *
1060:                 * Example:         int isWrEnabled=RtccGetWrEnable();
1061:                 ********************************************************************/
1062:                extern __inline__ int __attribute__((always_inline))	RtccGetWrEnable(void)
1063:                {
1064:                	return	RTCCONbits.RTCWREN!=0;
1065:                }
1066:                
1067:                /*********************************************************************
1068:                 * Function:        int RtccGetSync(void)
1069:                 *
1070:                 * PreCondition:    None
1071:                 *
1072:                 * Input:           None
1073:                 *
1074:                 * Output:          TRUE if the SYNC signal is asserted, FALSE otherwise
1075:                 *
1076:                 * Side Effects:    None
1077:                 *
1078:                 * Overview:        The function returns the current status of the RTCCON SYNC bit.
1079:                 *
1080:                 * Note:            None
1081:                 *
1082:                 * Example:         int isSync=RtccGetSync();
1083:                 ********************************************************************/
1084:                extern __inline__ int __attribute__((always_inline))	RtccGetSync(void)
1085:                {
1086:                	return	RTCCONbits.RTCSYNC!=0;
1087:                }
1088:                
1089:                
1090:                /*********************************************************************
1091:                 * Function:        int RtccGetHalfSecond(void)
1092:                 *
1093:                 * PreCondition:    None
1094:                 *
1095:                 * Input:           None
1096:                 *
1097:                 * Output:          TRUE if the RTCC is in the second HALF SECOND  interval, FALSE otherwise
1098:                 *
1099:                 * Side Effects:    None
1100:                 *
1101:                 * Overview:        The function returns the current status of the RTCCON HALFSEC bit.
1102:                 *
1103:                 * Note:            None
1104:                 *
1105:                 * Example:         int is2HalfSec=RtccGetHalfSecond();
1106:                 ********************************************************************/
1107:                extern __inline__ int __attribute__((always_inline))	RtccGetHalfSecond(void)
1108:                {
1109:                	return	RTCCONbits.HALFSEC!=0;
1110:                }
1111:                
1112:                /*********************************************************************
1113:                 * Function:        int RtccGetAlrmSync(void)
1114:                 *
1115:                 * PreCondition:    None
1116:                 *
1117:                 * Input:           None
1118:                 *
1119:                 * Output:          TRUE if the AlrmSync signal is asserted, FALSE otherwise
1120:                 *
1121:                 * Side Effects:    None
1122:                 *
1123:                 * Overview:        The function returns the current status of the RTCALRM ALRMSYNC bit.
1124:                 *
1125:                 * Note:            None
1126:                 *
1127:                 * Example:         int isSync=RtccGetAlrmSync();
1128:                 ********************************************************************/
1129:                extern __inline__ int __attribute__((always_inline))	RtccGetAlrmSync(void)
1130:                {
1131:                	return	RTCALRMbits.ALRMSYNC!=0;
1132:                }
1133:                
1134:                
1135:                /*********************************************************************
1136:                 * Function:        void RtccSelectPulseOutput(int secPulse)
1137:                 *
1138:                 * PreCondition:    None
1139:                 *
1140:                 * Input:           secPulse - boolean to select the seconds/alarm pulse as output
1141:                 *
1142:                 * Output:          None
1143:                 *
1144:                 * Side Effects:    None
1145:                 *
1146:                 * Overview:        The function selects the seconds clock pulse or the alarm pulse as the function of the RTCC output pin.
1147:                 *
1148:                 * Note:            The RTCC has to be enabled for the output to actually be active.
1149:                 *
1150:                 * Example:         RtccSelectPulseOutput(1);
1151:                 ********************************************************************/
1152:                extern __inline__ void __attribute__((always_inline))	RtccSelectPulseOutput(int secPulse)
1153:                {
1154:                	if(secPulse)
1155:                	{
1156:                		RTCCONSET=_RTCCON_RTSECSEL_MASK;
1157:                	}
1158:                	else
1159:                	{
1160:                		RTCCONCLR=_RTCCON_RTSECSEL_MASK;
1161:                	}
1162:                }
1163:                
1164:                
1165:                
1166:                /*********************************************************************
1167:                 * Function:        void RtccAlarmPulseHigh(void)
1168:                 *
1169:                 * PreCondition:    None
1170:                 *
1171:                 * Input:           None
1172:                 *
1173:                 * Output:          None
1174:                 *
1175:                 * Side Effects:    None
1176:                 *
1177:                 * Overview:        The function sets the initial value of the output Alarm Pulse to logic 1.
1178:                 *
1179:                 * Note:            1. The RTCC has to be enabled for the output to actually be active.
1180:                 * 					2. This Alarm Pulse output is writable only when the alarm is disabled.
1181:                 *					3. The function might wait for the proper Alarm window
1182:                 * 					to safely perform the update of the RTCALRM register.
1183:                 * 					4. Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
1184:                 *
1185:                 * Example:			RtccAlarmPulseHigh();
1186:                 ********************************************************************/
1187:                void		RtccAlarmPulseHigh(void);
1188:                
1189:                /*********************************************************************
1190:                 * Function:        void RtccAlarmPulseLow(void)
1191:                 *
1192:                 * PreCondition:    None
1193:                 *
1194:                 * Input:           None
1195:                 *
1196:                 * Output:          None
1197:                 *
1198:                 * Side Effects:    None
1199:                 *
1200:                 * Overview:        The function sets the initial value of the output Alarm Pulse to logic 0.
1201:                 *
1202:                 * Note:            1. The RTCC has to be enabled for the output to actually be active.
1203:                 * 					2. This Alarm Pulse output is writable only when the alarm is disabled.
1204:                *					3. The function might wait for the proper Alarm window
1205:                 * 					to safely perform the update of the RTCALRM register.
1206:                 * 					4. Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
1207:                 *
1208:                 * Example:			RtccAlarmPulseLow();
1209:                 ********************************************************************/
1210:                void		RtccAlarmPulseLow(void);
1211:                
1212:                /*********************************************************************
1213:                 * Function:        void RtccAlarmPulseToggle(void)
1214:                 *
1215:                 * PreCondition:    None
1216:                 *
1217:                 * Input:           None
1218:                 *
1219:                 * Output:          None
1220:                 *
1221:                 * Side Effects:    None
1222:                 *
1223:                 * Overview:        The function toggles the value of the output Alarm Pulse.
1224:                 *
1225:                 * Note:            1. The RTCC has to be enabled for the output to actually be active.
1226:                 * 					2. This Alarm Pulse output is writable only when the alarm is disabled.
1227:                *					3. The function might wait for the proper Alarm window
1228:                 * 					to safely perform the update of the RTCALRM register.
1229:                 * 					4. Interrupts are disabled shortly when properly probing the ALRMSYNC needed.
1230:                 *
1231:                 * Example:			RtccAlarmPulseToggle();
1232:                 ********************************************************************/
1233:                void		RtccAlarmPulseToggle(void);
1234:                
1235:                /*********************************************************************
1236:                 * Function:        int RtccGetAlarmPulse(void)
1237:                 *
1238:                 * PreCondition:    None
1239:                 *
1240:                 * Input:           None
1241:                 *
1242:                 * Output:          1 if the Alarm Pulse output is asserted
1243:                 *                  0 otherwise
1244:                 *
1245:                 * Side Effects:    None
1246:                 *
1247:                 * Overview:        The function returns the current state of the output Alarm Pulse.
1248:                 *
1249:                 * Note:            The alarm has to be enabled for this function to return the current state of the Alarm Pulse output.
1250:                 *
1251:                 * Example:         int alrmPulse=RtccGetAlarmPulse();
1252:                 ********************************************************************/
1253:                extern __inline__ int __attribute__((always_inline))	RtccGetAlarmPulse(void)
1254:                {
1255:                	return RTCALRMbits.PIV!=0;
1256:                }
1257:                
1258:                
1259:                /*********************************************************************
1260:                 * Function:        void RtccOutputEnable(int enable)
1261:                 *
1262:                 * PreCondition:    None
1263:                 *
1264:                 * Input:           enable -  boolean to enable/disable the RTCC output pin
1265:                 *
1266:                 * Output:          None
1267:                 *
1268:                 * Side Effects:    None
1269:                 *
1270:                 * Overview:        The function enables/disables the Output pin of the RTCC.
1271:                 *
1272:                 * Note:            The RTCC has to be enabled for the output to actually be active.
1273:                 *
1274:                 * Example:         RtccOutputEnable(1);
1275:                 ********************************************************************/
1276:                extern __inline__ void __attribute__((always_inline))	RtccOutputEnable(int enable)
1277:                {
1278:                	if(enable)
1279:                	{
1280:                		RTCCONSET=_RTCCON_RTCOE_MASK;
1281:                	}
1282:                	else
1283:                	{
1284:                		RTCCONCLR=_RTCCON_RTCOE_MASK;
1285:                	}
1286:                }
1287:                
1288:                /*********************************************************************
1289:                 * Function:        int RtccGetOutputEnable(void)
1290:                 *
1291:                 * PreCondition:    None
1292:                 *
1293:                 * Input:           None
1294:                 *
1295:                 * Output:          TRUE if Output is enabled, FALSE otherwise.
1296:                 *
1297:                 * Side Effects:    None
1298:                 *
1299:                 * Overview:        The function returns the enabled/disabled status of the RTCC Output pin.
1300:                 *
1301:                 * Note:            None
1302:                 *
1303:                 * Example:         int isOutEnabled=RtccGetOutputEnable();
1304:                 ********************************************************************/
1305:                extern __inline__ int __attribute__((always_inline))	RtccGetOutputEnable(void)
1306:                {
1307:                	return	RTCCONbits.RTCOE!=0;
1308:                }
1309:                
1310:                
1311:                // special purpose functions
1312:                
1313:                /********************************************************************
1314:                 * Include legacy RTCC functions
1315:                 * New projects should not use them!
1316:                 * Note that interrupt functions are no longer provided.
1317:                 * The functions in the int.h should be used instead.
1318:                 ********************************************************************/
1319:                #ifndef _PLIB_DISABLE_LEGACY
1320:                	#include <peripheral/legacy/rtcc_legacy.h>
1321:                #endif
1322:                
1323:                #endif  // _RTCC
1324:                
1325:                #ifdef __cplusplus
1326:                  }
1327:                #endif
1328:                #endif /*_RTCC_H_*/
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000808  27BDFFF0   ADDIU SP, SP, -16
9D00080C  AFBE000C   SW FP, 12(SP)
9D000810  03A0F025   OR FP, SP, ZERO
9D000814  3C02BF80   LUI V0, -16512
9D000818  8C420220   LW V0, 544(V0)
9D00081C  AFC20000   SW V0, 0(FP)
9D000820  3C02BF80   LUI V0, -16512
9D000824  8C420220   LW V0, 544(V0)
9D000828  AFC20004   SW V0, 4(FP)
9D00082C  8FC30000   LW V1, 0(FP)
9D000830  8FC20004   LW V0, 4(FP)
9D000834  1462FFF7   BNE V1, V0, 0x9D000814
9D000838  00000000   NOP
9D00083C  8FC20000   LW V0, 0(FP)
9D000840  03C0E825   OR SP, FP, ZERO
9D000844  8FBE000C   LW FP, 12(SP)
9D000848  27BD0010   ADDIU SP, SP, 16
9D00084C  03E00008   JR RA
9D000850  00000000   NOP
9D000854  27BDFFF0   ADDIU SP, SP, -16
9D000858  AFBE000C   SW FP, 12(SP)
9D00085C  03A0F025   OR FP, SP, ZERO
9D000860  3C02BF80   LUI V0, -16512
9D000864  8C420230   LW V0, 560(V0)
9D000868  AFC20000   SW V0, 0(FP)
9D00086C  3C02BF80   LUI V0, -16512
9D000870  8C420230   LW V0, 560(V0)
9D000874  AFC20004   SW V0, 4(FP)
9D000878  8FC30000   LW V1, 0(FP)
9D00087C  8FC20004   LW V0, 4(FP)
9D000880  1462FFF7   BNE V1, V0, 0x9D000860
9D000884  00000000   NOP
9D000888  8FC20000   LW V0, 0(FP)
9D00088C  03C0E825   OR SP, FP, ZERO
9D000890  8FBE000C   LW FP, 12(SP)
9D000894  27BD0010   ADDIU SP, SP, 16
9D000898  03E00008   JR RA
9D00089C  00000000   NOP
9D0008A0  27BDFFF0   ADDIU SP, SP, -16
9D0008A4  AFBE000C   SW FP, 12(SP)
9D0008A8  03A0F025   OR FP, SP, ZERO
9D0008AC  AFC40010   SW A0, 16(FP)
9D0008B0  AFC50014   SW A1, 20(FP)
9D0008B4  3C02BF80   LUI V0, -16512
9D0008B8  8C420230   LW V0, 560(V0)
9D0008BC  AFC20004   SW V0, 4(FP)
9D0008C0  3C02BF80   LUI V0, -16512
9D0008C4  8C420220   LW V0, 544(V0)
9D0008C8  AFC20000   SW V0, 0(FP)
9D0008CC  3C02BF80   LUI V0, -16512
9D0008D0  8C430220   LW V1, 544(V0)
9D0008D4  8FC20010   LW V0, 16(FP)
9D0008D8  AC430000   SW V1, 0(V0)
9D0008DC  3C02BF80   LUI V0, -16512
9D0008E0  8C430230   LW V1, 560(V0)
9D0008E4  8FC20014   LW V0, 20(FP)
9D0008E8  AC430000   SW V1, 0(V0)
9D0008EC  8FC30004   LW V1, 4(FP)
9D0008F0  8FC20014   LW V0, 20(FP)
9D0008F4  8C420000   LW V0, 0(V0)
9D0008F8  1462FFEE   BNE V1, V0, 0x9D0008B4
9D0008FC  00000000   NOP
9D000900  8FC30000   LW V1, 0(FP)
9D000904  8FC20010   LW V0, 16(FP)
9D000908  8C420000   LW V0, 0(V0)
9D00090C  1462FFE9   BNE V1, V0, 0x9D0008B4
9D000910  00000000   NOP
9D000914  00000000   NOP
9D000918  03C0E825   OR SP, FP, ZERO
9D00091C  8FBE000C   LW FP, 12(SP)
9D000920  27BD0010   ADDIU SP, SP, 16
9D000924  03E00008   JR RA
9D000928  00000000   NOP
9D00092C  27BDFFF8   ADDIU SP, SP, -8
9D000930  AFBE0004   SW FP, 4(SP)
9D000934  03A0F025   OR FP, SP, ZERO
9D000938  3C02BF80   LUI V0, -16512
9D00093C  8C420240   LW V0, 576(V0)
9D000940  03C0E825   OR SP, FP, ZERO
9D000944  8FBE0004   LW FP, 4(SP)
9D000948  27BD0008   ADDIU SP, SP, 8
9D00094C  03E00008   JR RA
9D000950  00000000   NOP
9D000954  27BDFFF8   ADDIU SP, SP, -8
9D000958  AFBE0004   SW FP, 4(SP)
9D00095C  03A0F025   OR FP, SP, ZERO
9D000960  3C02BF80   LUI V0, -16512
9D000964  8C420250   LW V0, 592(V0)
9D000968  03C0E825   OR SP, FP, ZERO
9D00096C  8FBE0004   LW FP, 4(SP)
9D000970  27BD0008   ADDIU SP, SP, 8
9D000974  03E00008   JR RA
9D000978  00000000   NOP
9D00097C  27BDFFF8   ADDIU SP, SP, -8
9D000980  AFBE0004   SW FP, 4(SP)
9D000984  03A0F025   OR FP, SP, ZERO
9D000988  AFC40008   SW A0, 8(FP)
9D00098C  AFC5000C   SW A1, 12(FP)
9D000990  3C02BF80   LUI V0, -16512
9D000994  8C430240   LW V1, 576(V0)
9D000998  8FC20008   LW V0, 8(FP)
9D00099C  AC430000   SW V1, 0(V0)
9D0009A0  3C02BF80   LUI V0, -16512
9D0009A4  8C430250   LW V1, 592(V0)
9D0009A8  8FC2000C   LW V0, 12(FP)
9D0009AC  AC430000   SW V1, 0(V0)
9D0009B0  00000000   NOP
9D0009B4  03C0E825   OR SP, FP, ZERO
9D0009B8  8FBE0004   LW FP, 4(SP)
9D0009BC  27BD0008   ADDIU SP, SP, 8
9D0009C0  03E00008   JR RA
9D0009C4  00000000   NOP
9D0009C8  27BDFFF0   ADDIU SP, SP, -16
9D0009CC  AFBE000C   SW FP, 12(SP)
9D0009D0  03A0F025   OR FP, SP, ZERO
9D0009D4  3C02BF80   LUI V0, -16512
9D0009D8  8C420210   LW V0, 528(V0)
9D0009DC  7C4203C0   EXT V0, V0, 15, 1
9D0009E0  304200FF   ANDI V0, V0, 255
9D0009E4  AFC20000   SW V0, 0(FP)
9D0009E8  3C02BF80   LUI V0, -16512
9D0009EC  8C420210   LW V0, 528(V0)
9D0009F0  7C4203C0   EXT V0, V0, 15, 1
9D0009F4  304200FF   ANDI V0, V0, 255
9D0009F8  AFC20004   SW V0, 4(FP)
9D0009FC  8FC30000   LW V1, 0(FP)
9D000A00  8FC20004   LW V0, 4(FP)
9D000A04  1462FFF3   BNE V1, V0, 0x9D0009D4
9D000A08  00000000   NOP
9D000A0C  8FC20000   LW V0, 0(FP)
9D000A10  03C0E825   OR SP, FP, ZERO
9D000A14  8FBE000C   LW FP, 12(SP)
9D000A18  27BD0010   ADDIU SP, SP, 16
9D000A1C  03E00008   JR RA
9D000A20  00000000   NOP
9D000A24  27BDFFF0   ADDIU SP, SP, -16
9D000A28  AFBE000C   SW FP, 12(SP)
9D000A2C  03A0F025   OR FP, SP, ZERO
9D000A30  3C02BF80   LUI V0, -16512
9D000A34  8C420210   LW V0, 528(V0)
9D000A38  7C420380   EXT V0, V0, 14, 1
9D000A3C  304200FF   ANDI V0, V0, 255
9D000A40  AFC20000   SW V0, 0(FP)
9D000A44  3C02BF80   LUI V0, -16512
9D000A48  8C420210   LW V0, 528(V0)
9D000A4C  7C420380   EXT V0, V0, 14, 1
9D000A50  304200FF   ANDI V0, V0, 255
9D000A54  AFC20004   SW V0, 4(FP)
9D000A58  8FC30000   LW V1, 0(FP)
9D000A5C  8FC20004   LW V0, 4(FP)
9D000A60  1462FFF3   BNE V1, V0, 0x9D000A30
9D000A64  00000000   NOP
9D000A68  8FC20000   LW V0, 0(FP)
9D000A6C  03C0E825   OR SP, FP, ZERO
9D000A70  8FBE000C   LW FP, 12(SP)
9D000A74  27BD0010   ADDIU SP, SP, 16
9D000A78  03E00008   JR RA
9D000A7C  00000000   NOP
9D000A80  27BDFFF0   ADDIU SP, SP, -16
9D000A84  AFBE000C   SW FP, 12(SP)
9D000A88  03A0F025   OR FP, SP, ZERO
9D000A8C  3C02BF80   LUI V0, -16512
9D000A90  8C420210   LW V0, 528(V0)
9D000A94  30420F00   ANDI V0, V0, 3840
9D000A98  AFC20000   SW V0, 0(FP)
9D000A9C  3C02BF80   LUI V0, -16512
9D000AA0  8C420210   LW V0, 528(V0)
9D000AA4  30420F00   ANDI V0, V0, 3840
9D000AA8  AFC20004   SW V0, 4(FP)
9D000AAC  8FC30000   LW V1, 0(FP)
9D000AB0  8FC20004   LW V0, 4(FP)
9D000AB4  1462FFF5   BNE V1, V0, 0x9D000A8C
9D000AB8  00000000   NOP
9D000ABC  8FC20000   LW V0, 0(FP)
9D000AC0  00021202   SRL V0, V0, 8
9D000AC4  03C0E825   OR SP, FP, ZERO
9D000AC8  8FBE000C   LW FP, 12(SP)
9D000ACC  27BD0010   ADDIU SP, SP, 16
9D000AD0  03E00008   JR RA
9D000AD4  00000000   NOP
9D000AD8  27BDFFF0   ADDIU SP, SP, -16
9D000ADC  AFBE000C   SW FP, 12(SP)
9D000AE0  03A0F025   OR FP, SP, ZERO
9D000AE4  3C02BF80   LUI V0, -16512
9D000AE8  90420210   LBU V0, 528(V0)
9D000AEC  304200FF   ANDI V0, V0, 255
9D000AF0  AFC20000   SW V0, 0(FP)
9D000AF4  3C02BF80   LUI V0, -16512
9D000AF8  90420210   LBU V0, 528(V0)
9D000AFC  304200FF   ANDI V0, V0, 255
9D000B00  AFC20004   SW V0, 4(FP)
9D000B04  8FC30000   LW V1, 0(FP)
9D000B08  8FC20004   LW V0, 4(FP)
9D000B0C  1462FFF5   BNE V1, V0, 0x9D000AE4
9D000B10  00000000   NOP
9D000B14  8FC20000   LW V0, 0(FP)
9D000B18  03C0E825   OR SP, FP, ZERO
9D000B1C  8FBE000C   LW FP, 12(SP)
9D000B20  27BD0010   ADDIU SP, SP, 16
9D000B24  03E00008   JR RA
9D000B28  00000000   NOP
9D000B2C  27BDFFF8   ADDIU SP, SP, -8
9D000B30  AFBE0004   SW FP, 4(SP)
9D000B34  03A0F025   OR FP, SP, ZERO
9D000B38  3C02BF80   LUI V0, -16512
9D000B3C  8C420200   LW V0, 512(V0)
9D000B40  30428040   ANDI V0, V0, -32704
9D000B44  03C0E825   OR SP, FP, ZERO
9D000B48  8FBE0004   LW FP, 4(SP)
9D000B4C  27BD0008   ADDIU SP, SP, 8
9D000B50  03E00008   JR RA
9D000B54  00000000   NOP
9D000B58  27BDFFF8   ADDIU SP, SP, -8
9D000B5C  AFBE0004   SW FP, 4(SP)
9D000B60  03A0F025   OR FP, SP, ZERO
9D000B64  3C02BF81   LUI V0, -16511
9D000B68  8C42F000   LW V0, -4096(V0)
9D000B6C  7C420040   EXT V0, V0, 1, 1
9D000B70  304200FF   ANDI V0, V0, 255
9D000B74  10400007   BEQ V0, ZERO, 0x9D000B94
9D000B78  00000000   NOP
9D000B7C  3C02BF81   LUI V0, -16511
9D000B80  8C42F000   LW V0, -4096(V0)
9D000B84  7C420580   EXT V0, V0, 22, 1
9D000B88  304200FF   ANDI V0, V0, 255
9D000B8C  14400004   BNE V0, ZERO, 0x9D000BA0
9D000B90  00000000   NOP
9D000B94  24020001   ADDIU V0, ZERO, 1
9D000B98  1000000B   BEQ ZERO, ZERO, 0x9D000BC8
9D000B9C  00000000   NOP
9D000BA0  3C02BF80   LUI V0, -16512
9D000BA4  8C420200   LW V0, 512(V0)
9D000BA8  7C420180   EXT V0, V0, 6, 1
9D000BAC  304200FF   ANDI V0, V0, 255
9D000BB0  14400004   BNE V0, ZERO, 0x9D000BC4
9D000BB4  00000000   NOP
9D000BB8  24020002   ADDIU V0, ZERO, 2
9D000BBC  10000002   BEQ ZERO, ZERO, 0x9D000BC8
9D000BC0  00000000   NOP
9D000BC4  00001025   OR V0, ZERO, ZERO
9D000BC8  03C0E825   OR SP, FP, ZERO
9D000BCC  8FBE0004   LW FP, 4(SP)
9D000BD0  27BD0008   ADDIU SP, SP, 8
9D000BD4  03E00008   JR RA
9D000BD8  00000000   NOP
9D000BDC  27BDFFF8   ADDIU SP, SP, -8
9D000BE0  AFBE0004   SW FP, 4(SP)
9D000BE4  03A0F025   OR FP, SP, ZERO
9D000BE8  3C02BF80   LUI V0, -16512
9D000BEC  8C420200   LW V0, 512(V0)
9D000BF0  7C424C00   EXT V0, V0, 16, 10
9D000BF4  3042FFFF   ANDI V0, V0, -1
9D000BF8  03C0E825   OR SP, FP, ZERO
9D000BFC  8FBE0004   LW FP, 4(SP)
9D000C00  27BD0008   ADDIU SP, SP, 8
9D000C04  03E00008   JR RA
9D000C08  00000000   NOP
9D000C0C  27BDFFD0   ADDIU SP, SP, -48
9D000C10  AFBF002C   SW RA, 44(SP)
9D000C14  AFBE0028   SW FP, 40(SP)
9D000C18  03A0F025   OR FP, SP, ZERO
9D000C1C  AFC40030   SW A0, 48(FP)
9D000C20  8FC20030   LW V0, 48(FP)
9D000C24  10400049   BEQ V0, ZERO, 0x9D000D4C
9D000C28  00000000   NOP
9D000C2C  0F400A0B   JAL INTDisableInterrupts
9D000C30  00000000   NOP
9D000C34  AFC20010   SW V0, 16(FP)
9D000C80  AFC20014   SW V0, 20(FP)
9D000C84  3C02BF81   LUI V0, -16511
9D000C88  AC40F230   SW ZERO, -3536(V0)
9D000C8C  3C02BF81   LUI V0, -16511
9D000C90  3C03AA99   LUI V1, -21863
9D000C94  34636655   ORI V1, V1, 26197
9D000C98  AC43F230   SW V1, -3536(V0)
9D000C9C  3C02BF81   LUI V0, -16511
9D000CA0  3C035566   LUI V1, 21862
9D000CA4  346399AA   ORI V1, V1, -26198
9D000CA8  AC43F230   SW V1, -3536(V0)
9D000CAC  3C02BF80   LUI V0, -16512
9D000CB0  24030008   ADDIU V1, ZERO, 8
9D000CB4  AC430208   SW V1, 520(V0)
9D000CB8  3C02BF81   LUI V0, -16511
9D000CBC  3C033333   LUI V1, 13107
9D000CC0  34633333   ORI V1, V1, 13107
9D000CC4  AC43F230   SW V1, -3536(V0)
9D000CC8  8FC20014   LW V0, 20(FP)
9D000CCC  AFC20018   SW V0, 24(FP)
9D000D34  8FC20010   LW V0, 16(FP)
9D000D38  00402025   OR A0, V0, ZERO
9D000D3C  0F4009E5   JAL INTRestoreInterrupts
9D000D40  00000000   NOP
9D000D44  10000004   BEQ ZERO, ZERO, 0x9D000D58
9D000D48  00000000   NOP
9D000D4C  3C02BF80   LUI V0, -16512
9D000D50  24030008   ADDIU V1, ZERO, 8
9D000D54  AC430204   SW V1, 516(V0)
9D000D58  00000000   NOP
9D000D5C  03C0E825   OR SP, FP, ZERO
9D000D60  8FBF002C   LW RA, 44(SP)
9D000D64  8FBE0028   LW FP, 40(SP)
9D000D68  27BD0030   ADDIU SP, SP, 48
9D000D6C  03E00008   JR RA
9D000D70  00000000   NOP
9D000D74  27BDFFF8   ADDIU SP, SP, -8
9D000D78  AFBE0004   SW FP, 4(SP)
9D000D7C  03A0F025   OR FP, SP, ZERO
9D000D80  3C02BF80   LUI V0, -16512
9D000D84  8C420200   LW V0, 512(V0)
9D000D88  7C4200C0   EXT V0, V0, 3, 1
9D000D8C  304200FF   ANDI V0, V0, 255
9D000D90  03C0E825   OR SP, FP, ZERO
9D000D94  8FBE0004   LW FP, 4(SP)
9D000D98  27BD0008   ADDIU SP, SP, 8
9D000D9C  03E00008   JR RA
9D000DA0  00000000   NOP
9D000DA4  27BDFFF8   ADDIU SP, SP, -8
9D000DA8  AFBE0004   SW FP, 4(SP)
9D000DAC  03A0F025   OR FP, SP, ZERO
9D000DB0  3C02BF80   LUI V0, -16512
9D000DB4  8C420200   LW V0, 512(V0)
9D000DB8  7C420080   EXT V0, V0, 2, 1
9D000DBC  304200FF   ANDI V0, V0, 255
9D000DC0  03C0E825   OR SP, FP, ZERO
9D000DC4  8FBE0004   LW FP, 4(SP)
9D000DC8  27BD0008   ADDIU SP, SP, 8
9D000DCC  03E00008   JR RA
9D000DD0  00000000   NOP
9D000DD4  27BDFFF8   ADDIU SP, SP, -8
9D000DD8  AFBE0004   SW FP, 4(SP)
9D000DDC  03A0F025   OR FP, SP, ZERO
9D000DE0  3C02BF80   LUI V0, -16512
9D000DE4  8C420200   LW V0, 512(V0)
9D000DE8  7C420040   EXT V0, V0, 1, 1
9D000DEC  304200FF   ANDI V0, V0, 255
9D000DF0  03C0E825   OR SP, FP, ZERO
9D000DF4  8FBE0004   LW FP, 4(SP)
9D000DF8  27BD0008   ADDIU SP, SP, 8
9D000DFC  03E00008   JR RA
9D000E00  00000000   NOP
9D000E04  27BDFFF8   ADDIU SP, SP, -8
9D000E08  AFBE0004   SW FP, 4(SP)
9D000E0C  03A0F025   OR FP, SP, ZERO
9D000E10  3C02BF80   LUI V0, -16512
9D000E14  8C420210   LW V0, 528(V0)
9D000E18  7C420300   EXT V0, V0, 12, 1
9D000E1C  304200FF   ANDI V0, V0, 255
9D000E20  03C0E825   OR SP, FP, ZERO
9D000E24  8FBE0004   LW FP, 4(SP)
9D000E28  27BD0008   ADDIU SP, SP, 8
9D000E2C  03E00008   JR RA
9D000E30  00000000   NOP
9D000E34  27BDFFF8   ADDIU SP, SP, -8
9D000E38  AFBE0004   SW FP, 4(SP)
9D000E3C  03A0F025   OR FP, SP, ZERO
9D000E40  AFC40008   SW A0, 8(FP)
9D000E44  8FC20008   LW V0, 8(FP)
9D000E48  10400006   BEQ V0, ZERO, 0x9D000E64
9D000E4C  00000000   NOP
9D000E50  3C02BF80   LUI V0, -16512
9D000E54  24030080   ADDIU V1, ZERO, 128
9D000E58  AC430208   SW V1, 520(V0)
9D000E5C  10000004   BEQ ZERO, ZERO, 0x9D000E70
9D000E60  00000000   NOP
9D000E64  3C02BF80   LUI V0, -16512
9D000E68  24030080   ADDIU V1, ZERO, 128
9D000E6C  AC430204   SW V1, 516(V0)
9D000E70  00000000   NOP
9D000E74  03C0E825   OR SP, FP, ZERO
9D000E78  8FBE0004   LW FP, 4(SP)
9D000E7C  27BD0008   ADDIU SP, SP, 8
9D000E80  03E00008   JR RA
9D000E84  00000000   NOP
9D000E88  27BDFFF8   ADDIU SP, SP, -8
9D000E8C  AFBE0004   SW FP, 4(SP)
9D000E90  03A0F025   OR FP, SP, ZERO
9D000E94  3C02BF80   LUI V0, -16512
9D000E98  8C420210   LW V0, 528(V0)
9D000E9C  7C420340   EXT V0, V0, 13, 1
9D000EA0  304200FF   ANDI V0, V0, 255
9D000EA4  03C0E825   OR SP, FP, ZERO
9D000EA8  8FBE0004   LW FP, 4(SP)
9D000EAC  27BD0008   ADDIU SP, SP, 8
9D000EB0  03E00008   JR RA
9D000EB4  00000000   NOP
9D000EB8  27BDFFF8   ADDIU SP, SP, -8
9D000EBC  AFBE0004   SW FP, 4(SP)
9D000EC0  03A0F025   OR FP, SP, ZERO
9D000EC4  AFC40008   SW A0, 8(FP)
9D000EC8  8FC20008   LW V0, 8(FP)
9D000ECC  10400006   BEQ V0, ZERO, 0x9D000EE8
9D000ED0  00000000   NOP
9D000ED4  3C02BF80   LUI V0, -16512
9D000ED8  24030001   ADDIU V1, ZERO, 1
9D000EDC  AC430208   SW V1, 520(V0)
9D000EE0  10000004   BEQ ZERO, ZERO, 0x9D000EF4
9D000EE4  00000000   NOP
9D000EE8  3C02BF80   LUI V0, -16512
9D000EEC  24030001   ADDIU V1, ZERO, 1
9D000EF0  AC430204   SW V1, 516(V0)
9D000EF4  00000000   NOP
9D000EF8  03C0E825   OR SP, FP, ZERO
9D000EFC  8FBE0004   LW FP, 4(SP)
9D000F00  27BD0008   ADDIU SP, SP, 8
9D000F04  03E00008   JR RA
9D000F08  00000000   NOP
9D000F0C  27BDFFF8   ADDIU SP, SP, -8
9D000F10  AFBE0004   SW FP, 4(SP)
9D000F14  03A0F025   OR FP, SP, ZERO
9D000F18  3C02BF80   LUI V0, -16512
9D000F1C  8C420200   LW V0, 512(V0)
9D000F20  7C420000   EXT V0, V0, 0, 1
9D000F24  304200FF   ANDI V0, V0, 255
9D000F28  03C0E825   OR SP, FP, ZERO
9D000F2C  8FBE0004   LW FP, 4(SP)
9D000F30  27BD0008   ADDIU SP, SP, 8
9D000F34  03E00008   JR RA
9D000F38  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/pmp.h  ---------------------
1:                   /******************************************************************************
2:                    *
3:                    *                  PMP (Parallel Master Port) Library definitions
4:                    *
5:                    ******************************************************************************
6:                    * FileName:        pmp.h
7:                    * Dependencies:	xc.h, int.h
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the “Company”) for its PIC32MX Microcontroller is intended
18:                   * and supplied to you, the Company’s customer, for use solely and
19:                   * exclusively on Microchip PIC32MX Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   *
35:                   * $Id: PMP.h,v 1.4 2006/11/15 21:22:46 C11842 Exp $
36:                   *
37:                   * $Name:  $
38:                   *
39:                   *****************************************************************************/
40:                  #ifndef PMP_H
41:                  #define PMP_H
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/int.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  typedef enum {BUF0, BUF1, BUF2, BUF3}BUFFER ;
58:                  
59:                  /******************************************************************************
60:                   * Parallel Master Port General Purpose macros
61:                   *
62:                   * Macros:
63:                   *          To enable/disable module's opeation when cpu is in IDLE mode
64:                   *                  mPMPIdleStop(void)
65:                   *                  mPMPIdleContinue(void)
66:                   *
67:                   *          To enable/disable PMP module
68:                   *                  mPMPEnable(void)
69:                   *                  mPMPDisable(void)
70:                   *
71:                   *          To check if Master Mode I,II read/write is busy
72:                   *                  mPMPGetBusyFlag(void)
73:                   *                  mPMPIsPMPBusy(void)
74:                   *
75:                   * PreCondition:    None
76:                   *
77:                   * Parameters:           None
78:                   *
79:                   * Returns:          None
80:                   *
81:                   * Example:         mIsPMPBusy();
82:                   *
83:                   *****************************************************************************/
84:                  #define mPMPIdleStop()                          (PMCONSET = _PMCON_SIDL_MASK)
85:                  #define mPMPIdleContinue()                      (PMCONCLR = _PMCON_SIDL_MASK)
86:                  #define mPMPEnable()                            (PMCONSET = _PMCON_ON_MASK)
87:                  #define mPMPDisable()                           (PMCONCLR = _PMCON_ON_MASK)
88:                  #define mPMPGetBusyFlag()                       (PMMODEbits.BUSY)
89:                  #define mIsPMPBusy()                            (PMMODEbits.BUSY)
90:                  
91:                  /******************************************************************************
92:                    Parallel Master Port Open Function
93:                   
94:                    Function:        void PMPOpen(unsigned int CONTROL, unsigned int MODE, unsigned int PORT, unsigned int INTERRUPT)
95:                   
96:                    PreCondition:    None
97:                   
98:                    Parameters:           
99:                  		 CONTROL   - control bits
100:                          MODE      - mode bits
101:                          PORT      - port bits
102:                          INTERRUPT - interrupt bits
103:                  				   - these are Bit-wise OR values of defined bit-masks, see example below
104:                  
105:                   Remarks:          An absent symbol assumes corresponding bit(s)
106:                  					are disabled, or default value, and will be set = 0.
107:                  
108:                   Returns:          None
109:                  
110:                   Example:
111:                   <code>
112:                   #define CONTROL  (PMP_ON | PMP_IDLE_CON | PMP_MUX_DATA8_LOWER | PMP_READ_WRITE_EN | \
113:                                    PMP_CS2_CS1_EN | PMP_LATCH_POL_HI | PMP_CS2_POL_LO | PMP_CS1_POL_LO |\
114:                                    PMP_WRITE_POL_LO | PMP_READ_POL_LO)
115:                  
116:                   #define MODE     (PMP_IRQ_OFF | PMP_AUTO_ADDR_OFF | PMP_DATA_BUS_8 | PMP_MODE_MASTER2 |\
117:                                    PMP_WAIT_BEG_3 | PMP_WAIT_MID_7 | PMP_WAIT_END_3 )
118:                  
119:                   #define PORT     (PMP_PEN_ALL)
120:                  
121:                   #define INT      (PMP_INT_OFF)
122:                  
123:                                    PMPOpen(CONTROL, MODE, PORT, INT);
124:                   </code>
125:                  
126:                  ******************************************************************************/
127:                 #define mPMPOpen(control, mode, port, interrupt)\
128:                 (\
129:                     PMCON = (control), PMMODE = (mode), PMAEN = (port), mPMPClearIntFlag(),\
130:                 	mPMPSetIntPriority(((interrupt) & 7)), mPMPSetIntSubPriority((((interrupt)>> 4) & 3)),\
131:                 	mPMPIntEnable(((interrupt) >> 15))\
132:                 )
133:                 
134:                 	/******************************************************************************
135:                 	 * Available options for CONTROL parameter
136:                 	 *****************************************************************************/
137:                 		// On/off control - values are mutually exclusive
138:                 		#define PMP_ON  					        (1 << _PMCON_ON_POSITION)		/* Configure PMP enabled */
139:                 		#define PMP_OFF								(0)								/* Default */
140:                 
141:                 		/* STOP DURING IDLE control - values are mutually exclusive */
142:                 		#define PMP_IDLE_CON                        (0)								/* Operate during IDLE  - default */
143:                 		#define PMP_IDLE_STOP						(1 << _PMCON_SIDL_POSITION)
144:                 
145:                 		/* PMP Address multiplexing mode - values are mutually exclusive */
146:                 		#define PMP_MUX_DATA16_ALL                  (3 << _PMCON_ADRMUX_POSITION)	/* Configure 11 = All 16-bits addrs muxed on 16-bit data */
147:                 		#define PMP_MUX_DATA8_ALL			        (2 << _PMCON_ADRMUX_POSITION)	/* Configure 10 = All 16-bits addrs muxed on 8-bit data */
148:                 		#define PMP_MUX_DATA8_LOWER			        (1 << _PMCON_ADRMUX_POSITION)	/* Configure 01 = Lower 8-bits addrs muxed on 8-bit data */
149:                 		#define PMP_MUX_OFF							(0)								/* Default */
150:                 
151:                 		/* PMP Input buffer type  - values are mutually exclusive */
152:                 		#define PMP_TTL								(1 << _PMCON_PMPTTL_POSITION)	/* Configure 1 = TTL inputs */
153:                 		#define PMP_ST								(0)								/* Configure 0 = Schmidt Trigger inputs - default */
154:                 
155:                 		/* Read and Write Strobes enables - values are mutually exclusive */
156:                 		#define PMP_READ_WRITE_EN    		        (3 << _PMCON_PTRDEN_POSITION)	/* Configure RD, RD/WR strobe = ON; WR, WR/ENB strobe = ON */
157:                 		#define PMP_WRITE_EN    			        (2 << _PMCON_PTRDEN_POSITION)	/* Configure WR, WR/ENB strobe = ON */
158:                 		#define PMP_READ_EN     			        (1 << _PMCON_PTRDEN_POSITION)	/* Configure RD, RD/WR strobe = ON */
159:                 		#define PMP_READ_WRITE_OFF					(0)								/* Default */
160:                 
161:                 		/* Chip select control - values are mutually exclusive */
162:                 		#define PMP_CS2_CS1_EN				        (1 << _PMCON_CSF1_POSITION)		/* Configure 10 = CS1 and CS2 are chip selects */
163:                 		#define PMP_CS2_EN    						(1 << _PMCON_CSF0_POSITION)		/* Configure 01 = CS2 = chip select, CS1 = A14 */
164:                 		#define PMP_CS2_CS1_OFF						(0)								/* Configure 00 = CS2 = A15, CS1 = A14  - default */
165:                 
166:                 		/* PMP Address latch control - values are mutually exclusive */
167:                 		#define PMP_LATCH_POL_HI			        (1 << _PMCON_ALP_POSITION)		/* Configure PMALL, PMALH = active high */
168:                 		#define PMP_LATCH_POL_LO			        (0)								/* Configure PMALL, PMALH = active low - default */
169:                 
170:                 		/* CS polarity control - values are mutually exclusive */
171:                 		#define PMP_CS2_POL_HI						(1 << _PMCON_CS2P_POSITION)		/* Configure CS2 polarity = active high */
172:                 		#define PMP_CS2_POL_LO						(0)								/* Configure CS2 polarity = active low - default */
173:                 		#define PMP_CS1_POL_HI						(1 << _PMCON_CS1P_POSITION)		/* Configure CS1 polarity = active high */
174:                 		#define PMP_CS1_POL_LO						(0)								/* Configure CS1 polarity = active low - default */
175:                 
176:                 		/* RD/RW/WR/ENB POLARITY bit control - values are mutually exclusive */
177:                 		#define PMP_WRITE_POL_HI			        (1 << _PMCON_WRSP_POSITION)		/* Configure Write/ENB strobe polarity = active high */
178:                 		#define PMP_WRITE_POL_LO			        (0)								/* Configure Write/ENB strobe polarity = active low - default */
179:                 		#define PMP_READ_POL_HI	    		        (1 << _PMCON_RDSP_POSITION)		/* Configure Read/RW strobe polarity = active high */
180:                 		#define PMP_READ_POL_LO				        (0)								/* Configure Read/RW strobe polarity = active low */
181:                 
182:                 
183:                 	/******************************************************************************
184:                 	 * Available options for MODE parameter
185:                 	 *****************************************************************************/
186:                 		/* PMP interrupt mode - values are mutually exclusive */
187:                 		#define PMP_IRQ_BUF_FULL                    (2 << _PMMODE_IRQM_POSITION)	/* Configure Interrupt on buffer full */
188:                 		#define PMP_IRQ_READ_WRITE                  (1 << _PMMODE_IRQM_POSITION)	/* Configure Interrupt at end of R/W cycle */
189:                 		#define PMP_IRQ_OFF							(0)
190:                 
191:                 		/* Auto Increment/Decrement FUNCTION SELECTION BITS configuration bit mask defines - values are mutually exclusive */
192:                 		#define PMP_AUTO_ADDR_BUFFER		        (3 << _PMMODE_INCM_POSITION)	/* Configure 11 = SLAVE R/W buffers auto increment */
193:                 		#define PMP_AUTO_ADDR_DEC   		        (2 << _PMMODE_INCM_POSITION)	/* Configure 10 = Addrs decrements on every R/W cycle */
194:                 		#define PMP_AUTO_ADDR_INC	    	        (1 << _PMMODE_INCM_POSITION)	/* Configure 01 = Addrs increments on every R/W cycle */
195:                 		#define PMP_AUTO_ADDR_OFF					(0)
196:                 
197:                 		/* MODE16/8 FUNCTION BITS configuration bit mask defines - values are mutually exclusive */
198:                 		#define PMP_DATA_BUS_16			        	(1 << _PMMODE_MODE16_POSITION)	/* Configure 16-bit data mode */
199:                 		#define PMP_DATA_BUS_8			        	(0)								/* Configure 8-bit data mode (default)*/
200:                 
201:                 		/* Master/Slave MODE FUNCTION SELECTION BITS configuration bit mask defines - values are mutually exclusive */
202:                 		#define PMP_MODE_MASTER1			        (3 << _PMMODE_MODE_POSITION)	/* Configure MASTER mode 1 */
203:                 		#define PMP_MODE_MASTER2			        (2 << _PMMODE_MODE_POSITION)	/* Configure MASTER modw 2 */
204:                 		#define PMP_MODE_ESLAVE     		        (1 << _PMMODE_MODE_POSITION)	/* Configure SLAVE enhanced mode */
205:                 		#define PMP_MODE_SLAVE				        (0)								/* Configure SLAVE mode */
206:                 
207:                 		/* PMP Beginning phase wait states - values are mutually exclusive */
208:                 		#define PMP_WAIT_BEG_4				        (3 << _PMMODE_WAITB_POSITION)	/* Configure 4 Tpb WAIT */
209:                 		#define PMP_WAIT_BEG_3				        (2 << _PMMODE_WAITB_POSITION)	/* Configure 3 Tpb WAIT */
210:                 		#define PMP_WAIT_BEG_2				        (1 << _PMMODE_WAITB_POSITION)	/* Configure 2 Tpb WAIT */
211:                 		#define PMP_WAIT_BEG_1				        (0)								/* Configure 1 Tpb WAIT */
212:                 
213:                 		/* PMP Middle phase wait states - values are mutually exclusive */
214:                 		#define PMP_WAIT_MID_15				        (15 << _PMMODE_WAITM_POSITION)	/* Configure 3 Tpb WAIT */
215:                 		#define PMP_WAIT_MID_14				        (14 << _PMMODE_WAITM_POSITION)	/* Configure 2 Tpb WAIT */
216:                 		#define PMP_WAIT_MID_13				        (13 << _PMMODE_WAITM_POSITION)	/* Configure 1 Tpb WAIT */
217:                 		#define PMP_WAIT_MID_12				        (12 << _PMMODE_WAITM_POSITION)	/* Configure 4 Tpb WAIT */
218:                 		#define PMP_WAIT_MID_11				        (11 << _PMMODE_WAITM_POSITION)	/* Configure 3 Tpb WAIT */
219:                 		#define PMP_WAIT_MID_10				        (10 << _PMMODE_WAITM_POSITION)	/* Configure 2 Tpb WAIT */
220:                 		#define PMP_WAIT_MID_9				        (9 << _PMMODE_WAITM_POSITION)	/* Configure 1 Tpb WAIT */
221:                 		#define PMP_WAIT_MID_8				        (8 << _PMMODE_WAITM_POSITION)	/* Configure 4 Tpb WAIT */
222:                 		#define PMP_WAIT_MID_7				        (7 << _PMMODE_WAITM_POSITION)	/* Configure 3 Tpb WAIT */
223:                 		#define PMP_WAIT_MID_6				        (6 << _PMMODE_WAITM_POSITION)	/* Configure 2 Tpb WAIT */
224:                 		#define PMP_WAIT_MID_5				        (5 << _PMMODE_WAITM_POSITION)	/* Configure 1 Tpb WAIT */
225:                 		#define PMP_WAIT_MID_4				        (4 << _PMMODE_WAITM_POSITION)	/* Configure 4 Tpb WAIT */
226:                 		#define PMP_WAIT_MID_3				        (3 << _PMMODE_WAITM_POSITION)	/* Configure 3 Tpb WAIT */
227:                 		#define PMP_WAIT_MID_2				        (2 << _PMMODE_WAITM_POSITION)	/* Configure 3 Tpb WAIT */
228:                 		#define PMP_WAIT_MID_1				        (1 << _PMMODE_WAITM_POSITION)	/* Configure 2 Tpb WAIT */
229:                 		#define PMP_WAIT_MID_0				        (0)								/* Configure 1 Tpb WAIT */
230:                 
231:                 		/* PMP end phase wait states - values are mutually exclusive  */
232:                 		#define PMP_WAIT_END_4				        (3 << _PMMODE_WAITE_POSITION)	/* Configure 4 Tpb WAIT */
233:                 		#define PMP_WAIT_END_3				        (2 << _PMMODE_WAITE_POSITION)	/* Configure 3 Tpb WAIT */
234:                 		#define PMP_WAIT_END_2				        (1 << _PMMODE_WAITE_POSITION)	/* Configure 2 Tpb WAIT */
235:                 		#define PMP_WAIT_END_1				        (0 << _PMMODE_WAITE_POSITION)	/* Configure 1 Tpb WAIT */
236:                 
237:                 
238:                 	/******************************************************************************
239:                 	 * Available options for PORT parameter
240:                 	 *****************************************************************************/
241:                 		/* PMP Port enable control- values are mutually exclusive  */
242:                 		#define PMP_PEN_ALL					        (0xFFFF)						/* Enable All PMA and PMCS PINS*/
243:                 		#define PMP_PEN_15							(1 << _PMAEN_PTEN15_POSITION)	/* Enable Addrs PIN 15 */
244:                 		#define PMP_PEN_14					        (1 << _PMAEN_PTEN14_POSITION)	/* Enable Addrs PIN 14 */
245:                 		#define PMP_PEN_13					        (1 << _PMAEN_PTEN13_POSITION)	/* Enable Addrs PIN 13 */
246:                 		#define PMP_PEN_12					        (1 << _PMAEN_PTEN12_POSITION)	/* Enable Addrs PIN 12 */
247:                 		#define PMP_PEN_11					        (1 << _PMAEN_PTEN11_POSITION)	/* Enable Addrs PIN 11 */
248:                 		#define PMP_PEN_10					        (1 << _PMAEN_PTEN10_POSITION)	/* Enable Addrs PIN 10 */
249:                 		#define PMP_PEN_9					        (1 << _PMAEN_PTEN9_POSITION)	/* Enable Addrs PIN 9 */
250:                 		#define PMP_PEN_8					        (1 << _PMAEN_PTEN8_POSITION)	/* Enable Addrs PIN 8 */
251:                 		#define PMP_PEN_7					        (1 << _PMAEN_PTEN7_POSITION)	/* Enable Addrs PIN 7 */
252:                 		#define PMP_PEN_6					        (1 << _PMAEN_PTEN6_POSITION)	/* Enable Addrs PIN 6 */
253:                 		#define PMP_PEN_5					        (1 << _PMAEN_PTEN5_POSITION)	/* Enable Addrs PIN 5 */
254:                 		#define PMP_PEN_4					        (1 << _PMAEN_PTEN4_POSITION)	/* Enable Addrs PIN 4 */
255:                 		#define PMP_PEN_3					        (1 << _PMAEN_PTEN3_POSITION)	/* Enable Addrs PIN 3 */
256:                 		#define PMP_PEN_2					        (1 << _PMAEN_PTEN2_POSITION)	/* Enable Addrs PIN 2 */
257:                 		#define PMP_PEN_1					        (1 << _PMAEN_PTEN1_POSITION)	/* Enable Addrs PIN 1 */
258:                 		#define PMP_PEN_0					        (1 << _PMAEN_PTEN0_POSITION)	/* Enable Addrs PIN 0 */
259:                 		#define PMP_PEN_OFF                         (0)								/* Disable all */
260:                 
261:                 
262:                 	/******************************************************************************
263:                 	 * Available options for INTERRUPT parameter
264:                 	 *****************************************************************************/
265:                 		// PMP interrupt control - values are mutually exclusive
266:                 		#define PMP_INT_ON	        				(1 << 15)						/* Interrupt enable/disable bit */
267:                 		#define PMP_INT_OFF    						(0)								/* Interrupt flag position */
268:                 
269:                 		// PMP interrupt priority - values are mutually exclusive
270:                 		#define PMP_INT_PRI_7					    (7)								/* Interrupt Priority 7 */
271:                 		#define PMP_INT_PRI_6					    (6)								/* Interrupt Priority 6 */
272:                 		#define PMP_INT_PRI_5					    (5)								/* Interrupt Priority 5 */
273:                 		#define PMP_INT_PRI_4					    (4)								/* Interrupt Priority 4 */
274:                 		#define PMP_INT_PRI_3					    (3)								/* Interrupt Priority 3 */
275:                 		#define PMP_INT_PRI_2					    (2)								/* Interrupt Priority 2 */
276:                 		#define PMP_INT_PRI_1					    (1)								/* Interrupt Priority 1 */
277:                 		#define PMP_INT_PRI_0				    	(0)								/* Interrupt Priority 0 */
278:                 
279:                 		// PMP interrupt sub-priority - values are mutually exclusive
280:                 		#define PMP_INT_SUB_PRI_3			        (3 << 4)						/* Interrupt Sub-Priority 3 */
281:                 		#define PMP_INT_SUB_PRI_2					(2 << 4)						/* Interrupt Sub-Priority 2 */
282:                 		#define PMP_INT_SUB_PRI_1					(1 << 4)						/* Interrupt Sub-Priority 1 */
283:                 		#define PMP_INT_SUB_PRI_0					(0 << 4)						/* Interrupt Sub-Priority 0 */
284:                 	/***********************************
285:                 	 * End parameter values
286:                 	 ************************************/
287:                 
288:                 
289:                 /******************************************************************************
290:                  * Parallel Master Port Close Function
291:                  *
292:                  * Macro:           void PMPClose(void)
293:                  *
294:                  * Description:		Disables PMP module, clears PMP interrupt enable and PMP
295:                  *                  interrupt flag.
296:                  *
297:                  * Inputs:			None
298:                  *
299:                  * Returns:          None
300:                  *
301:                  * Example:			PMPClose();
302:                  *
303:                  *****************************************************************************/
304:                 #define mPMPClose()     (    mPMPIntEnable(0), mPMPDisable(), mPMPClearIntFlag())
305:                 
306:                 
307:                 /******************************************************************************
308:                  * Parallel Master Port Set Address Function
309:                  *
310:                  * Function:        PMPSetAddress(unsigned short)
311:                  *
312:                  * PreCondition:    None
313:                  *
314:                  * Parameters:           (unsigned short) addrs
315:                  *
316:                  * Returns:          None
317:                  *
318:                  * Example:         PMPSetAddress(0x4800);
319:                  *
320:                  * Note             Copies argument #1 into the PMADDR register.
321:                  *          		Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
322:                  *****************************************************************************/
323:                 extern inline void __attribute__((always_inline)) PMPSetAddress(unsigned int addrs)
324:                 {
325:                     while(mIsPMPBusy());
326:                     PMADDR = addrs;
327:                 }
328:                 /******************************************************************************
329:                  * Parallel Master Port Read Byte Macro
330:                  *
331:                  * Macro:	        mPMPMasterReadByte ()
332:                  *
333:                  * PreCondition:    None
334:                  *
335:                  * Parameters:           None
336:                  *
337:                  * Returns:          (unsigned char) value
338:                  *
339:                  * Example:         value = mPMPMasterReadByte();
340:                  *
341:                  * Remarks:            This macro calls function PMPMasterRead() and casts return
342:                  *					value = unsigned char
343:                  *
344:                  *****************************************************************************/
345:                 #define mPMPMasterReadByte()             ((unsigned char) PMPMasterRead())
346:                 
347:                 
348:                 /******************************************************************************
349:                  * Parallel Master Port Read Word Macro
350:                  *
351:                  * Macro:	        mPMPMasterReadWord ()
352:                  *
353:                  * PreCondition:    None
354:                  *
355:                  * Parameters:           None
356:                  *
357:                  * Returns:          (unsigned short) value
358:                  *
359:                  * Example:         value = mPMPMasterReadWord();
360:                  *
361:                  * Remarks:            This macro calls function PMPMasterRead() and casts return
362:                  *					value = unsigned word
363:                  *
364:                  *****************************************************************************/
365:                 #define mPMPMasterReadWord()             ((unsigned short) PMPMasterRead())
366:                 
367:                 
368:                 /******************************************************************************
369:                  * Parallel Master Port Master mode I,II Read Function
370:                  *
371:                  * Function:        unsigned int PMPMasterRead(void)
372:                  *
373:                  * PreCondition:    None
374:                  *
375:                  * Parameters:           None
376:                  *
377:                  * Returns:          (unsigned int) - Returns the current contents of PMDIN register
378:                  *
379:                  * Example:         value = PMPMasterRead();
380:                  *
381:                  * Remarks:            Returns the current contents of PMDIN register
382:                  *
383:                  *					Note 1: This function is blocking while the PMMODE busy flag
384:                  *					is being polled.
385:                  *
386:                  *					Note 2: Due to the architecture of the PMP module, the data
387:                  *					obtained from the PMDIN register is actually the latched value
388:                  *					from the previous read operation.  Refer to the PIC32MX Family
389:                  *					Reference Manual for further details regarding this behavior.
390:                  *
391:                  *					Note 3: Depending on the PMP mode, the data could be 8-bit or 16-bit.
392:                  *					However, the value returned is always 32-bits wide (unsigned int).
393:                  *					For example, in 8-bit mode, a value of 0xFF read from an external
394:                  *					device will be returned from this function as 0x000000FF.
395:                  *					Likewise, in 16-bit mode, a value of 0xFFFF read from an external
396:                  *					device will be returned as 0x0000FFFF.
397:                  *
398:                  *					Note 3: Use macros mPMPMasterReadWord or mPMPMasterReadByte to
399:                  *					provide a return value cast to the appropriate size.
400:                  *					mPMPMasterReadWord and mPMPMasterReadByte call PMPMasterRead().
401:                  *
402:                  *      			Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
403:                  *****************************************************************************/
404:                 extern inline unsigned int __attribute__((always_inline)) PMPMasterRead(void)
405:                 {
406:                 	while(mIsPMPBusy());
407:                 	return(PMDIN);
408:                 }
409:                 
410:                 
411:                 /******************************************************************************
412:                  * Parallel Master Port Read a block of bytes (8-bit)
413:                  *
414:                  * Function:        void PMPMasterReadByteBlock(unsigned int, unsigned int,
415:                  *                                              unsigned char*)
416:                  *
417:                  * PreCondition:    None
418:                  *
419:                  * Parameters:           
420:                 					Argument #1 (unsigned int) addrs = starting address
421:                  *                  Argument #2 (unsigned int) bytes = number of bytes to read
422:                  *                  Argument #3 (unsigned char*) pDest = byte data destination
423:                  *
424:                  * Returns:          None
425:                  *
426:                  * Example:         PMPMasterReadByteBlock(0x6400, 32, &myArray);
427:                  *
428:                  * Remarks:            Reads N bytes (argument #2) starting at location specified
429:                  *                  in (argument #1) and stores the data at destination
430:                  *                  specified by byte pointer (argument #3)
431:                  *
432:                  *                  Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
433:                  *****************************************************************************/
434:                 void PMPMasterReadByteBlock(unsigned int addrs, unsigned int bytes, unsigned char* pDest);
435:                 
436:                 
437:                 /******************************************************************************
438:                  * Parallel Master Port Read a block of words (16-bit)
439:                  *
440:                  * Function:        void PMPMasterReadWordBlock(unsigned int, unsigned int,
441:                  *                                              unsigned short*)
442:                  *
443:                  * PreCondition:    None
444:                  *
445:                  * Parameters:           
446:                 					Argument #1 (unsigned int) addrs = starting address
447:                  *                  Argument #2 (unsigned int) words = number of words to read
448:                  *                  Argument #3 (unsigned short*) pDest = word data destination
449:                  *
450:                  * Returns:          None
451:                  *
452:                  * Example:         PMPMasterReadWordBlock(0x6400, 16, &myArray);
453:                  *
454:                  * Remarks:            Reads N words (argument #2) starting at location specified
455:                  *                  in (argument #1) and stores the data at destination
456:                  *                  specified by byte pointer (argument #3)
457:                  *
458:                  *                  Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
459:                  *****************************************************************************/
460:                 void PMPMasterReadWordBlock(unsigned int addrs, unsigned int words, unsigned short* pDest);
461:                 
462:                 
463:                 /******************************************************************************
464:                  * Parallel Master Port Master mode I,II Write Function
465:                  *
466:                  * Function:        void PMPMasterWrite(unsigned int)
467:                  *
468:                  * PreCondition:    None
469:                  *
470:                  * Parameters:           
471:                 					Argument #1 (unsigned int) value to be written to PMDIN register
472:                  *
473:                  * Returns:         None
474:                  *
475:                  * Example:         PMPMasterWrite(0xAA);
476:                  *
477:                  * Remarks:    		In 8-bit data mode, the 8-bits of data appear on the lower 8
478:                  *					data lines while the upper 8-bits are not used.
479:                  *					In 16-bit data mode, the lower 8-bits appear on the lower 8
480:                  *					data lines and the upper 8-bits of data appear on the upper
481:                  *					8 data lines.
482:                  *
483:                  *					Note 1: This function is blocking while the PMMODE busy flag
484:                  *					is being polled.
485:                  *
486:                  *      			Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
487:                  *****************************************************************************/
488:                 extern inline void __attribute__((always_inline)) PMPMasterWrite(unsigned short value)
489:                 {
490:                 	while(mIsPMPBusy());
491:                 	PMDIN = value;
492:                 }
493:                 
494:                 
495:                 /******************************************************************************
496:                  * Parallel Master Port Write a block of bytes (8-bit)
497:                  *
498:                  * Function:        void PMPMasterWriteByteBlock(unsigned int, unsigned int,
499:                  *                                               unsigned char*)
500:                  *
501:                  * PreCondition:    None
502:                  *
503:                  * Parameters:           
504:                 					(unsigned int) addrs - starting address
505:                  *                  (unsigned int) bytes - number of bytes to read
506:                  *                  (unsigned char*) source - byte data destination
507:                  *
508:                  * Returns:          None
509:                  *
510:                  * Example:         PMPMasterWriteByteBlock(0x8000, 0x800, &myArray);
511:                  *
512:                  * Overview:        Writes N bytes (argument #2) starting at location specified
513:                  *                  in (argument #1), from the destination specified by
514:                  *                  byte pointer (argument #3)
515:                  *
516:                  * Remarks:            Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
517:                  *****************************************************************************/
518:                 void PMPMasterWriteByteBlock(unsigned int addrs, unsigned int bytes, unsigned char* source);
519:                 
520:                 
521:                 /******************************************************************************
522:                  * Parallel Master Port Write a block of words (16-bit)
523:                  *
524:                  * Function:        void PMPMasterWriteWordBlock(unsigned int, unsigned int,
525:                  *                                               unsigned short*)
526:                  *
527:                  * PreCondition:    None
528:                  *
529:                  * Parameters:           
530:                 					Argument #1 (unsigned int) addrs = starting address
531:                  *                  Argument #2 (unsigned int) words = number of words to write
532:                  *                  Argument #3 (unsigned char*) source = word data destination
533:                  *
534:                  * Returns:          None
535:                  *
536:                  * Example:         PMPMasterWriteWordBlock(0x8000, 16, &myArray);
537:                  *
538:                  * Remarks:            Writes N words (argument #2) starting at location specified
539:                  *                  in (argument #1), from the destination specified by
540:                  *                  word pointer (argument #3).
541:                  *
542:                  *                  Use in MASTER mode 1 or 2, MODE[1:0] = 10, 11
543:                  *****************************************************************************/
544:                 void PMPMasterWriteWordBlock(unsigned int addrs, unsigned int words, unsigned short* source);
545:                 
546:                 
547:                 /******************************************************************************
548:                  * Parallel Master Port Read Slave Buffer Function
549:                  *
550:                  * Function:        unsigned int PMPSlaveReadBuffer(enum BUFFER)
551:                  *
552:                  * PreCondition:    None
553:                  *
554:                  * Parameters:           (enum BUFFER) 0..3
555:                  *
556:                  * Returns:          The value in selected buffer register.
557:                  *
558:                  * Example:         value = PMPSlaveReadBuffer(BUF0);
559:                  *
560:                  * Remarks:            Reads the value in PMDIN register.
561:                  *
562:                  *                  Use in SLAVE BUFFERED mode, MODE[1:0] = 00 and INCM[1:0]=11
563:                  *					or SLAVE ENHANCED mode, MODE[1:0] = 01
564:                  *****************************************************************************/
565:                 unsigned char PMPSlaveReadBuffer(BUFFER);
566:                 
567:                 
568:                 /******************************************************************************
569:                  * Parallel Master Port Read Enhanced Slave Buffers Function
570:                  *
571:                  * Function:        void PMPSlaveReadBuffers(unsigned char*)
572:                  *
573:                  * PreCondition:    None
574:                  *
575:                  * Parameters:           (unsigned char* ) pointer to destination array
576:                  *
577:                  * Returns:          The contents of the (4) 8-bit slave buffer registers.
578:                  *
579:                  * Example:         PMPSlaveReadBuffers(&myArray);
580:                  *
581:                  * Remarks:            Copies 4 bytes from DATAIN buffers to a starting location
582:                  *					pointed to by input parameter.
583:                  *
584:                  *                  Use in SLAVE BUFFERED mode, MODE[1:0] = 00 and INCM[1:0]=11
585:                  *					or SLAVE ENHANCED mode, MODE[1:0] = 01
586:                  *****************************************************************************/
587:                 void PMPSlaveReadBuffers(unsigned char* pDest);
588:                 
589:                 
590:                 /******************************************************************************
591:                  * Parallel Master Port Write Slave Buffer Function
592:                  *
593:                  * Function:        void PMPSlaveWriteBuffer(enum BUFFER, unsigned char)
594:                  *
595:                  * PreCondition:    None
596:                  *
597:                  * Parameters:           Argument #1 (enum BUFFER) = 0..3
598:                  *                  Argument #2 (unsigned char) = value to be written
599:                  *
600:                  * Returns:          None
601:                  *
602:                  * Example:         PMPSlaveWriteBuffer(BUF2, 0x88);
603:                  *
604:                  * Remarks:            Writes the desired value into the selected output buffer.
605:                  *                  This function does not check or modify the OBUF bit and
606:                  *                  therefore it is the user's responsibility to check for
607:                  *                  an overflow condition.
608:                  *
609:                  *                  Use in SLAVE BUFFERED mode, MODE[1:0] = 00
610:                  *					or SLAVE ENHANCED mode, MODE[1:0] = 00  and INCM[1:0]=11
611:                  *****************************************************************************/
612:                 void PMPSlaveWriteBuffer(BUFFER, unsigned char value);
613:                 
614:                 
615:                 
616:                 /******************************************************************************
617:                  * Parallel Master Port Write Enhanced Slave Buffers Function
618:                  *
619:                  * Function:        void PMPSlaveWriteBuffers(unsigned char*)
620:                  *
621:                  * PreCondition:    None
622:                  *
623:                  * Parameters:           (unsigned char*) source = pointer to data
624:                  *
625:                  * Returns:          None
626:                  *
627:                  * Example:         PMPSlaveWriteBuffers(&myArray);
628:                  *
629:                  * Remarks:            Copies 4 bytes, addressed by the pointer argument #1, into
630:                  *					the corresponding PMDOUT registers.
631:                  *
632:                  *                  Use in SLAVE BUFFERED mode, MODE[1:0] = 00
633:                  *					or SLAVE ENHANCED mode, MODE[1:0] = 00  and INCM[1:0]=11
634:                  *****************************************************************************/
635:                 void PMPSlaveWriteBuffers(unsigned char* source);
636:                 
637:                 
638:                 /******************************************************************************
639:                  * Parallel Master Port Read Slave Macro
640:                  *
641:                  * Macro:	        mPMPSlaveRead ()
642:                  *
643:                  * PreCondition:    None
644:                  *
645:                  * Parameters:           None
646:                  *
647:                  * Returns:          8-bit value in slave buffer register
648:                  *
649:                  * Example:         value = mPMPSlaveRead();
650:                  *
651:                  * Remarks:            
652:                 					Reads the value in PMDIN register
653:                  *
654:                  *					Note 1: This macro does not check the status of the
655:                  *					PMSTAT.IBF (input buffer full) bit prior to reading the
656:                  *					PMDIN register.  It is recommended that the user's software
657:                  *					verify PMSTAT.IBF = 1 prior to reading the PMDIN register.
658:                  *
659:                  *		            Note 2: If an external master write occurs before the current
660:                  *					contents of the PMDIN register is performed, the IBOV flag
661:                  *					will be set, indicating an overflow.  This function does
662:                  *					not check or modify the IBOV bit.  Therefore it should the
663:                  *					user's responsibility to check for an overflow condition.
664:                  *
665:                  *					Use in SLAVE LEGACY mode, MODE[1:0] = 00
666:                  *****************************************************************************/
667:                 #define mPMPSlaveRead()             (PMDIN)
668:                 
669:                 /******************************************************************************
670:                  * Parallel Master Port Slave Write Macro
671:                  *
672:                  * Macro:	        mPMPSlaveWrite(unsigned char)
673:                  *
674:                  * PreCondition:    None
675:                  *
676:                  * Parameters:           (unsigned char) - _value
677:                  *
678:                  * Returns:         None
679:                  *
680:                  * Example:         mPMPSlaveWrite(0x20);
681:                  *
682:                  * Remarks:            
683:                 					Writes argument #1 into PMDOUT register.
684:                  *
685:                  *					Note 1: This function does not check the status of the
686:                  *					PMSTAT.OBE (output buffer empty) bit prior to writing to the
687:                  *					PMDOUT register.  It is recommended that the user's software
688:                  *					verify PMSTAT.OBE = 1 prior to writing the PMDOUT register.
689:                  *
690:                  *					Use in SLAVE LEGACY mode, MODE[1:0] = 00
691:                  *****************************************************************************/
692:                 #define mPMPSlaveWrite(_value)              (PMDOUT = (unsigned char) (_value))
693:                 
694:                 
695:                 /******************************************************************************
696:                  * Parallel Master Port Slave mode general purpose macros
697:                  *
698:                  * Macros:
699:                  *          To read Slave Output Buffer Empty Flags
700:                  *                  mIsPMPSlaveBufferEmpty(void)
701:                  *                  mPMPGetBufferEmptyFlags((enum BUFFER) _buffer)
702:                  *
703:                  *          To read Slave Input Buffer Full Flags
704:                  *                  mIsPMPSlaveBufferFull(void)
705:                  *                  mPMPGetBufferFullFlags((enum BUFFER) _buffer)
706:                  *
707:                  *          To read/clear Slave Output Buffer Underflow Flags
708:                  *                  mIsPMPSlaveBufferUnderflow(void)
709:                  *                  mPMPClearBufferUnderflow(void)
710:                  *
711:                  *          To read/clear Slave Input Buffer Overflow Flags
712:                  *                  mIsPMPSlaveBufferOverflow(void)
713:                  *                  mPMPClearBufferOverflow(void)
714:                  *
715:                  * PreCondition:    None
716:                  *
717:                  * Parameters:      Depends
718:                  *
719:                  * Returns:          None
720:                  *
721:                  * Example:         mPMPClearBufferOverflowFlag();
722:                  *
723:                  *                  Use in SLAVE BUFFERED mode, MODE[1:0] = 00 and INCM[1:0]=11
724:                  *					or SLAVE ENHANCED mode, MODE[1:0] = 01
725:                  *****************************************************************************/
726:                 #define	mIsPMPSlaveBufferFull()                 (PMSTATbits.IBF)
727:                 #define mPMPGetBufferFullFlags(_buffer)         ((PMSTAT & (1 << ((BUFFER) (_buffer) + 8)))\
728:                 												>> ((BUFFER) (_buffer) + 8))
729:                 #define mIsPMPSlaveBufferOverflow()				(PMSTATbits.IBOV)
730:                 #define mPMPClearBufferOverflow()			    (PMSTATCLR = _PMSTAT_IBOV_MASK)
731:                 
732:                 #define	mIsPMPSlaveBufferEmpty()                (PMSTATbits.OBE)
733:                 #define mPMPGetBufferEmptyFlags(_buffer)        ((PMSTAT & (1 << (BUFFER )(_buffer)))\
734:                 												>> (BUFFER) (_buffer))
735:                 #define mIsPMPSlaveBufferUnderflow()			(PMSTATbits.OBUF)
736:                 #define	mPMPClearBufferUnderflow()		    	(PMSTATCLR = _PMSTAT_OBUF_MASK)
737:                 
738:                 #endif
739:                 // END OF PMP.H
740:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000720  27BDFFF8   ADDIU SP, SP, -8
9D000724  AFBE0004   SW FP, 4(SP)
9D000728  03A0F025   OR FP, SP, ZERO
9D00072C  AFC40008   SW A0, 8(FP)
9D000730  00000000   NOP
9D000734  3C02BF80   LUI V0, -16512
9D000738  8C427010   LW V0, 28688(V0)
9D00073C  7C4203C0   EXT V0, V0, 15, 1
9D000740  304200FF   ANDI V0, V0, 255
9D000744  1440FFFB   BNE V0, ZERO, 0x9D000734
9D000748  00000000   NOP
9D00074C  3C02BF80   LUI V0, -16512
9D000750  8FC30008   LW V1, 8(FP)
9D000754  AC437020   SW V1, 28704(V0)
9D000758  00000000   NOP
9D00075C  03C0E825   OR SP, FP, ZERO
9D000760  8FBE0004   LW FP, 4(SP)
9D000764  27BD0008   ADDIU SP, SP, 8
9D000768  03E00008   JR RA
9D00076C  00000000   NOP
9D000770  27BDFFF8   ADDIU SP, SP, -8
9D000774  AFBE0004   SW FP, 4(SP)
9D000778  03A0F025   OR FP, SP, ZERO
9D00077C  00000000   NOP
9D000780  3C02BF80   LUI V0, -16512
9D000784  8C427010   LW V0, 28688(V0)
9D000788  7C4203C0   EXT V0, V0, 15, 1
9D00078C  304200FF   ANDI V0, V0, 255
9D000790  1440FFFB   BNE V0, ZERO, 0x9D000780
9D000794  00000000   NOP
9D000798  3C02BF80   LUI V0, -16512
9D00079C  8C427040   LW V0, 28736(V0)
9D0007A0  03C0E825   OR SP, FP, ZERO
9D0007A4  8FBE0004   LW FP, 4(SP)
9D0007A8  27BD0008   ADDIU SP, SP, 8
9D0007AC  03E00008   JR RA
9D0007B0  00000000   NOP
9D0007B4  27BDFFF8   ADDIU SP, SP, -8
9D0007B8  AFBE0004   SW FP, 4(SP)
9D0007BC  03A0F025   OR FP, SP, ZERO
9D0007C0  00801025   OR V0, A0, ZERO
9D0007C4  A7C20008   SH V0, 8(FP)
9D0007C8  00000000   NOP
9D0007CC  3C02BF80   LUI V0, -16512
9D0007D0  8C427010   LW V0, 28688(V0)
9D0007D4  7C4203C0   EXT V0, V0, 15, 1
9D0007D8  304200FF   ANDI V0, V0, 255
9D0007DC  1440FFFB   BNE V0, ZERO, 0x9D0007CC
9D0007E0  00000000   NOP
9D0007E4  97C30008   LHU V1, 8(FP)
9D0007E8  3C02BF80   LUI V0, -16512
9D0007EC  AC437040   SW V1, 28736(V0)
9D0007F0  00000000   NOP
9D0007F4  03C0E825   OR SP, FP, ZERO
9D0007F8  8FBE0004   LW FP, 4(SP)
9D0007FC  27BD0008   ADDIU SP, SP, 8
9D000800  03E00008   JR RA
9D000804  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/osc.h  ---------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the “Company”) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company’s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                   // Reference Oscillator Source Select bits - values are mutually exclusive
169:                   #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                   #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                   #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                   #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                   #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                   #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                   #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                   #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                   #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                   typedef enum
180:                   {
181:                       OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                       OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                       OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                       OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                   } OSCREFConfigFlags;
186:                 
187:                   void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                   #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
190:                 
191:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
192:                 
193:                 #undef  NEED_OSCREFCONFIG_FLAGS
194:                 
195:                 
196:                 /*********************************************************************
197:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
198:                  *
199:                  * Description: Configures peripheral bus divisor
200:                  *
201:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
202:                  *
203:                  * Inputs:    oscPbDiv - desired PB divider
204:                  *
205:                  * Output:      None
206:                  *
207:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
208:                  *
209:                  ********************************************************************/
210:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
211:                 {
212:                     unsigned int dma_status;
213:                     unsigned int int_status;
214:                     __OSCCONbits_t oscBits;
215:                 
216:                     mSYSTEMUnlock(int_status, dma_status);
217:                 
218:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
219:                     oscBits.PBDIV=0;
220:                     oscBits.w|=oscPbDiv;
221:                     OSCCON=oscBits.w;       // write back
222:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
223:                 
224:                     mSYSTEMLock(int_status, dma_status);
225:                 }
226:                 
227:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
228:                 
229:                 
230:                 
231:                     /******************************************************************************
232:                      * Available options for config parameter
233:                      *****************************************************************************/
234:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
235:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
236:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
239:                     /***********************************
240:                      * End config parameter values
241:                      ************************************/
242:                 
243:                 
244:                 /*********************************************************************
245:                  * Function:    mOSCGetPBDIV()
246:                  *
247:                  * Description: Reads peripheral bus divisor
248:                  *
249:                  * PreCondition:None
250:                  *
251:                  * Inputs:      None
252:                  *
253:                  * Output:      None
254:                  *
255:                  * Example:     mOSCGetPBDIV()
256:                  *
257:                  ********************************************************************/
258:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
259:                 
260:                 
261:                 /*********************************************************************
262:                  * Function:    mOSCClockFailStatus()
263:                  *
264:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
265:                  *
266:                  * PreCondition: None
267:                  *
268:                  * Inputs:      None
269:                  *
270:                  * Output:      None
271:                  *
272:                  * Example:     mOSCClockFailStatus()
273:                  *
274:                  ********************************************************************/
275:                 #define mOSCClockFailStatus (OSCCONbits.CF)
276:                 
277:                 
278:                 /*********************************************************************
279:                  * Function:        mOSCEnableSOSC()
280:                  *
281:                  * Description:     Enables the LPRC
282:                  *
283:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
284:                  *
285:                  * Inputs:          None
286:                  *
287:                  * Output:          None
288:                  *
289:                  * Example:         mOSCEnableSOSC()
290:                  *
291:                  ********************************************************************/
292:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
293:                 
294:                 
295:                 /*********************************************************************
296:                  * Function:        mOSCDisableSOSC(config)
297:                  *
298:                  * Description:     Disables SOSC
299:                  *
300:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
301:                  *
302:                  * Inputs:          None
303:                  *
304:                  * Output:          None
305:                  *
306:                  * Example:         mOSCDisableSOSC()
307:                  *
308:                  ********************************************************************/
309:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
310:                 
311:                 
312:                 
313:                 #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000F84  27BDFFD0   ADDIU SP, SP, -48
9D000F88  AFBF002C   SW RA, 44(SP)
9D000F8C  AFBE0028   SW FP, 40(SP)
9D000F90  03A0F025   OR FP, SP, ZERO
9D000F94  AFC40030   SW A0, 48(FP)
9D000F98  0F400A0B   JAL INTDisableInterrupts
9D000F9C  00000000   NOP
9D000FA0  AFC20010   SW V0, 16(FP)
9D000FEC  AFC20014   SW V0, 20(FP)
9D000FF0  3C02BF81   LUI V0, -16511
9D000FF4  AC40F230   SW ZERO, -3536(V0)
9D000FF8  3C02BF81   LUI V0, -16511
9D000FFC  3C03AA99   LUI V1, -21863
9D001000  34636655   ORI V1, V1, 26197
9D001004  AC43F230   SW V1, -3536(V0)
9D001008  3C02BF81   LUI V0, -16511
9D00100C  3C035566   LUI V1, 21862
9D001010  346399AA   ORI V1, V1, -26198
9D001014  AC43F230   SW V1, -3536(V0)
9D001018  3C02BF81   LUI V0, -16511
9D00101C  8C42F000   LW V0, -4096(V0)
9D001020  AFC20024   SW V0, 36(FP)
9D001024  8FC20024   LW V0, 36(FP)
9D001028  7C02A4C4   INS V0, ZERO, 19, 2
9D00102C  AFC20024   SW V0, 36(FP)
9D001030  8FC30024   LW V1, 36(FP)
9D001034  8FC20030   LW V0, 48(FP)
9D001038  00621025   OR V0, V1, V0
9D00103C  AFC20024   SW V0, 36(FP)
9D001040  8FC30024   LW V1, 36(FP)
9D001044  3C02BF81   LUI V0, -16511
9D001048  AC43F000   SW V1, -4096(V0)
9D00104C  3C02BF81   LUI V0, -16511
9D001050  8C42F000   LW V0, -4096(V0)
9D001054  AFC20024   SW V0, 36(FP)
9D001058  3C02BF81   LUI V0, -16511
9D00105C  3C033333   LUI V1, 13107
9D001060  34633333   ORI V1, V1, 13107
9D001064  AC43F230   SW V1, -3536(V0)
9D001068  8FC20014   LW V0, 20(FP)
9D00106C  AFC20018   SW V0, 24(FP)
9D0010D4  8FC40010   LW A0, 16(FP)
9D0010D8  0F4009E5   JAL INTRestoreInterrupts
9D0010DC  00000000   NOP
9D0010E0  00000000   NOP
9D0010E4  03C0E825   OR SP, FP, ZERO
9D0010E8  8FBF002C   LW RA, 44(SP)
9D0010EC  8FBE0028   LW FP, 40(SP)
9D0010F0  27BD0030   ADDIU SP, SP, 48
9D0010F4  03E00008   JR RA
9D0010F8  00000000   NOP
9D001158  0F400A0B   JAL INTDisableInterrupts
9D0011AC  AFC20024   SW V0, 36(FP)
9D0011D8  3C02BF81   LUI V0, -16511
9D0011E4  8FC20030   LW V0, 48(FP)
9D0011F0  8FC30030   LW V1, 48(FP)
9D001200  8FC30030   LW V1, 48(FP)
9D001204  3C02BF81   LUI V0, -16511
9D00120C  3C02BF81   LUI V0, -16511
9D001218  3C02BF81   LUI V0, -16511
9D001294  8FC4001C   LW A0, 28(FP)
9D0013B8  0F400A0B   JAL INTDisableInterrupts
9D00140C  AFC20034   SW V0, 52(FP)
9D001438  3C02BF81   LUI V0, -16511
9D001444  8FC20040   LW V0, 64(FP)
9D001450  8FC30040   LW V1, 64(FP)
9D001460  8FC30040   LW V1, 64(FP)
9D001464  3C02BF81   LUI V0, -16511
9D00146C  3C02BF81   LUI V0, -16511
9D001478  3C02BF81   LUI V0, -16511
9D0014F4  8FC4002C   LW A0, 44(FP)
9D0015F8  0F400A0B   JAL INTDisableInterrupts
9D00164C  AFC20038   SW V0, 56(FP)
9D001678  3C02BF81   LUI V0, -16511
9D001684  8FC20050   LW V0, 80(FP)
9D001690  8FC30050   LW V1, 80(FP)
9D0016A0  8FC30050   LW V1, 80(FP)
9D0016A4  3C02BF81   LUI V0, -16511
9D0016AC  3C02BF81   LUI V0, -16511
9D0016B8  3C02BF81   LUI V0, -16511
9D001734  8FC40030   LW A0, 48(FP)
9D001934  0F400A0B   JAL INTDisableInterrupts
9D001988  AFC20040   SW V0, 64(FP)
9D0019B4  3C02BF81   LUI V0, -16511
9D0019C0  8FC2004C   LW V0, 76(FP)
9D0019CC  8FC3004C   LW V1, 76(FP)
9D0019DC  8FC3004C   LW V1, 76(FP)
9D0019E0  3C02BF81   LUI V0, -16511
9D0019E8  3C02BF81   LUI V0, -16511
9D0019F4  3C02BF81   LUI V0, -16511
9D001A70  8FC40038   LW A0, 56(FP)
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/int.h  ---------------------
1:                   /********************************************************************
2:                    * FileName:        int.h
3:                    * Dependencies:
4:                    * Processor:       PIC32MX
5:                    * Hardware:        N/A
6:                    * Assembler:       N/A
7:                    * Linker:          N/A
8:                    * Company:         Microchip Technology Inc.
9:                    *
10:                   * Software License Agreement:
11:                   * The software supplied herewith by Microchip Technology Incorporated
12:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
13:                   * supplied to you, the Company’s customer, for use solely and
14:                   * exclusively on Microchip PICmicro Microcontroller products. The
15:                   * software is owned by the Company and/or its supplier, and is
16:                   * protected under applicable copyright laws. All rights are reserved.
17:                   * Any use in violation of the foregoing restrictions may subject the
18:                   * user to criminal sanctions under applicable laws, as well as to
19:                   * civil liability for the breach of the terms and conditions of this
20:                   * license.
21:                   *
22:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
23:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
24:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
25:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
26:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
27:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
28:                   *
29:                   * $Id: INT.h,v 1.6 2006/11/07 23:29:45 C12923 Exp $
30:                   * $Name:  $
31:                  
32:                   ********************************************************************/
33:                  
34:                  #ifndef _PIC32INT_HEADER_FILE
35:                  #define _PIC32INT_HEADER_FILE
36:                  
37:                  #ifdef __cplusplus
38:                  extern "C"
39:                    {
40:                  #endif
41:                  
42:                  /*
43:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
44:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
45:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
46:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
47:                  */
48:                  #ifndef _SUPPRESS_PLIB_WARNING
49:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
50:                  #endif
51:                  
52:                  
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  // Section: Includes
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  #include <xc.h>
59:                  #include <../sys/attribs.h>
60:                  
61:                  #if defined(__32MX120F064H__) || \
62:                      defined(__32MX130F128H__) || \
63:                      defined(__32MX130F128L__) || \
64:                      defined(__32MX150F256H__) || \
65:                      defined(__32MX150F256L__) || \
66:                      defined(__32MX170F512H__) || \
67:                      defined(__32MX170F512L__) || \
68:                      defined(__32MX230F128H__) || \
69:                      defined(__32MX230F128L__) || \
70:                      defined(__32MX250F256H__) || \
71:                      defined(__32MX250F256L__) || \
72:                      defined(__32MX270F512H__) || \
73:                      defined(__32MX270F512L__) || \
74:                      defined(__32MX530F128H__) || \
75:                      defined(__32MX530F128L__) || \
76:                      defined(__32MX550F256H__) || \
77:                      defined(__32MX550F256L__) || \
78:                      defined(__32MX570F512H__) || \
79:                      defined(__32MX570F512L__)
80:                    #error "Device not supported by legacy interrupt PLIB!"
81:                  #elif (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || defined(__32MXGENERIC__))
82:                    #include <peripheral/int_1xx_2xx.h>
83:                  #elif  ((__PIC32_FEATURE_SET__ >= 300) && (__PIC32_FEATURE_SET__ <= 499))
84:                    #include <../peripheral/int_3xx_4xx.h>
85:                  #elif (((__PIC32_FEATURE_SET__ >= 500) && (__PIC32_FEATURE_SET__ <= 799)) || defined (__32MXPOCONO__))
86:                    #include <peripheral/int_5xx_6xx_7xx.h>
87:                  #else
88:                    #error "Device not supported by the interrupt peripheral library"
89:                  #endif
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Legacy Includes
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  #ifndef _PLIB_DISABLE_LEGACY
96:                  #include <peripheral/legacy/int_legacy.h>
97:                  #endif
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 // Section: Constants & Data Types
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 
104:                 // *****************************************************************************
105:                 /* Interrupt Single Vector Shadow Set
106:                 
107:                   Summary:
108:                     Single vector shadow set selector.
109:                 
110:                   Description:
111:                     These definitions can be used enable the use of the shadow set when
112:                     in single vector mode.
113:                 */
114:                 typedef enum
115:                 {
116:                     // Use the the CPU's register set when entering the handler.
117:                     INT_REGISTOR_SET_SELECT_NONE /*DOM-IGNORE-BEGIN*/ = 0 /*DOM-IGNORE-END*/,
118:                     // Use the shadow set when entering the handler
119:                     INT_REGISTOR_SET_SELECT_SS0  /*DOM-IGNORE-BEGIN*/ = (_INTCON_SS0_MASK) /*DOM-IGNORE-END*/
120:                 
121:                 }INT_SV_SS;
122:                 
123:                 // *****************************************************************************
124:                 /* Interrupt Vector Priority
125:                 
126:                   Summary:
127:                     Interrupt vector priority definitions.
128:                 
129:                   Description:
130:                     These definitions can be used to set the priority of an interrupt
131:                     vector.
132:                 */
133:                 typedef enum
134:                 {
135:                     // Interrupt vector priority level of 0, interrupt is disabled.
136:                     INT_PRIORITY_DISABLED /*DOM-IGNORE-BEGIN*/=      0 /*DOM-IGNORE-END*/,
137:                     // Interrupt vector priority level of 1.
138:                     INT_PRIORITY_LEVEL_1  /*DOM-IGNORE-BEGIN*/=      1 /*DOM-IGNORE-END*/,
139:                     // Interrupt vector priority level of 2.
140:                     INT_PRIORITY_LEVEL_2  /*DOM-IGNORE-BEGIN*/=      2 /*DOM-IGNORE-END*/,
141:                     // Interrupt vector priority level of 3.
142:                     INT_PRIORITY_LEVEL_3  /*DOM-IGNORE-BEGIN*/=      3 /*DOM-IGNORE-END*/,
143:                     // Interrupt vector priority level of 4.
144:                     INT_PRIORITY_LEVEL_4  /*DOM-IGNORE-BEGIN*/=      4 /*DOM-IGNORE-END*/,
145:                     // Interrupt vector priority level of 5.
146:                     INT_PRIORITY_LEVEL_5  /*DOM-IGNORE-BEGIN*/=      5 /*DOM-IGNORE-END*/,
147:                     // Interrupt vector priority level of 6.
148:                     INT_PRIORITY_LEVEL_6  /*DOM-IGNORE-BEGIN*/=      6 /*DOM-IGNORE-END*/,
149:                     // Interrupt vector priority level of 7.
150:                     INT_PRIORITY_LEVEL_7  /*DOM-IGNORE-BEGIN*/=      7  /*DOM-IGNORE-END*/
151:                 }INT_PRIORITY;
152:                 
153:                 // *****************************************************************************
154:                 /* Interrupt Vector Sub-priority
155:                 
156:                   Summary:
157:                     Interrupt vector sub-priority definitions.
158:                 
159:                   Description:
160:                     These definitions can be used to set the sub-priority of an interrupt
161:                     vector.
162:                 */
163:                 typedef enum
164:                 {
165:                     // Interrupt vector sub-priority level of 0.
166:                     INT_SUB_PRIORITY_LEVEL_0 /*DOM-IGNORE-BEGIN*/=   0 /*DOM-IGNORE-END*/,
167:                     // Interrupt vector sub-priority level of 1.
168:                     INT_SUB_PRIORITY_LEVEL_1 /*DOM-IGNORE-BEGIN*/=   1 /*DOM-IGNORE-END*/,
169:                     // Interrupt vector sub-priority level of 2.
170:                     INT_SUB_PRIORITY_LEVEL_2 /*DOM-IGNORE-BEGIN*/=   2 /*DOM-IGNORE-END*/,
171:                     // Interrupt vector sub-priority level of 3.
172:                     INT_SUB_PRIORITY_LEVEL_3 /*DOM-IGNORE-BEGIN*/=   3 /*DOM-IGNORE-END*/
173:                 }INT_SUB_PRIORITY;
174:                 
175:                 // *****************************************************************************
176:                 /* Interrupt Enable/Disable
177:                 
178:                   Summary:
179:                     Interrupt enable/disable definitions.
180:                 
181:                   Description:
182:                     These definitions can be used to enable or disable an interrupt.
183:                 */
184:                 typedef enum
185:                 {
186:                     // Disables the interrupt.
187:                     INT_DISABLED /*DOM-IGNORE-BEGIN*/ = 0 /*DOM-IGNORE-END*/,
188:                     // Enables the interrupt.
189:                     INT_ENABLED /*DOM-IGNORE-BEGIN*/  = 1 /*DOM-IGNORE-END*/
190:                 }INT_EN_DIS;
191:                 // *****************************************************************************
192:                 /* Interrupt Temporal Proximity Control
193:                 
194:                   Summary:
195:                     Interrupt Temporal Proximity Control definitions.
196:                 
197:                   Description:
198:                     These definitions can be used to set the interrupt priority of the Interrupt Temporal Proximity Timer.
199:                 */
200:                 typedef enum
201:                 {
202:                     // Temporal Proximity Timer disabled.
203:                     INT_TPC_DISABLE            /*DOM-IGNORE-BEGIN*/=      0x00000700 /*DOM-IGNORE-END*/,
204:                     // Temporal Proximity Timer enable for interupt priority level 1.
205:                     INT_TPC_GROUP_PRI_LEVEL_1  /*DOM-IGNORE-BEGIN*/=      1 /*DOM-IGNORE-END*/,
206:                     // Temporal Proximity Timer enable for interupt priority level 2 and below.
207:                     INT_TPC_GROUP_PRI_LEVEL_2  /*DOM-IGNORE-BEGIN*/=      2 /*DOM-IGNORE-END*/,
208:                     // Temporal Proximity Timer enable for interupt priority level 3 and below.
209:                     INT_TPC_GROUP_PRI_LEVEL_3  /*DOM-IGNORE-BEGIN*/=      3 /*DOM-IGNORE-END*/,
210:                     // Temporal Proximity Timer enable for interupt priority level 4 and below.
211:                     INT_TPC_GROUP_PRI_LEVEL_4  /*DOM-IGNORE-BEGIN*/=      4 /*DOM-IGNORE-END*/,
212:                     // Temporal Proximity Timer enable for interupt priority level 5 and below.
213:                     INT_TPC_GROUP_PRI_LEVEL_5  /*DOM-IGNORE-BEGIN*/=      5 /*DOM-IGNORE-END*/,
214:                     // Temporal Proximity Timer enable for interupt priority level 6 and below.
215:                     INT_TPC_GROUP_PRI_LEVEL_6  /*DOM-IGNORE-BEGIN*/=      6 /*DOM-IGNORE-END*/,
216:                     // Temporal Proximity Timer enable for interupt priority level 7 and below.
217:                     INT_TPC_GROUP_PRI_LEVEL_7  /*DOM-IGNORE-BEGIN*/=      7 /*DOM-IGNORE-END*/
218:                 }INT_TPC_GROUP;
219:                 
220:                 // *****************************************************************************
221:                 /* Interrupt Vector Spacing
222:                 
223:                   Summary:
224:                     Interrupt vector spacing definitions.
225:                 
226:                   Description:
227:                     These definitions can be used to set the core's EBASE vector spacing.
228:                 */
229:                 typedef enum
230:                 {
231:                     // Vector spacing of 32 bytes.
232:                     INT_VS_32  /*DOM-IGNORE-BEGIN*/= 32 /*DOM-IGNORE-END*/,
233:                     // Vector spacing of 64 bytes.
234:                     INT_VS_64  /*DOM-IGNORE-BEGIN*/= 64 /*DOM-IGNORE-END*/,
235:                     // Vector spacing of 128 bytes.
236:                     INT_VS_128  /*DOM-IGNORE-BEGIN*/= 128 /*DOM-IGNORE-END*/,
237:                     // Vector spacing of 256 bytes.
238:                     INT_VS_256  /*DOM-IGNORE-BEGIN*/= 256 /*DOM-IGNORE-END*/,
239:                     // Vector spacing of 512 bytes.
240:                     INT_VS_512  /*DOM-IGNORE-BEGIN*/= 512 /*DOM-IGNORE-END*/
241:                 }INT_VS;
242:                 
243:                 // *****************************************************************************
244:                 /* Interrupt Configuration
245:                 
246:                   Summary:
247:                     Interrupt configuration parameters.
248:                 
249:                   Description:
250:                     These definitions can be used to configure the system interrupt controller.
251:                 */
252:                 typedef enum
253:                 {
254:                     // Configure the interrupt module for Mult-vector mode.
255:                     INT_SYSTEM_CONFIG_MULT_VECTOR,
256:                     // Configure the interrupt module for Single Vectored mode.
257:                     INT_SYSTEM_CONFIG_SINGLE_VECTOR
258:                 }INT_SYSTEM_CONFIG;
259:                 
260:                 // *****************************************************************************
261:                 // *****************************************************************************
262:                 // Section: Interrupt Peripheral Library Interface Routines and Macors
263:                 // *****************************************************************************
264:                 // *****************************************************************************
265:                 
266:                 /*******************************************************************************
267:                   Function:
268:                     unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
269:                 
270:                   Summary:
271:                     Disables the PIC32MX from handling interrupts.
272:                 
273:                   Description:
274:                     This routine disables the core from handling any pending interrupt requests.
275:                 
276:                   Precondition:
277:                     None
278:                 
279:                   Parameters:
280:                     None
281:                 
282:                   Returns:
283:                     The previous state of the CP0 register Status.IE bit.  The INTRestoreInterrupts
284:                     function can be used in other routines to restore the system interrupt state.
285:                 
286:                   Example:
287:                     <code>
288:                     unsigned int intStatus;
289:                 
290:                     intStatus = INTDisableInterrupts();
291:                     </code>
292:                 
293:                   Remarks:
294:                     This function cannot be compiled using the MIPS16 instruction set.
295:                   *****************************************************************************/
296:                 unsigned int __attribute__((nomips16)) INTDisableInterrupts(void);
297:                 
298:                 /*******************************************************************************
299:                   Function:
300:                     unsigned int __attribute__((nomips16))  INTEnableInterrupts(void)
301:                 
302:                   Summary:
303:                     Enables the PIC32MX to handle interrupts.
304:                 
305:                   Description:
306:                     This routine enables the core to handle any pending interrupt requests.
307:                 
308:                   Precondition:
309:                     Need to configure system using INTConfigureSystem
310:                 
311:                   Parameters:
312:                     None
313:                 
314:                   Returns:
315:                     The previous state of the CP0 register Status.IE bit.  The INTRestoreInterrupts
316:                     function can be used in other routines to restore the system interrupt state.
317:                 
318:                   Example:
319:                     <code>
320:                     unsigned int intStatus;
321:                 
322:                     intStatus = INTEnableInterrupts();
323:                     </code>
324:                 
325:                   Remarks:
326:                     This function cannot be compiled using the MIPS16 instruction set.
327:                   *****************************************************************************/
328:                 unsigned int __attribute__((nomips16))  INTEnableInterrupts(void);
329:                 
330:                 /*******************************************************************************
331:                   Function:
332:                     void __attribute__((nomips16))  INTRestoreInterrupts(unsigned int status)
333:                 
334:                   Summary:
335:                     Restores the PIC32MX interrupt state.
336:                 
337:                   Description:
338:                     This routine restores the core to the previous interrupt handling state.
339:                 
340:                   Precondition:
341:                     None
342:                 
343:                   Parameters:
344:                     status      - the state of the CP0 register Status.IE
345:                 
346:                   Returns:
347:                     None
348:                 
349:                   Example:
350:                     <code>
351:                     unsigned int intStatus;
352:                 
353:                     intStatus = INTDisableInterrupts();
354:                 
355:                     // ... application code
356:                 
357:                     INTRestoreInterrupts(intStatus);
358:                     </code>
359:                 
360:                   Remarks:
361:                     This function cannot be compiled using the MIPS16 instruction set.
362:                   *****************************************************************************/
363:                 void __attribute__((nomips16))  INTRestoreInterrupts(unsigned int status);
364:                 
365:                 /*******************************************************************************
366:                   Function:
367:                     void __attribute__ ((nomips16)) INTConfigureSystem(INT_SYSTEM_CONFIG config);
368:                 
369:                   Summary:
370:                     Configures the system for  multi-vector or single vectored interrupts.
371:                 
372:                   Description:
373:                     This routine configures the core to receive interrupt requests and configures the
374:                     Interrupt module for Multi-vectored or Single Vectored mode.
375:                 
376:                   Precondition:
377:                     None
378:                 
379:                   Parameters:
380:                     config      - The interrupt configuration to set.
381:                 
382:                   Returns:
383:                     None
384:                 
385:                   Example:
386:                     Configure for Multi-vectored mode
387:                     <code>
388:                 
389:                     // configure for multi-vectored mode
390:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
391:                 
392:                     // enable interrupts
393:                     INTEnableInterrupts();
394:                 
395:                     // ...
396:                     </code>
397:                 
398:                     Configure for Single Vectored mode
399:                     <code>
400:                 
401:                     // configure for single vectored mode
402:                     INTConfigureSystem(INT_SYSTEM_CONFIG_SINGLE_VECTOR);
403:                 
404:                     // enable interrupts
405:                     INTEnableInterrupts();
406:                 
407:                     // ...
408:                     </code>
409:                 
410:                   Remarks:
411:                     This function cannot be compiled using the MIPS16 instruction set.
412:                   *****************************************************************************/
413:                 void __attribute__ ((nomips16)) INTConfigureSystem(INT_SYSTEM_CONFIG config);
414:                 
415:                 /*******************************************************************************
416:                   Function:
417:                     void __attribute__((nomips16)) INTSetEBASE(unsigned int ebase_address)
418:                 
419:                   Summary:
420:                     Sets the PIC32MX exception base.
421:                 
422:                   Description:
423:                     This routine sets the exception base of the core.
424:                 
425:                   Precondition:
426:                     None
427:                 
428:                   Parameters:
429:                     ebase_address   - The address of the EBASE.
430:                                     * must be be located in KSEG0 or KSEG1
431:                                     * must be 4KB aligned
432:                 
433:                   Returns:
434:                     None
435:                 
436:                   Example:
437:                     <code>
438:                 
439:                     INTSetEBASE(0xBFC01000);
440:                     </code>
441:                 
442:                   Remarks:
443:                     This function cannot be compiled using the MIPS16 instruction set.
444:                   *****************************************************************************/
445:                 void __attribute__((nomips16)) INTSetEBASE(unsigned int ebase_address);
446:                 
447:                 /*******************************************************************************
448:                   Function:
449:                     void __attribute__((nomips16)) INTSetVectorSpacing(INT_VS vector_spacing)
450:                 
451:                   Summary:
452:                     Sets the PIC32MX exception vector spacing.
453:                 
454:                   Description:
455:                     This routine sets the exception vector spacing of the core.
456:                 
457:                   Precondition:
458:                     None
459:                 
460:                   Parameters:
461:                     vector_spacing  - The desired vector spacing.
462:                 
463:                   Returns:
464:                     None
465:                 
466:                   Example:
467:                     <code>
468:                 
469:                     INTSetVectorSpacing(INT_VS_32);
470:                     </code>
471:                 
472:                   Remarks:
473:                     This function cannot be compiled using the MIPS16 instruction set.
474:                   *****************************************************************************/
475:                 void __attribute__((nomips16)) INTSetVectorSpacing(INT_VS vector_spacing);
476:                 
477:                 /*******************************************************************************
478:                   Function:
479:                     extern inline void __attribute__ ((always_inline)) INTSingleVectorRegisterSet(INT_SV_SS reg_set)
480:                 
481:                   Summary:
482:                     Sets the single vectored interrupt handler's general purpose register set.
483:                 
484:                   Description:
485:                     This routine sets the single vectored interrupt handler's general purpose register set.
486:                 
487:                   Precondition:
488:                     The interrupt controller must be set in Single Vectored mode.
489:                 
490:                   Parameters:
491:                     reg_set         - Register set for the single vectored handler.
492:                 
493:                   Returns:
494:                     None
495:                 
496:                   Example:
497:                     <code>
498:                 
499:                     INTSingleVectorRegisterSet(INT_REGISTOR_SET_SELECT_NONE);
500:                     </code>
501:                 
502:                   Remarks:
503:                     None.
504:                   *****************************************************************************/
505:                 extern inline void __attribute__ ((always_inline)) INTSingleVectorRegisterSet(INT_SV_SS reg_set)
506:                 {
507:                     INTCONCLR   = reg_set;
508:                     INTCONSET    = reg_set;
509:                 }
510:                 
511:                 /*******************************************************************************
512:                   Function:
513:                     extern inline unsigned int __attribute__ ((always_inline)) INTGetInterruptVectorNumber(void)
514:                 
515:                   Summary:
516:                     Gets the pending interrupt vector.
517:                 
518:                   Description:
519:                     This routine gets the pending interrupt vector number.
520:                 
521:                   Precondition:
522:                     None
523:                 
524:                   Parameters:
525:                     None
526:                 
527:                   Returns:
528:                     The pending interrupt vector number.
529:                 
530:                   Example:
531:                     <code>
532:                     unsigned int vector_num;
533:                 
534:                     vector_num = INTGetInterruptVectorNumber();
535:                 
536:                     if(vector_num == _CORE_TIMER_VECTOR)
537:                     {
538:                         // ...
539:                     }
540:                     </code>
541:                 
542:                   Remarks:
543:                     The user can refer to the device file to get the vector number defines.
544:                   *****************************************************************************/
545:                 extern inline unsigned int __attribute__ ((always_inline)) INTGetInterruptVectorNumber(void)
546:                 {
547:                     return (unsigned int)(INTSTATbits.VEC);
548:                 }
549:                 /*******************************************************************************
550:                   Function:
551:                     extern inline INT_PRIORITY __attribute__ ((always_inline)) INTGetInterruptVectorPriority(void)
552:                 
553:                   Summary:
554:                     Gets the pending interrupt vector's priority.
555:                 
556:                   Description:
557:                     This routine gets the pending interrupt vector's priority.
558:                 
559:                   Precondition:
560:                     None
561:                 
562:                   Parameters:
563:                     None
564:                 
565:                   Returns:
566:                     The pending interrupt vector's priority.
567:                 
568:                   Example:
569:                     <code>
570:                     INT_PRIORITY vector_pri;
571:                 
572:                     vector_pri = INTGetInterruptVectorPriority();
573:                     </code>
574:                 
575:                   Remarks:
576:                     None.
577:                   *****************************************************************************/
578:                 extern inline INT_PRIORITY __attribute__ ((always_inline)) INTGetInterruptVectorPriority(void)
579:                 {
580:                     return (INT_PRIORITY)(INTSTATbits.SRIPL);
581:                 }
582:                 
583:                 /*******************************************************************************
584:                   Function:
585:                     extern inline void __attribute__ ((always_inline)) INTGetInterruptVectorNumberAndPriority(unsigned int *number, INT_PRIORITY *priority)
586:                 
587:                   Summary:
588:                     Gets the pending interrupt vector number and priority.
589:                 
590:                   Description:
591:                     This routine gets the pending interrupt vector number and priority.
592:                 
593:                   Precondition:
594:                     *number - pointer to the vector number
595:                 
596:                     *priority - pointer to the interrupt priority
597:                 
598:                   Parameters:
599:                     None
600:                 
601:                   Returns:
602:                     The pending interrupt vector's priority.
603:                 
604:                   Example:
605:                     <code>
606:                     INT_PRIORITY vector_pri;
607:                     unsigned int vector_num;
608:                 
609:                     INTGetInterruptVectorNumberAndPriority(&vector_num, &vector_pri);
610:                 
611:                     if(vector_num == _CORE_TIMER_VECTOR)
612:                     {
613:                         // ...
614:                     }
615:                     </code>
616:                 
617:                   Remarks:
618:                     None.
619:                   *****************************************************************************/
620:                 extern inline void __attribute__ ((always_inline)) INTGetInterruptVectorNumberAndPriority(unsigned int *number, INT_PRIORITY *priority)
621:                 {
622:                     *number     = INTSTAT;
623:                     *priority   = (INT_PRIORITY)((*number >> 8) & 7);
624:                     *number     &= 0x3F;
625:                 }
626:                 
627:                 /*******************************************************************************
628:                   Function:
629:                     void INTClearFlag(INT_SOURCE source)
630:                 
631:                   Summary:
632:                     Clears an interrupt request flag.
633:                 
634:                   Description:
635:                     This routine clears an interrupt request flag.
636:                 
637:                   Precondition:
638:                     None
639:                 
640:                   Parameters:
641:                     source  - Interrupt source.
642:                 
643:                   Returns:
644:                     None
645:                 
646:                   Example:
647:                     <code>
648:                     INTClearFlag(INT_CT);
649:                     </code>
650:                 
651:                   Remarks:
652:                     None
653:                   *****************************************************************************/
654:                 void INTClearFlag(INT_SOURCE source);
655:                 
656:                 /*******************************************************************************
657:                   Function:
658:                     void INTSetFlag(INT_SOURCE source)
659:                 
660:                   Summary:
661:                     Sets an interrupt request flag.
662:                 
663:                   Description:
664:                     This routine sets an interrupt request flag.
665:                 
666:                   Precondition:
667:                     None
668:                 
669:                   Parameters:
670:                     source  - Interrupt source.
671:                 
672:                   Returns:
673:                     None
674:                 
675:                   Example:
676:                     <code>
677:                     INTSetFlag(INT_CT);
678:                     </code>
679:                 
680:                   Remarks:
681:                     If the corresponding interrupt enable is set, this routine will cause the
682:                     application to vector to the interrupt's handler.
683:                   *****************************************************************************/
684:                 void INTSetFlag(INT_SOURCE source);
685:                 
686:                 /*******************************************************************************
687:                   Function:
688:                     unsigned int INTGetFlag(INT_SOURCE source)
689:                 
690:                   Summary:
691:                     Gets the interrupt request flag.
692:                 
693:                   Description:
694:                     This routine gets an interrupt request flag.
695:                 
696:                   Precondition:
697:                     None
698:                 
699:                   Parameters:
700:                     source  - Interrupt source.
701:                 
702:                   Returns:
703:                     * 0 if the interrupt request flag is clear
704:                     * 1 if the interrupt request flag is set
705:                 
706:                   Example:
707:                     <code>
708:                     if(INTGetFlag(INT_CT))
709:                     {
710:                         // ... do something
711:                     }
712:                     </code>
713:                 
714:                   Remarks:
715:                     None
716:                   *****************************************************************************/
717:                 unsigned int INTGetFlag(INT_SOURCE source);
718:                 
719:                 /*******************************************************************************
720:                   Function:
721:                     void INTEnable(INT_SOURCE source, INT_EN_DIS enable)
722:                 
723:                   Summary:
724:                     Enables or disables the interrupt.
725:                 
726:                   Description:
727:                     This routine enables or disables the interrupt source.
728:                 
729:                   Precondition:
730:                     None
731:                 
732:                   Parameters:
733:                     source  - Interrupt source.
734:                     enable  - Enable state to set.
735:                 
736:                   Returns:
737:                     None
738:                 
739:                   Example:
740:                     <code>
741:                     INTEnable(INT_CT, INT_ENABLED);
742:                     </code>
743:                 
744:                   Remarks:
745:                     None
746:                   *****************************************************************************/
747:                 void INTEnable(INT_SOURCE source, INT_EN_DIS enable);
748:                 
749:                 /*******************************************************************************
750:                   Function:
751:                     unsigned int INTGetEnable(INT_SOURCE source)
752:                 
753:                   Summary:
754:                     Gets the interrupt enable.
755:                 
756:                   Description:
757:                     This routine gets an interrupt enable.
758:                 
759:                   Precondition:
760:                     None
761:                 
762:                   Parameters:
763:                     source  - Interrupt source.
764:                 
765:                   Returns:
766:                     * 0 if interrupt is disabled
767:                     * else interrupt is enabled
768:                 
769:                   Example:
770:                     <code>
771:                     if(INTGetEnable(INT_CT))
772:                     {
773:                         // ... do something
774:                     }
775:                     </code>
776:                 
777:                   Remarks:
778:                     None
779:                   *****************************************************************************/
780:                 unsigned int INTGetEnable(INT_SOURCE source);
781:                 
782:                 /*******************************************************************************
783:                   Function:
784:                     void INTSetVectorPriority(INT_VECTOR vector, INT_PRIORITY priority)
785:                 
786:                   Summary:
787:                     Sets the interrupt vector's priority.
788:                 
789:                   Description:
790:                     This routine sets the interrupt vector's priority.
791:                 
792:                   Precondition:
793:                     None
794:                 
795:                   Parameters:
796:                     vector    - Interrupt vector.
797:                     priority  - Interrupt vector's priority.
798:                 
799:                   Returns:
800:                     None
801:                 
802:                   Example:
803:                     <code>
804:                     INTSetVectorPriority(INT_CORE_TIMER_VECTOR, INT_PRIORITY_LEVEL_4);
805:                     </code>
806:                 
807:                   Remarks:
808:                     None
809:                   *****************************************************************************/
810:                 void INTSetVectorPriority(INT_VECTOR vector, INT_PRIORITY priority);
811:                 
812:                 /*******************************************************************************
813:                   Function:
814:                     INT_PRIORITY INTGetVectorPriority(INT_VECTOR vector)
815:                 
816:                   Summary:
817:                     Gets the interrupt vector's priority.
818:                 
819:                   Description:
820:                     This routine gets the interrupt vector's priority.
821:                 
822:                   Precondition:
823:                     None
824:                 
825:                   Parameters:
826:                     vector    - Interrupt vector.
827:                 
828:                   Returns:
829:                     interrupt vector's priority
830:                 
831:                   Example:
832:                     <code>
833:                     INT_PRIORITY intPriority;
834:                 
835:                     intPriority = INTGetVectorPriority(INT_CORE_TIMER_VECTOR);
836:                     </code>
837:                 
838:                   Remarks:
839:                     None
840:                   *****************************************************************************/
841:                 INT_PRIORITY INTGetVectorPriority(INT_VECTOR vector);
842:                 
843:                 /*******************************************************************************
844:                   Function:
845:                     void INTSetVectorSubPriority(INT_VECTOR vector, INT_SUB_PRIORITY subPriority)
846:                 
847:                   Summary:
848:                     Sets the interrupt vector's sub-priority.
849:                 
850:                   Description:
851:                     This routine sets the interrupt vector's sub-priority.
852:                 
853:                   Precondition:
854:                     None
855:                 
856:                   Parameters:
857:                     vector          - Interrupt vector.
858:                     subPriority     - Interrupt vector's sub-priority.
859:                 
860:                   Returns:
861:                     None
862:                 
863:                   Example:
864:                     <code>
865:                     INTSetVectorSubPriority(INT_CORE_TIMER_VECTOR, INT_SUB_PRIORITY_LEVEL_1);
866:                     </code>
867:                 
868:                   Remarks:
869:                     None
870:                   *****************************************************************************/
871:                 void INTSetVectorSubPriority(INT_VECTOR vector, INT_SUB_PRIORITY subPriority);
872:                 
873:                 /*******************************************************************************
874:                   Function:
875:                     INT_SUB_PRIORITY INTGetVectorSubPriority(INT_VECTOR vector)
876:                 
877:                   Summary:
878:                     Gets the interrupt vector's priority.
879:                 
880:                   Description:
881:                     This routine gets the interrupt vector's priority.
882:                 
883:                   Precondition:
884:                     None
885:                 
886:                   Parameters:
887:                     vector    - Interrupt vector.
888:                 
889:                   Returns:
890:                     interrupt vector's sub-priority
891:                 
892:                   Example:
893:                     <code>
894:                     INT_SUB_PRIORITY intSubPriority;
895:                 
896:                     intSubPriority = INTGetVectorSubPriority(INT_CORE_TIMER_VECTOR);
897:                     </code>
898:                 
899:                   Remarks:
900:                     None
901:                   *****************************************************************************/
902:                 INT_SUB_PRIORITY INTGetVectorSubPriority(INT_VECTOR vector);
903:                 
904:                 
905:                 /*******************************************************************************
906:                   Function:
907:                     extern inline void __attribute__ ((always_inline)) INTSetIntProximityTimerReload(unsigned int time)
908:                 
909:                   Summary:
910:                     Sets or reloads the interrupt proximity timer.
911:                 
912:                   Description:
913:                     This routine sets or reloads the interrupt proximity timer.
914:                 
915:                   Precondition:
916:                     None
917:                 
918:                   Parameters:
919:                     time            - 32-bit timer value.
920:                 
921:                   Returns:
922:                     None
923:                 
924:                   Example:
925:                     <code>
926:                     INTSetIntProximityTimerReload(56000);
927:                     </code>
928:                 
929:                   Remarks:
930:                     None
931:                   *****************************************************************************/
932:                 extern inline void __attribute__ ((always_inline)) INTSetIntProximityTimerReload(unsigned int time)
933:                 {
934:                     IPTMR = time;
935:                 }
936:                 /*******************************************************************************
937:                   Function:
938:                     extern inline unsigned int __attribute__ ((always_inline)) INTGetIntProximityTimer(void)
939:                 
940:                   Summary:
941:                     Gets the interrupt proximity timer.
942:                 
943:                   Description:
944:                     This routine gets the interrupt proximity timer.
945:                 
946:                   Precondition:
947:                     None
948:                 
949:                   Parameters:
950:                     None
951:                 
952:                   Returns:
953:                     The current tick count of the timer.
954:                 
955:                   Example:
956:                     <code>
957:                     unsigned int time
958:                 
959:                     time = INTGetIntProximityTimer();
960:                     </code>
961:                 
962:                   Remarks:
963:                     None
964:                   *****************************************************************************/
965:                 extern inline unsigned int __attribute__ ((always_inline)) INTGetIntProximityTimer(void)
966:                 {
967:                     return IPTMR;
968:                 }
969:                 /*******************************************************************************
970:                   Function:
971:                     extern inline void __attribute__ ((always_inline)) INTSetTemporalProximityControl(INT_TPC_GROUP level)
972:                 
973:                   Summary:
974:                     Sets the Temporal Proximity Control level.
975:                 
976:                   Description:
977:                     This routine sets the temporal Proximity Control level.
978:                 
979:                   Precondition:
980:                     None
981:                 
982:                   Parameters:
983:                     level   - Level of the temporal proximity control.
984:                 
985:                   Returns:
986:                     None
987:                 
988:                   Example:
989:                     <code>
990:                     INTSetTemporalProximityControl(INT_TPC_GROUP_PRI_LEVEL_3);
991:                     </code>
992:                 
993:                   Remarks:
994:                     None
995:                   *****************************************************************************/
996:                 extern inline void __attribute__ ((always_inline)) INTSetTemporalProximityControl(INT_TPC_GROUP level)
997:                 {
998:                     INTCONCLR = INT_TPC_DISABLE;
999:                 
1000:                    if(level != INT_TPC_DISABLE)
1001:                        INTCONSET = (level << _INTCON_TPC_POSITION);
1002:                }
1003:                
1004:                /*******************************************************************************
1005:                //DOM-IGNORE-BEGIN
1006:                  *****************************************************************************/
1007:                #define CORE_SW_0           0x00000100
1008:                #define CORE_SW_1           0x00000200
1009:                /*******************************************************************************
1010:                //DOM-IGNORE-END
1011:                  *****************************************************************************/
1012:                
1013:                
1014:                /*******************************************************************************
1015:                  Function:
1016:                    void __attribute__ ((nomips16)) CoreSetSoftwareInterrupt0(void)
1017:                
1018:                  Summary:
1019:                    Set the Core Software Interrupt 0.
1020:                
1021:                  Description:
1022:                    This routine sets the core software interrupt 0.  This will produce an interrupt
1023:                    service request.
1024:                
1025:                  Precondition:
1026:                    None
1027:                
1028:                  Parameters:
1029:                    None
1030:                
1031:                  Returns:
1032:                    None
1033:                
1034:                  Example:
1035:                    <code>
1036:                
1037:                    CoreSetSoftwareInterrupt0();
1038:                    </code>
1039:                
1040:                  Remarks:
1041:                    This function cannot be compiled using the MIPS16 instruction set.
1042:                  *****************************************************************************/
1043:                void __attribute__((nomips16)) CoreSetSoftwareInterrupt0(void);
1044:                
1045:                /*******************************************************************************
1046:                  Function:
1047:                    void __attribute__ ((nomips16)) CoreSetSoftwareInterrupt1(void)
1048:                
1049:                  Summary:
1050:                    Set the Core Software Interrupt 1.
1051:                
1052:                  Description:
1053:                    This routine sets the core software interrupt 1.  This will produce an interrupt
1054:                    service request.
1055:                
1056:                  Precondition:
1057:                    None
1058:                
1059:                  Parameters:
1060:                    None
1061:                
1062:                  Returns:
1063:                    None
1064:                
1065:                  Example:
1066:                    <code>
1067:                
1068:                    CoreSetSoftwareInterrupt1();
1069:                    </code>
1070:                
1071:                  Remarks:
1072:                    This function cannot be compiled using the MIPS16 instruction set.
1073:                  *****************************************************************************/
1074:                void __attribute__((nomips16))  CoreSetSoftwareInterrupt1(void);
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void __attribute__ ((nomips16)) CoreClearSoftwareInterrupt0(void)
1079:                
1080:                  Summary:
1081:                    Clears the Core Software Interrupt 0.
1082:                
1083:                  Description:
1084:                    This routine clears the core software interrupt 0.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    None
1091:                
1092:                  Returns:
1093:                    None
1094:                
1095:                  Example:
1096:                    <code>
1097:                
1098:                    CoreClearSoftwareInterrupt0();
1099:                
1100:                    INTClearFlag(INT_CS0);
1101:                    </code>
1102:                
1103:                  Remarks:
1104:                    This function cannot be compiled using the MIPS16 instruction set.
1105:                
1106:                    You must call this routine before clearing the interrupt request flag.
1107:                  *****************************************************************************/
1108:                void __attribute__((nomips16))  CoreClearSoftwareInterrupt0(void);
1109:                
1110:                /*******************************************************************************
1111:                  Function:
1112:                    void __attribute__ ((nomips16)) CoreClearSoftwareInterrupt1(void)
1113:                
1114:                  Summary:
1115:                    Clears the Core Software Interrupt 1.
1116:                
1117:                  Description:
1118:                    This routine clears the core software interrupt 1.
1119:                
1120:                  Precondition:
1121:                    None
1122:                
1123:                  Parameters:
1124:                    None
1125:                
1126:                  Returns:
1127:                    None
1128:                
1129:                  Example:
1130:                    <code>
1131:                
1132:                    CoreClearSoftwareInterrupt1();
1133:                
1134:                    INTClearFlag(INT_CS1);
1135:                    </code>
1136:                
1137:                  Remarks:
1138:                    This function cannot be compiled using the MIPS16 instruction set.
1139:                
1140:                    You must call this routine before clearing the interrupt request flag.
1141:                  *****************************************************************************/
1142:                void __attribute__((nomips16))  CoreClearSoftwareInterrupt1(void);
1143:                
1144:                #ifdef __cplusplus
1145:                  }
1146:                #endif
1147:                
1148:                #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000000  27BDFFF8   ADDIU SP, SP, -8
9D000004  AFBE0004   SW FP, 4(SP)
9D000008  03A0F025   OR FP, SP, ZERO
9D00000C  AFC40008   SW A0, 8(FP)
9D000010  3C02BF88   LUI V0, -16504
9D000014  8FC30008   LW V1, 8(FP)
9D000018  AC431004   SW V1, 4100(V0)
9D00001C  3C02BF88   LUI V0, -16504
9D000020  8FC30008   LW V1, 8(FP)
9D000024  AC431008   SW V1, 4104(V0)
9D000028  00000000   NOP
9D00002C  03C0E825   OR SP, FP, ZERO
9D000030  8FBE0004   LW FP, 4(SP)
9D000034  27BD0008   ADDIU SP, SP, 8
9D000038  03E00008   JR RA
9D00003C  00000000   NOP
9D000040  27BDFFF8   ADDIU SP, SP, -8
9D000044  AFBE0004   SW FP, 4(SP)
9D000048  03A0F025   OR FP, SP, ZERO
9D00004C  3C02BF88   LUI V0, -16504
9D000050  8C421010   LW V0, 4112(V0)
9D000054  7C422800   EXT V0, V0, 0, 6
9D000058  304200FF   ANDI V0, V0, 255
9D00005C  03C0E825   OR SP, FP, ZERO
9D000060  8FBE0004   LW FP, 4(SP)
9D000064  27BD0008   ADDIU SP, SP, 8
9D000068  03E00008   JR RA
9D00006C  00000000   NOP
9D000070  27BDFFF8   ADDIU SP, SP, -8
9D000074  AFBE0004   SW FP, 4(SP)
9D000078  03A0F025   OR FP, SP, ZERO
9D00007C  3C02BF88   LUI V0, -16504
9D000080  8C421010   LW V0, 4112(V0)
9D000084  7C421200   EXT V0, V0, 8, 3
9D000088  304200FF   ANDI V0, V0, 255
9D00008C  03C0E825   OR SP, FP, ZERO
9D000090  8FBE0004   LW FP, 4(SP)
9D000094  27BD0008   ADDIU SP, SP, 8
9D000098  03E00008   JR RA
9D00009C  00000000   NOP
9D0000A0  27BDFFF8   ADDIU SP, SP, -8
9D0000A4  AFBE0004   SW FP, 4(SP)
9D0000A8  03A0F025   OR FP, SP, ZERO
9D0000AC  AFC40008   SW A0, 8(FP)
9D0000B0  AFC5000C   SW A1, 12(FP)
9D0000B4  3C02BF88   LUI V0, -16504
9D0000B8  8C431010   LW V1, 4112(V0)
9D0000BC  8FC20008   LW V0, 8(FP)
9D0000C0  AC430000   SW V1, 0(V0)
9D0000C4  8FC20008   LW V0, 8(FP)
9D0000C8  8C420000   LW V0, 0(V0)
9D0000CC  00021202   SRL V0, V0, 8
9D0000D0  30430007   ANDI V1, V0, 7
9D0000D4  8FC2000C   LW V0, 12(FP)
9D0000D8  AC430000   SW V1, 0(V0)
9D0000DC  8FC20008   LW V0, 8(FP)
9D0000E0  8C420000   LW V0, 0(V0)
9D0000E4  3043003F   ANDI V1, V0, 63
9D0000E8  8FC20008   LW V0, 8(FP)
9D0000EC  AC430000   SW V1, 0(V0)
9D0000F0  00000000   NOP
9D0000F4  03C0E825   OR SP, FP, ZERO
9D0000F8  8FBE0004   LW FP, 4(SP)
9D0000FC  27BD0008   ADDIU SP, SP, 8
9D000100  03E00008   JR RA
9D000104  00000000   NOP
9D000108  27BDFFF8   ADDIU SP, SP, -8
9D00010C  AFBE0004   SW FP, 4(SP)
9D000110  03A0F025   OR FP, SP, ZERO
9D000114  AFC40008   SW A0, 8(FP)
9D000118  3C02BF88   LUI V0, -16504
9D00011C  8FC30008   LW V1, 8(FP)
9D000120  AC431020   SW V1, 4128(V0)
9D000124  00000000   NOP
9D000128  03C0E825   OR SP, FP, ZERO
9D00012C  8FBE0004   LW FP, 4(SP)
9D000130  27BD0008   ADDIU SP, SP, 8
9D000134  03E00008   JR RA
9D000138  00000000   NOP
9D00013C  27BDFFF8   ADDIU SP, SP, -8
9D000140  AFBE0004   SW FP, 4(SP)
9D000144  03A0F025   OR FP, SP, ZERO
9D000148  3C02BF88   LUI V0, -16504
9D00014C  8C421020   LW V0, 4128(V0)
9D000150  03C0E825   OR SP, FP, ZERO
9D000154  8FBE0004   LW FP, 4(SP)
9D000158  27BD0008   ADDIU SP, SP, 8
9D00015C  03E00008   JR RA
9D000160  00000000   NOP
9D000164  27BDFFF8   ADDIU SP, SP, -8
9D000168  AFBE0004   SW FP, 4(SP)
9D00016C  03A0F025   OR FP, SP, ZERO
9D000170  AFC40008   SW A0, 8(FP)
9D000174  3C02BF88   LUI V0, -16504
9D000178  24030700   ADDIU V1, ZERO, 1792
9D00017C  AC431004   SW V1, 4100(V0)
9D000180  8FC30008   LW V1, 8(FP)
9D000184  24020700   ADDIU V0, ZERO, 1792
9D000188  10620005   BEQ V1, V0, 0x9D0001A0
9D00018C  00000000   NOP
9D000190  8FC20008   LW V0, 8(FP)
9D000194  00021A00   SLL V1, V0, 8
9D000198  3C02BF88   LUI V0, -16504
9D00019C  AC431008   SW V1, 4104(V0)
9D0001A0  00000000   NOP
9D0001A4  03C0E825   OR SP, FP, ZERO
9D0001A8  8FBE0004   LW FP, 4(SP)
9D0001AC  27BD0008   ADDIU SP, SP, 8
9D0001B0  03E00008   JR RA
9D0001B4  00000000   NOP
---  c:/program files/microchip/xc32/v4.10/pic32mx/include/lega-c/peripheral/dma_3xx_4xx.h  -------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the “Company”) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company’s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_3XX_4XX_H_
43:                  #define _DMA_3XX_4XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                  	#define _DMA_CHANNELS		// DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                  	typedef enum
66:                  	{
67:                  		DMA_CHANNEL0,
68:                  	#ifdef _DMAC1
69:                  		DMA_CHANNEL1,
70:                  	#ifdef _DMAC2
71:                  		DMA_CHANNEL2,
72:                  	#ifdef _DMAC3
73:                  		DMA_CHANNEL3,
74:                  	#ifdef _DMAC4
75:                  		DMA_CHANNEL4,
76:                  	#ifdef _DMAC5
77:                  		DMA_CHANNEL5,
78:                  	#ifdef _DMAC6
79:                  		DMA_CHANNEL6,
80:                  	#ifdef _DMAC7
81:                  		DMA_CHANNEL7,
82:                  	#endif	// _DMAC7
83:                  	#endif	// _DMAC6
84:                  	#endif	// _DMAC5
85:                  	#endif	// _DMAC4
86:                  	#endif	// _DMAC3
87:                  	#endif	// _DMAC2
88:                  	#endif	// _DMAC1
89:                  		//	add/remove DMA channel as needed here
90:                  
91:                  		DMA_CHANNELS	// number of current available channels
92:                  	}DmaChannel;
93:                  
94:                  
95:                  	// Relative Dma channels priority, between each other
96:                  	typedef enum
97:                  	{
98:                  		DMA_CHN_PRI0,
99:                  		DMA_CHN_PRI1,
100:                 		DMA_CHN_PRI2,
101:                 		DMA_CHN_PRI3
102:                 	}DmaChannelPri;
103:                 
104:                 
105:                 
106:                 	// high level definitions for the API functions
107:                 
108:                 	typedef enum
109:                 	{
110:                 		DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
111:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
112:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
113:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
114:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
115:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
116:                 		DMA_OPEN_MATCH	= 0x80000000,                           // DMA channel stops on match
117:                 	}DmaOpenFlags;	// flags for the channel open
118:                 
119:                 
120:                 	typedef enum
121:                 	{
122:                 		DMA_EV_ERR =			0x1,		// address error event
123:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
124:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
125:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
126:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
127:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
128:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
129:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
130:                 
131:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
133:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_TXFER_OK,			// the transfer was performed successfully
139:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
140:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
141:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
142:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
143:                 		DMA_TXFER_TMO			// DMA transfer timeout
144:                 	}DmaTxferRes;		// DMA transfer result
145:                 
146:                 	typedef enum
147:                 	{
148:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
149:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
150:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
151:                 	}DmaWaitMode;		// DMA transfer wait mode
152:                 
153:                 
154:                 	/*********************************************************************
155:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
156:                 	 *
157:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
158:                 	 *
159:                 	 * Input:           chn    - channel to be configured in the DMA controller
160:                 	 *                  chPri  - the priority given to the channel, 0-3
161:                 	 *                  oFlags - orred flags specifying the open mode:
162:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
163:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
164:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
165:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
166:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
167:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
168:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
169:                 	 *
170:                 	 *
171:                 	 *
172:                 	 * Output:          None
173:                 	 *
174:                 	 * Side Effects:    None
175:                 	 *
176:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
177:                 	 *
178:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
179:                 	 *                  Use the low level functions to address special settings.
180:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
181:                 	 *                  After that the channel is configured.
182:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
183:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
184:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
185:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
186:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
187:                 	 *                  User has to call event channel functions to enable the event flags if needed.
188:                 	 *
189:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
190:                 	 ********************************************************************/
191:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
192:                 
193:                 	/*********************************************************************
194:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
195:                 	 *
196:                 	 * PreCondition:    None
197:                 	 *
198:                 	 * Input:			chn		- channel to be enabled
199:                 	 *
200:                 	 * Output:          None
201:                 	 *
202:                 	 * Side Effects:    None
203:                 	 *
204:                 	 * Overview:		The function enables a previously configured DMA channel.
205:                 	 *
206:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
207:                 	 *
208:                 	 * Example:			DmaChnEnable(DMA_CHANNEL2);
209:                 	 ********************************************************************/
210:                 	 void			DmaChnEnable(DmaChannel chn);
211:                 
212:                 	/*********************************************************************
213:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
214:                 	 *
215:                 	 * PreCondition:    None
216:                 	 *
217:                 	 * Input:			chn		- selected channel in the DMA controller
218:                 	 *
219:                 	 * Output:          None
220:                 	 *
221:                 	 * Side Effects:    None
222:                 	 *
223:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
224:                 	 *
225:                 	 * Note:            None.
226:                 	 *
227:                 	 * Example:			DmaChnDisable(DMA_CHANNEL2);
228:                 	 ********************************************************************/
229:                 	 void			DmaChnDisable(DmaChannel chn);
230:                 
231:                 	/*********************************************************************
232:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
233:                 	 *
234:                 	 * PreCondition:    chn		- valid DMA channel
235:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
236:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
237:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
238:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
239:                 	 *
240:                 	 * Input:			chn			- DMA channel number
241:                 	 * 								- vSrcAdd: source of the DMA transfer
242:                 	 * 								- vDstAdd: destination of the DMA transfer
243:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
244:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
245:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
246:                 	 *
247:                 	 * Output:          None
248:                 	 *
249:                 	 * Side Effects:    None
250:                 	 *
251:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
252:                 	 * 					the source and the destination addresses.
253:                 	 * 					the source and destination lengths
254:                 	 * 					and the number of bytes	transferred per event.
255:                 	 *
256:                 	 * Note:			The function clears the existing DMA channel event flags.
257:                 	 *
258:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL2, &U2RXREG, dstBuff, 1, 200, 1);
259:                 	 ********************************************************************/
260:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
261:                 
262:                 
263:                 	/*********************************************************************
264:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
265:                 	 *
266:                 	 * PreCondition:    chn		- valid DMA channel
267:                 	 *
268:                 	 * Input:           chn		- DMA channel number
269:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
270:                 	 * Output:          None
271:                 	 *
272:                 	 * Side Effects:    None
273:                 	 *
274:                 	 * Overview:        The function is a helper to set directly the transfer source address.
275:                 	 *
276:                 	 * Note:            None.
277:                 	 *
278:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
279:                 	 ********************************************************************/
280:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
281:                 
282:                 	/*********************************************************************
283:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
284:                 	 *
285:                 	 * PreCondition:    chn		- valid DMA channel
286:                 	 *
287:                 	 * Input:			chn			- DMA channel number
288:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
289:                 	 * Output:          None
290:                 	 *
291:                 	 * Side Effects:    None
292:                 	 *
293:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
294:                 	 *
295:                 	 * Note:            None
296:                 	 *
297:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
298:                 	 ********************************************************************/
299:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
300:                 
301:                 	/*********************************************************************
302:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
303:                 	 *
304:                 	 * PreCondition:    chn	- valid DMA channel
305:                 	 *
306:                 	 * Input:			chn		- DMA channel number
307:                 	 * 					pattern	-  the match pattern
308:                 	 *
309:                 	 * Output:          None
310:                 	 *
311:                 	 * Side Effects:    None
312:                 	 *
313:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
314:                 	 *
315:                 	 * Note:            None.
316:                 	 *
317:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL2, '\r');
318:                 	 ********************************************************************/
319:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
320:                 
321:                 	/*********************************************************************
322:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
323:                 	 *
324:                 	 * PreCondition:    chn	- valid DMA channel
325:                 	 *
326:                 	 * Input:			chn		- DMA channel number
327:                 	 *
328:                 	 * Output:          The channel match pattern.
329:                 	 *
330:                 	 * Side Effects:    None
331:                 	 *
332:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
333:                 	 *
334:                 	 * Note:            None.
335:                 	 *
336:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL2);
337:                 	 ********************************************************************/
338:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
339:                 
340:                 	/*********************************************************************
341:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
342:                 	 *
343:                 	 * PreCondition:    chn	- valid DMA channel
344:                 	 *
345:                 	 * Input:			chn		- DMA channel number
346:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
347:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
348:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
349:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
350:                 	 * 								If 0, wait forever.
351:                 	 *
352:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
353:                 	 * 					an DmaTxferRes error code  otherwise
354:                 	 *
355:                 	 * Side Effects:    None
356:                 	 *
357:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
358:                 	 * 					The DMA channel is enabled.
359:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
360:                 	 * 					this event) the function will periodically query the DMA controller for the
361:                 	 * 					transfer completion status.
362:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
363:                      * 					the block transfer than the function will re-force the transfer for each cell.
364:                 	 *
365:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
366:                      *                  by hardware interrupt requests.
367:                      *                  This is because the transfers are software forced, theere is no
368:                      *                  wait for the occurrence of the hardware trigger. 
369:                 	 *
370:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
371:                 	 ********************************************************************/
372:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
373:                 
374:                 	/*********************************************************************
375:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
376:                 	 *
377:                 	 * PreCondition:    chn	- valid DMA channel
378:                 	 *
379:                 	 * Input:			chn		- DMA channel number
380:                 	 *
381:                 	 * Output:          None
382:                 	 *
383:                 	 * Side Effects:    None
384:                 	 *
385:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
386:                 	 *
387:                 	 * Note:            None.
388:                 	 *
389:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL2);
390:                 	 ********************************************************************/
391:                 	 void			DmaChnForceTxfer(DmaChannel chn);
392:                 
393:                 	/*********************************************************************
394:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
395:                 	 *
396:                 	 * PreCondition:    chn	- valid DMA channel
397:                 	 *
398:                 	 * Input:			chn		- DMA channel number
399:                 	 *
400:                 	 * Output:          None
401:                 	 *
402:                 	 * Side Effects:    None
403:                 	 *
404:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
405:                 	 *
406:                 	 * Note:            None.
407:                 	 *
408:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL2);
409:                 	 ********************************************************************/
410:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
411:                 
412:                 	// High level channel event and interrupt control functions
413:                 
414:                 	/*********************************************************************
415:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
416:                 	 *
417:                 	 * PreCondition:    chn	- valid DMA channel
418:                 	 *
419:                 	 * Input:			chn		- DMA channel number
420:                 	 * 					eFlags	- event flags with the following significance:
421:                 	 * 								- DMA_EV_ERR: address error event
422:                 	 * 								- DMA_EV_ABORT: transfer abort event
423:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
424:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
425:                 	 * 								- DMA_EV_DST_HALF: destination half event
426:                 	 * 								- DMA_EV_DST_FULL: destination full event
427:                 	 * 								- DMA_EV_SRC_HALF: source half event
428:                 	 * 								- DMA_EV_SRC_FULL: source full event
429:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
430:                 	 *
431:                 	 * Output:          None
432:                 	 *
433:                 	 * Side Effects:    None
434:                 	 *
435:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
436:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
437:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
438:                 	 *
439:                 	 * Note:            None.
440:                 	 *
441:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
442:                 	 ********************************************************************/
443:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
444:                 
445:                 	/*********************************************************************
446:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
447:                 	 *
448:                 	 * PreCondition:    chn	- valid DMA channel
449:                 	 *
450:                 	 * Input:			chn		- DMA channel number
451:                 	 * 					eFlags	- event flags with the following significance:
452:                 	 * 								- DMA_EV_ERR: address error event
453:                 	 * 								- DMA_EV_ABORT: transfer abort event
454:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
455:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
456:                 	 * 								- DMA_EV_DST_HALF: destination half event
457:                 	 * 								- DMA_EV_DST_FULL: destination full event
458:                 	 * 								- DMA_EV_SRC_HALF: source half event
459:                 	 * 								- DMA_EV_SRC_FULL: source full event
460:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
461:                 	 *
462:                 	 * Output:          None
463:                 	 *
464:                 	 * Side Effects:    None
465:                 	 *
466:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
467:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
468:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
469:                 	 *
470:                 	 * Note:            None.
471:                 	 *
472:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
473:                 	 ********************************************************************/
474:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
475:                 
476:                 	/*********************************************************************
477:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
478:                 	 *
479:                 	 * PreCondition:    chn	- valid DMA channel
480:                 	 *
481:                 	 * Input:			chn		- DMA channel number
482:                 	 * 					eFlags	- event flags with the following significance:
483:                 	 * 								- DMA_EV_ERR: address error event
484:                 	 * 								- DMA_EV_ABORT: transfer abort event
485:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
486:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
487:                 	 * 								- DMA_EV_DST_HALF: destination half event
488:                 	 * 								- DMA_EV_DST_FULL: destination full event
489:                 	 * 								- DMA_EV_SRC_HALF: source half event
490:                 	 * 								- DMA_EV_SRC_FULL: source full event
491:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
492:                 	 *
493:                 	 * Output:          None
494:                 	 *
495:                 	 * Side Effects:    None
496:                 	 *
497:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
498:                 	 * 					The channel event flags are forced to the eFlags value.
499:                 	 *
500:                 	 * Note:            None.
501:                 	 *
502:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
503:                 	 ********************************************************************/
504:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
505:                 
506:                 	/*********************************************************************
507:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
508:                 	 *
509:                 	 * PreCondition:    chn	- valid DMA channel
510:                 	 *
511:                 	 * Input:			chn		- DMA channel number
512:                 	 *
513:                 	 * Output:          - event flags with the following significance:
514:                 	 * 						- DMA_EV_ERR: address error event
515:                 	 * 						- DMA_EV_ABORT: transfer abort event
516:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
517:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
518:                 	 * 						- DMA_EV_DST_HALF: destination half event
519:                 	 * 						- DMA_EV_DST_FULL: destination full event
520:                 	 * 						- DMA_EV_SRC_HALF: source half event
521:                 	 * 						- DMA_EV_SRC_FULL: source full event
522:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
523:                 	 *
524:                 	 * Side Effects:    None
525:                 	 *
526:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
527:                 	 *
528:                 	 * Note:            None.
529:                 	 *
530:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL2);
531:                 	 ********************************************************************/
532:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
533:                 
534:                 	/*********************************************************************
535:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
536:                 	 *
537:                 	 * PreCondition:    chn	- valid DMA channel
538:                 	 *
539:                 	 * Input:			chn		- DMA channel number
540:                 	 * 					eFlags	- event flags with the following significance:
541:                 	 * 								- DMA_EV_ERR: address error event
542:                 	 * 								- DMA_EV_ABORT: transfer abort event
543:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
544:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
545:                 	 * 								- DMA_EV_DST_HALF: destination half event
546:                 	 * 								- DMA_EV_DST_FULL: destination full event
547:                 	 * 								- DMA_EV_SRC_HALF: source half event
548:                 	 * 								- DMA_EV_SRC_FULL: source full event
549:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
550:                 	 *
551:                 	 * Output:          None
552:                 	 *
553:                 	 * Side Effects:    None
554:                 	 *
555:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
556:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
557:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
558:                 	 *
559:                 	 * Note:            None.
560:                 	 *
561:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
562:                 	 ********************************************************************/
563:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
564:                 
565:                 	/*********************************************************************
566:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
567:                 	 *
568:                 	 * PreCondition:    chn	- valid DMA channel
569:                 	 *
570:                 	 * Input:			chn		- DMA channel number
571:                 	 *
572:                 	 * Output:          event flags with the following significance:
573:                 	 * 						- DMA_EV_ERR: address error event
574:                 	 * 						- DMA_EV_ABORT: transfer abort event
575:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
576:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
577:                 	 * 						- DMA_EV_DST_HALF: destination half event
578:                 	 * 						- DMA_EV_DST_FULL: destination full event
579:                 	 * 						- DMA_EV_SRC_HALF: source half event
580:                 	 * 						- DMA_EV_SRC_FULL: source full event
581:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
582:                 	 *
583:                 	 * Side Effects:    None
584:                 	 *
585:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
586:                 	 *
587:                 	 * Note:            None.
588:                 	 *
589:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL2);
590:                 	 ********************************************************************/
591:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
592:                 
593:                 
594:                 	// high level helpers for fast strcpy/memcpy transfers
595:                 
596:                 	/*********************************************************************
597:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
598:                 	 *
599:                 	 * PreCondition:    chn		- a valid DMA channel
600:                 	 * 					s1, s2	- valid memory pointers
601:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
602:                 	 *
603:                 	 * Input:			s1		- destination pointer
604:                 	 * 					s2		- source pointer
605:                 	 * 					n		- number of bytes to transfer
606:                 	 * 					chn		- the DMA channel to perform the transfer
607:                 	 * 					chPri	- the desired channel priority
608:                 	 *
609:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
610:                 	 * 					an DmaTxferRes error code  otherwise
611:                 	 *
612:                 	 * Side Effects:    None
613:                 	 *
614:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
615:                 	 * 			Then it copies one block of memory from source to destination.
616:                 	 *
617:                 	 *
618:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
619:                 	 * 						This way, the transfer will occur correctly together with CRC calculation.
620:                 	 * 					- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
621:                 	 * 					- Multiple channels could be opened to perform fast memory transfers, if necessary.
622:                 	 * 					- The function clears the suspend state and resumes the operation of the DMA controller.
623:                 	 *
624:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL2, DMA_CHN_PRI3);
625:                  	 ********************************************************************/
626:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
627:                 
628:                 	/*********************************************************************
629:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
630:                 	 *
631:                 	 * PreCondition:    chn		- a valid DMA channel
632:                 	 * 					s1, s2	- valid memory pointers
633:                 	 *
634:                 	 * Input:			s1		- destination pointer
635:                 	 * 					s2		- source pointer
636:                 	 * 					chn		- the DMA channel to perform the transfer
637:                 	 * 					chPri	- the desired channel priority
638:                 	 *
639:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
640:                 	 * 					an DmaTxferRes error code  otherwise
641:                 	 *
642:                 	 * Side Effects:    None
643:                 	 *
644:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
645:                 	 * 			Then it copies one zero terminated string from source to destination.
646:                 	 *
647:                 	 *
648:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
649:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
650:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
651:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
652:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
653:                 	 *
654:                 	 *
655:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL2, DMA_CHN_PRI3);
656:                 	 *********************************************************************/
657:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
658:                 
659:                 	/*********************************************************************
660:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
661:                 	 *
662:                 	 * PreCondition:    chn		- a valid DMA channel
663:                 	 * 				- s1, s2	- valid memory pointers
664:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
665:                 	 *
666:                 	 * Input:			s1		- destination pointer
667:                 	 * 					s2		- source pointer
668:                 	 * 					n	- max number of bytes to transfer
669:                 	 * 					chn		- the DMA channel to perform the transfer
670:                 	 * 					chPri	- the desired channel priority
671:                 	 *
672:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
673:                 	 * 					an DmaTxferRes error code  otherwise
674:                 	 *
675:                 	 * Side Effects:    None
676:                 	 *
677:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
678:                 	 * 			Then it copies one zero terminated string from source to destination.
679:                 	 * 			It copies no more than n characters from s2.
680:                 	 *
681:                 	 *
682:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
683:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
684:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
685:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
686:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
687:                 	 *
688:                 	 *
689:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL2, DMA_CHN_PRI3);
690:                 	 ********************************************************************/
691:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
692:                 
693:                 	/*********************************************************************
694:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
695:                 	 *
696:                 	 * PreCondition:    chn		- a valid DMA channel
697:                 	 * 					d, s		- valid memory pointer
698:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
699:                 	 *
700:                 	 * Input:			d		- address where to deposit the result
701:                 	 * 					s		- source buffer pointer
702:                 	 * 					n		- number of bytes in the pointer
703:                 	 * 					chn		- the DMA channel to use
704:                 	 * 					chPri	- the desired channel priority
705:                 	 *
706:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
707:                 	 * 					an DmaTxferRes error code  otherwise
708:                 	 *
709:                 	 * Side Effects:    None
710:                 	 *
711:                 	 * Overview:		The function is a helper that calculates the CRC of a memory block.
712:                 	 * 			The function configures the DMA channel for a fast memory transfer and calculates the CRC.
713:                 	 *
714:                 	 *
715:                 	 * Note:            - The CRC generator must have been previously configured using mCrcConfigure()
716:                 	 * 					- No transfer is done, just the CRC is calculated.
717:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
718:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
719:                 	 *
720:                 	 * Example:		int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
721:                 	 ********************************************************************/
722:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
723:                 
724:                 
725:                 	// High level CRC functions
726:                 
727:                 	/*********************************************************************
728:                 	 * Function:        void DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
729:                 	 *
730:                 	 * PreCondition:    pLen		- valid polynomial length within 1-16
731:                 	 *
732:                 	 * Input:			polynomial	- the layout of the CRC generator
733:                 	 * 					pLen		- the length of the CRC generator polynomial
734:                 	 * 					seed		- the initial seed of the CRC generator
735:                 	 *
736:                 	 * Output:          None
737:                 	 *
738:                 	 * Side Effects:    None
739:                 	 *
740:                 	 * Overview:		The function configures the CRC module by setting the parameters that define the generator polynomial:
741:                 	 * 					- the length of the CRC generator polynomial, pLen;
742:                 	 * 					- the function sets the layout of the shift stages that take place in the CRC generation.
743:                 	 * 						Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
744:                 	 * 						If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
745:                 	 * 						Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
746:                 	 * 						are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
747:                 	 * 						feedback should be 0x8005, or 0x8004, but not 0x018005;
748:                 	 *					- the function sets the seed of the CRC generator. This is the initial data present in the
749:                 	 * 						CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
750:                 	 *
751:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
752:                 	 * 					- When the append mode is set, the attached DMA channel has to have destination size <=4.
753:                 	 * 						Upon the transfer completion the calculated CRC is stored at the destination address.
754:                 	 * 					- When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
755:                 	 * 						the CrcResult() function.
756:                 	 * 					- The CRC module should be configured before enabled.
757:                 	 *
758:                 	 * Example:			DmaCrcConfigure(0x8005, 16, 0xffff);
759:                 	 ********************************************************************/
760:                 	extern __inline__ void __attribute__((always_inline)) DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
761:                 	{
762:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
763:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
764:                 		DCRCDATA=seed;
765:                 		DCRCXOR=polynomial;
766:                 	}
767:                 
768:                 	/*********************************************************************
769:                 	 * Function:        void CrcAttachChannel(DmaChannel chn, int appendMode)
770:                 	 *
771:                 	 * PreCondition:    chn		- valid DMA channel
772:                 	 *
773:                 	 * Input:			chn			- the DMA channel to be attached to the CRC generator module.
774:                 	 * 					appendMode	- if TRUE the data passed to the CRC generator is not transferred to destination
775:                 	 * 									but it's written to the destination address when the block transfer is complete.
776:                 	 * 								- if FALSE the data is transferred normally while the CRC is calculated. The CRC will
777:                 	 * 									be available using the CrcResult function.
778:                 	 *
779:                 	 * Output:          None
780:                 	 *
781:                 	 * Side Effects:    None
782:                 	 *
783:                 	 * Overview:		The function attaches the CRC module to an DMA channel and enables the CRC generator.
784:                 	 * 					From now on, all the DMA traffic is directed to the CRC generator. Once the DMA block transfer
785:                 	 * 					is complete, the CRC result is available both at the DMA destination address and in the CRC data register.
786:                 	 *
787:                 	 * Note:            None
788:                 	 *
789:                 	 * Example:			CrcAttachChannel(0, TRUE);
790:                 	 ********************************************************************/
791:                 	 void			CrcAttachChannel(DmaChannel chn, int appendMode);
792:                 
793:                 	/*********************************************************************
794:                 	 * Function:        unsigned int CrcResult(void)
795:                 	 *
796:                 	 * PreCondition:    None
797:                 	 *
798:                 	 * Input:			None
799:                 	 *
800:                 	 * Output:          the current value of the CRC generator.
801:                 	 *
802:                 	 * Side Effects:    None
803:                 	 *
804:                 	 * Overview:		The function returns the calculated CRC value.
805:                 	 *
806:                 	 * Note:            The function returns the valid CRC result by masking out the unused MSbits in the CRC register.
807:                 	 * 					Use CrcGetValue() to get the full CRC register value.
808:                 	 *
809:                 	 * Example:			int myCrc=CrcResult();
810:                 	 ********************************************************************/
811:                 	 unsigned int		CrcResult(void);
812:                 
813:                 
814:                 /*********************  end of high level functions ****************************************/
815:                 
816:                 	// low level definitions for the API functions
817:                 
818:                 
819:                 	typedef struct
820:                 	{
821:                 		union
822:                 		{
823:                 			struct
824:                 			{
825:                 				unsigned int chn:	3;		// last active DMA channel
826:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
827:                 			};
828:                 			unsigned int	w;						// word access
829:                 		}lastAccess;
830:                 		void*	lastAddress;		// most recent DMA address
831:                 	}DmaStatus;			// DMA controller status
832:                 #if(defined(__32MX330F064H__)||\
833:                     defined(__32MX330F064L__)||\
834:                     defined(__32MX350F128H__)||\
835:                     defined(__32MX350F128L__)||\
836:                     defined(__32MX350F256H__)||\
837:                     defined(__32MX350F256L__)||\
838:                     defined(__32MX370F512H__)||\
839:                     defined(__32MX370F512L__)||\
840:                     defined(__32MX430F064H__)||\
841:                     defined(__32MX430F064L__)||\
842:                     defined(__32MX450F128H__)||\
843:                     defined(__32MX450F128L__)||\
844:                     defined(__32MX450F256H__)||\
845:                     defined(__32MX450F256L__)||\
846:                     defined(__32MX470F512L__)||\
847:                     defined(__32MX470F512L__))
848:                 typedef enum
849:                 	{
850:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
851:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
852:                 		//
853:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
854:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
855:                 #else
856:                 	typedef enum
857:                 	{
858:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
859:                 		DMA_GFLG_SIDL =		_DMACON_SIDL_MASK,		// DMA controller sleep/active in idle mode
860:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
861:                 		//
862:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_SIDL|DMA_GFLG_ON		// all flags
863:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
864:                 
865:                 #endif
866:                 
867:                 
868:                 	typedef enum
869:                 	{
870:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
871:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
872:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
873:                         // the start and abort IRQ signals
874:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
875:                 
876:                 
877:                         // compiler use only field
878:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
879:                 	}DmaEvCtrlFlags;	// DMA channel event control fields accessibile as flags
880:                 	// also part of DmaEvCtrlFlags:
881:                 	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
882:                 	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
883:                 
884:                 	// DMA channel event control as a structure:
885:                 	#define	DmaEvCtrl	__DCH0ECONbits_t
886:                 
887:                 
888:                 
889:                 
890:                 	typedef enum
891:                 	{
892:                 		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
893:                 		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
894:                 		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
895:                 		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
896:                 		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
897:                         // use the DMA_CTL_PRI() below for selecting the DMA
898:                         // channel priority
899:                 	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
900:                 	// also part of DmaChnCtrlFlags:
901:                 	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
902:                 
903:                 	// DMA channel control as a structure:
904:                 	#define	DmaChnCtrl  	__DCH0CONbits_t
905:                 
906:                 	typedef struct
907:                 	{
908:                 		void*	vSrcAdd;		// source of the DMA transfer, virtual
909:                 		void*	vDstAdd;		// destination of the DMA transfer, virtual
910:                 		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
911:                 		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
912:                 		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
913:                 	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
914:                 
915:                 
916:                 	/********************** low level DMA channel functions *******************************/
917:                 
918:                 
919:                 
920:                 	// Global DMA controller functions
921:                 
922:                 
923:                 	/*********************************************************************
924:                 	 * Function:        void DmaEnable(int enable)
925:                 	 *
926:                 	 * PreCondition:    None
927:                 	 *
928:                 	 * Input:           enable - boolean to enable/disable the DMA controller
929:                 	 *
930:                 	 * Output:          None
931:                 	 *
932:                 	 * Side Effects:    None
933:                 	 *
934:                 	 * Overview:       The function enables/disables the DMA controller.
935:                 	 *
936:                 	 * Note:           None.
937:                 	 *
938:                 	 * Example:        DmaEnable(1);
939:                 	 ********************************************************************/
940:                 	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
941:                 	{
942:                 		if(enable)
943:                 		{
944:                 			DMACONSET=_DMACON_ON_MASK;
945:                 		}
946:                 		else
947:                 		{
948:                 			DMACONCLR=_DMACON_ON_MASK;
949:                 			while(DMACONbits.ON);		// wait to take effect
950:                 		}
951:                 	}
952:                 
953:                 	/*********************************************************************
954:                 	 * Function:        void DmaReset(void)
955:                 	 *
956:                 	 * PreCondition:    None
957:                 	 *
958:                 	 * Input:		None
959:                 	 *
960:                 	 * Output:          None
961:                 	 *
962:                 	 * Side Effects:    None
963:                 	 *
964:                 	 * Overview:        The function resets the DMA controller.
965:                 	 *
966:                 	 * Note:            None.
967:                 	 *
968:                 	 * Example:        DmaReset();
969:                 	 ********************************************************************/
970:                 	#define            DmaReset()	DmaEnable(0)
971:                 
972:                 	/*********************************************************************
973:                 	 * Function:        int DmaSuspend(void)
974:                 	 *
975:                 	 * PreCondition:    None
976:                 	 *
977:                 	 * Input:		None
978:                 	 *
979:                 	 * Output:          true if the DMA was previously suspended, false otherwise
980:                 	 *
981:                 	 *
982:                 	 * Side Effects:    None
983:                 	 *
984:                 	 * Overview:        The function suspends the DMA controller.
985:                 	 *
986:                 	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
987:                 	 *                  I.e. the function has to wait for the suspension to take place!
988:                 	 *
989:                 	 * Example:			int susp=DmaSuspend();
990:                 	 ********************************************************************/
991:                     extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
992:                 	{
993:                 		int suspSt;
994:                 		if(!(suspSt=DMACONbits.SUSPEND))
995:                 		{
996:                 			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
997:                 			while(!(DMACONbits.SUSPEND));	// wait to be actually suspended
998:                 		}
999:                 		return suspSt;
1000:                	}
1001:                
1002:                
1003:                
1004:                	/*********************************************************************
1005:                	 * Function:        void DmaResume(int susp)
1006:                	 *
1007:                	 * PreCondition:    None
1008:                	 *
1009:                	 * Input:		the desired DMA suspended state.
1010:                	 *
1011:                	 * Output:          None
1012:                	 *
1013:                	 * Side Effects:    None
1014:                	 *
1015:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1016:                	 *
1017:                	 * Note:            None.
1018:                	 *
1019:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1020:                	 ********************************************************************/
1021:                    extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1022:                	{
1023:                		if(susp)
1024:                		{
1025:                			DmaSuspend();
1026:                		}
1027:                		else
1028:                		{
1029:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
1030:                		}
1031:                	}
1032:                
1033:                	/*********************************************************************
1034:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1035:                	 *
1036:                	 * PreCondition:    pStat	- valid pointer
1037:                	 *
1038:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1039:                	 * 							status, carrying the following info:
1040:                	 * 								- chn:	the last active DMA channel
1041:                	 * 								- rdOp: the last DMA operation, read/write
1042:                	 * 								- lastAddress: the most recent DMA address
1043:                	 *
1044:                	 * Output:          None
1045:                	 *
1046:                	 * Side Effects:    None
1047:                	 *
1048:                	 * Overview:		The function updates the info for the current DMA controller status.
1049:                	 * 					It updates the last DMA: operation, channel used and address.
1050:                	 *
1051:                	 * Note:            None.
1052:                	 *
1053:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1054:                	 ********************************************************************/
1055:                	 void			DmaGetStatus(DmaStatus* pStat);
1056:                
1057:                	/*********************************************************************
1058:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1059:                	 *
1060:                	 * PreCondition:    None
1061:                	 *
1062:                	 * Input:			gFlags	- flags to be set, having the following fields:
1063:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1064:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1065:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1066:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1067:                	 *
1068:                	 * Output:          None
1069:                	 *
1070:                	 * Side Effects:    None
1071:                	 *
1072:                	 * Overview:		The function affects the global behavior of the DMA controller.
1073:                	 * 					It sets the specified flags. Any flag that is set in the gFlags will be
1074:                	 * 					enabled, the other flags won't be touched.
1075:                	 *
1076:                	 * Note:            None.
1077:                	 *
1078:                	 * Example:			DmaSetGlobalFlags(DMA_GFLG_SIDL|DMA_GFLG_ON);
1079:                	 ********************************************************************/
1080:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1081:                	{
1082:                		DMACONSET=gFlags;
1083:                	}
1084:                
1085:                	/*********************************************************************
1086:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1087:                	 *
1088:                	 * PreCondition:    None
1089:                	 *
1090:                	 * Input:			gFlags	- flags to be cleared, having the following fields:
1091:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1092:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1093:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1094:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1095:                	 *
1096:                	 * Output:          None
1097:                	 *
1098:                	 * Side Effects:    None
1099:                	 *
1100:                	 * Overview:		The function affects the global behavior of the DMA controller.
1101:                	 * 					It clears the specified flags. Any flag that is set in the gFlags will be
1102:                	 * 					cleared, the other flags won't be touched.
1103:                	 *
1104:                	 * Note:            None.
1105:                	 *
1106:                	 * Example:			DmaClrGlobalFlags(DMA_GFLG_SUSPEND|DMA_GFLG_SIDL);
1107:                	 ********************************************************************/
1108:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1109:                	{
1110:                		DMACONCLR=gFlags;
1111:                	}
1112:                
1113:                
1114:                	/*********************************************************************
1115:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1116:                	 *
1117:                	 * PreCondition:    None
1118:                	 *
1119:                	 * Input:			gFlags	- flags to be set, having the following fields:
1120:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1121:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1122:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1123:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1124:                	 *
1125:                	 * Output:          None
1126:                	 *
1127:                	 * Side Effects:    None
1128:                	 *
1129:                	 * Overview:		The function affects the global behavior of the DMA controller.
1130:                	 * 					It forces the flags to have the specified gFlags value.
1131:                	 *
1132:                	 * Note:            None.
1133:                	 *
1134:                	 * Example:			DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1135:                	 ********************************************************************/
1136:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1137:                	{
1138:                		DMACON=gFlags;
1139:                	}
1140:                
1141:                	/*********************************************************************
1142:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1143:                	 *
1144:                	 * PreCondition:    None
1145:                	 *
1146:                	 * Input:			None
1147:                	 *
1148:                	 * Output:          The current DMA controller flags settings.
1149:                	 * 						- DMA_GFLG_SUSPEND: DMA controller operation suspend
1150:                	 * 						- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1151:                	 * 						- DMA_GFLG_ON: DMA controller enabled/desabled
1152:                	 *
1153:                	 * Side Effects:    None
1154:                	 *
1155:                	 * Overview:		The function returns the global flags of the DMA controller.
1156:                	 *
1157:                	 * Note:            None.
1158:                	 *
1159:                	 * Example:			DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1160:                	 ********************************************************************/
1161:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1162:                	{
1163:                		return (DmaGlblFlags)DMACON;
1164:                	}
1165:                
1166:                
1167:                	/*********************************************************************
1168:                	 * Function:        int DmaGetMaxTxferSize(void)
1169:                	 *
1170:                	 * PreCondition:    None
1171:                	 *
1172:                	 * Input:           None
1173:                	 *
1174:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1175:                	 *
1176:                	 * Side Effects:    None
1177:                	 *
1178:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1179:                	 *
1180:                	 * Note:            Revision dependant.
1181:                	 *
1182:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1183:                	 ********************************************************************/
1184:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1185:                	{
1186:                		return 256;
1187:                	}
1188:                
1189:                
1190:                	// Direct Channel control functions
1191:                
1192:                	typedef enum
1193:                	{
1194:                		DMA_CONFIG_DEFAULT = 0,							        // DMA default operation
1195:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
1196:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1197:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),			// DMA channel is chained to higher channel
1198:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,				// events detection enabled while channel off
1199:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
1200:                		DMA_CONFIG_MATCH	= 0x80000000,						// DMA channel stops on match
1201:                	}DmaConfigFlags;	// flags for the channel configuration
1202:                
1203:                	/*********************************************************************
1204:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1205:                	 *
1206:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1207:                	 *
1208:                	 * Input:           chn    - channel to be configured in the DMA controller
1209:                	 *                  chPri  - the priority given to the channel, 0-3
1210:                	 *                  cFlags - orred flags specifying the configuration:
1211:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1212:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1213:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1214:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1215:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1216:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1217:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1218:                	 *
1219:                	 *
1220:                	 *
1221:                	 * Output:          None
1222:                	 *
1223:                	 * Side Effects:    None
1224:                	 *
1225:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1226:                	 *
1227:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1228:                	 *                  The channel is just configured.
1229:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1230:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1231:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1232:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1233:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1234:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1235:                	 *
1236:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1237:                	 ********************************************************************/
1238:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1239:                
1240:                
1241:                	/*********************************************************************
1242:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1243:                	 *
1244:                	 * PreCondition:    chn	- valid DMA channel
1245:                	 *
1246:                	 * Input:			chn		- DMA channel number
1247:                	 *
1248:                	 * Output:          Current channel source pointer.
1249:                	 *
1250:                	 * Side Effects:    None
1251:                	 *
1252:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1253:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1254:                	 *
1255:                	 * Note:            None
1256:                	 *
1257:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL2);
1258:                	 ********************************************************************/
1259:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1260:                
1261:                	/*********************************************************************
1262:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1263:                	 *
1264:                	 * PreCondition:    chn	- valid DMA channel
1265:                	 *
1266:                	 * Input:			chn		- DMA channel number
1267:                	 *
1268:                	 * Output:          Current channel destination pointer.
1269:                	 *
1270:                	 * Side Effects:    None
1271:                	 *
1272:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1273:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1274:                	 *
1275:                	 * Note:            None
1276:                	 *
1277:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL2);
1278:                	 ********************************************************************/
1279:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1280:                
1281:                	/*********************************************************************
1282:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1283:                	 *
1284:                	 * PreCondition:    chn	- valid DMA channel
1285:                	 *
1286:                	 * Input:			chn		- DMA channel number
1287:                	 *
1288:                	 * Output:          Current channel transfer pointer.
1289:                	 *
1290:                	 * Side Effects:    None
1291:                	 *
1292:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1293:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1294:                	 *
1295:                	 * Note:            None
1296:                	 *
1297:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL2);
1298:                	 ********************************************************************/
1299:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1300:                
1301:                
1302:                
1303:                	/*********************************************************************
1304:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1305:                	 *
1306:                	 * PreCondition:    chn	- valid DMA channel
1307:                	 *
1308:                	 * Input:			chn			- DMA channel number
1309:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1310:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1311:                	 * 										- SIRQEN: enable/disable the start IRQ action
1312:                	 * 										- PATEN: enable/disable the pattern match and abort
1313:                	 * 									or any of the DmaEvCtrlFlags:
1314:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1315:                	 *
1316:                	 *
1317:                	 * Output:          None
1318:                	 *
1319:                	 * Side Effects:    None
1320:                	 *
1321:                	 * Overview:		The function sets the events that start and abort the transfer
1322:                	 * 					for the selected DMA channel.
1323:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1324:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1325:                	 *
1326:                	 * Note:            None.
1327:                	 *
1328:                	 * Example:			either:
1329:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1330:                	 * 					or:
1331:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1332:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1333:                	 *
1334:                	 ********************************************************************/
1335:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1336:                
1337:                
1338:                	/*********************************************************************
1339:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1340:                	 *
1341:                	 * PreCondition:    chn	- valid DMA channel
1342:                	 *
1343:                	 * Input:			chn			- DMA channel number
1344:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1345:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1346:                	 * 										- SIRQEN: enable/disable the start IRQ action
1347:                	 * 										- PATEN: enable/disable the pattern match and abort
1348:                	 * 									or any of the DmaEvCtrlFlags:
1349:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1350:                	 *
1351:                	 *
1352:                	 * Output:          None
1353:                	 *
1354:                	 * Side Effects:    None
1355:                	 *
1356:                	 * Overview:		The function clears the events that start and abort the transfer
1357:                	 * 					for the selected DMA channel.
1358:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1359:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1360:                	 *
1361:                	 * Note:            None.
1362:                	 *
1363:                	 * Example:			either:
1364:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1365:                	 * 					or:
1366:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1367:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1368:                	 *
1369:                	 ********************************************************************/
1370:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1371:                
1372:                
1373:                
1374:                	/*********************************************************************
1375:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1376:                	 *
1377:                	 * PreCondition:    chn	- valid DMA channel
1378:                	 *
1379:                	 * Input:			chn			- DMA channel number
1380:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1381:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1382:                	 * 										- SIRQEN: enable/disable the start IRQ action
1383:                	 * 										- PATEN: enable/disable the pattern match and abort
1384:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1385:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1386:                	 * 									or any of the DmaEvCtrlFlags:
1387:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1388:                	 *
1389:                	 *
1390:                	 * Output:          None
1391:                	 *
1392:                	 * Side Effects:    None
1393:                	 *
1394:                	 * Overview:		The function writes the events that start and abort the transfer
1395:                	 * 					for the selected DMA channel.
1396:                	 *
1397:                	 * Note:            None.
1398:                	 *
1399:                	 * Example:			either:
1400:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1401:                	 * 					or:
1402:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1403:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1404:                	 *
1405:                	 ********************************************************************/
1406:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1407:                
1408:                
1409:                
1410:                	/*********************************************************************
1411:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1412:                	 *
1413:                	 * PreCondition:    chn	- valid DMA channel
1414:                	 *
1415:                	 * Input:			chn			- DMA channel number
1416:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1417:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1418:                	 * 										- SIRQEN: enable/disable the start IRQ action
1419:                	 * 										- PATEN: enable/disable the pattern match and abort
1420:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1421:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1422:                	 * 									or any of the DmaEvCtrlFlags:
1423:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1424:                	 *
1425:                	 *
1426:                	 * Output:          None
1427:                	 *
1428:                	 * Side Effects:    None
1429:                	 *
1430:                	 * Overview:		The function sets the events that start and abort the transfer
1431:                	 * 					for the selected DMA channel.
1432:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1433:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1434:                	 *
1435:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1436:                	 *
1437:                	 * Example:			either:
1438:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1439:                	 * 					or:
1440:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1441:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, evCtrl.w);
1442:                	 *
1443:                	 ********************************************************************/
1444:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1445:                
1446:                
1447:                	/*********************************************************************
1448:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1449:                	 *
1450:                	 * PreCondition:    chn	- valid DMA channel
1451:                	 *
1452:                	 * Input:			chn		- DMA channel number
1453:                	 *
1454:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1455:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1456:                	 * 							- SIRQEN: enable/disable the start IRQ action
1457:                	 * 							- PATEN: enable/disable the pattern match and abort
1458:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1459:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1460:                	 * 						or any of the DmaEvCtrlFlags:
1461:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1462:                	 *
1463:                	 *
1464:                	 * Side Effects:    None
1465:                	 *
1466:                	 * Overview:		The function retrieves the events that start and abort the transfer
1467:                	 * 					for the selected DMA channel.
1468:                	 *
1469:                	 * Note:            None.
1470:                	 *
1471:                	 * Example:			either:
1472:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1473:                	 * 					or:
1474:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrl.PATEN){...}
1475:                	 *
1476:                	 ********************************************************************/
1477:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1478:                
1479:                
1480:                	/*********************************************************************
1481:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1482:                	 *
1483:                	 * PreCondition:    chn	- valid DMA channel
1484:                	 *
1485:                	 * Input:			chn			- DMA channel number
1486:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1487:                	 * 										- autoEn: enable/disable the automatic mode
1488:                	 * 										- chainEn: enable/disable channel chaining
1489:                	 * 										- detectEn: enable/disable events detection when channel disabled
1490:                	 * 										- chEn: enable/disable channel functionality
1491:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1492:                	 * 									or any of the DmaChnCtrlFlags flags:
1493:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1494:                	 *
1495:                	 * Output:          None
1496:                	 *
1497:                	 * Side Effects:    None
1498:                	 *
1499:                	 * Overview:		The function sets the selected DMA channel control flags:
1500:                	 * 					the chaining or auto mode, and events detection.
1501:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1502:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1503:                	 *
1504:                	 * Note:            None.
1505:                	 *
1506:                	 * Example:			either:
1507:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1508:                	 * 					or:
1509:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1510:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, chCtrl.w);
1511:                	 *
1512:                	 ********************************************************************/
1513:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1514:                
1515:                	/*********************************************************************
1516:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1517:                	 *
1518:                	 * PreCondition:    chn	- valid DMA channel
1519:                	 *
1520:                	 * Input:			chn			- DMA channel number
1521:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1522:                	 * 										- autoEn: enable/disable the automatic mode
1523:                	 * 										- chainEn: enable/disable channel chaining
1524:                	 * 										- detectEn: enable/disable events detection when channel disabled
1525:                	 * 										- chEn: enable/disable channel functionality
1526:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1527:                	 * 									or any of the DmaChnCtrlFlags flags:
1528:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1529:                	 *
1530:                	 * Output:          None
1531:                	 *
1532:                	 * Side Effects:    None
1533:                	 *
1534:                	 * Overview:		The function clears the selected DMA channel control flags:
1535:                	 * 					the chaining or auto mode and events detection.
1536:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1537:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1538:                	 *
1539:                	 * Note:            None.
1540:                	 *
1541:                	 * Example:			either:
1542:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1543:                	 * 					or:
1544:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1545:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, chCtrl.w);
1546:                	 *
1547:                	 ********************************************************************/
1548:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1549:                
1550:                	/*********************************************************************
1551:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1552:                	 *
1553:                	 * PreCondition:    chn	- valid DMA channel
1554:                	 *
1555:                	 * Input:			chn			- DMA channel number
1556:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1557:                	 * 										- chPri: channel priority 0-3
1558:                	 * 										- autoEn: enable/disable the automatic mode
1559:                	 * 										- chainEn: enable/disable channel chaining
1560:                	 * 										- detectEn: enable/disable events detection when channel disabled
1561:                	 * 										- chEn: enable/disable channel functionality
1562:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1563:                	 * 									or any of the DmaChnCtrlFlags flags:
1564:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1565:                	 *
1566:                	 * Output:          None
1567:                	 *
1568:                	 * Side Effects:    None
1569:                	 *
1570:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1571:                	 * 					the channel priority, chaining mode or auto and events detection.
1572:                	 *
1573:                	 * Note:            None.
1574:                	 *
1575:                	 * Example:			either:
1576:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1577:                	 * 					or:
1578:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1579:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, chCtrl.w);
1580:                	 *
1581:                	 ********************************************************************/
1582:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1583:                
1584:                	/*********************************************************************
1585:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1586:                	 *
1587:                	 * PreCondition:    chn	- valid DMA channel
1588:                	 *
1589:                	 * Input:	    chn		- DMA channel number
1590:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1591:                	 * 						- chPri: channel priority 0-3
1592:                	 * 						- autoEn: enable/disable the automatic mode
1593:                	 * 						- chainEn: enable/disable channel chaining
1594:                	 * 						- detectEn: enable/disable events detection when channel disabled
1595:                	 * 						- chEn: enable/disable channel functionality
1596:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1597:                	 * 					or any of the DmaChnCtrlFlags flags:
1598:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1599:                	 *
1600:                	 * Output:          None
1601:                	 *
1602:                	 * Side Effects:    None
1603:                	 *
1604:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1605:                	 * 					the channel priority, chaining mode or auto and events detection.
1606:                	 *
1607:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1608:                	 *
1609:                	 * Example:         either:
1610:                	 *                      DmaChnSetControl(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1611:                	 *                  or:
1612:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1613:                	 * 			DmaChnSetControl(DMA_CHANNEL2, chCtrl.w);
1614:                	 *
1615:                	 ********************************************************************/
1616:                #define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1617:                
1618:                	/*********************************************************************
1619:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1620:                	 *
1621:                	 * PreCondition:    chn	- valid DMA channel
1622:                	 *
1623:                	 * Input:			chn			- DMA channel number
1624:                	 *
1625:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1626:                	 * 							- chPri: channel priority 0-3
1627:                	 * 							- autoEn: enable/disable the automatic mode
1628:                	 * 							- chainEn: enable/disable channel chaining
1629:                	 * 							- detectEn: enable/disable events detection when channel disabled
1630:                	 * 							- chEn: enable/disable channel functionality
1631:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1632:                	 *						or any of the DmaChnCtrlFlags flags:
1633:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1634:                	 *
1635:                	 * Side Effects:    None
1636:                	 *
1637:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1638:                	 * 					including the channel enable/disable status, the channel priority,
1639:                	 * 					chaining mode, auto mode and events detection.
1640:                	 *
1641:                	 * Note:            None.
1642:                	 *
1643:                	 * Example:			either:
1644:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL2); if(ctrl&DMA_CTL_AUTO_EN) {...}
1645:                	 * 					or:
1646:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL2); if(chnCtrl.autoEn) {...}
1647:                	 *
1648:                	 ********************************************************************/
1649:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1650:                
1651:                
1652:                	/*********************************************************************
1653:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1654:                	 *
1655:                	 * PreCondition:    chn	- valid DMA channel
1656:                	 *
1657:                	 * Input:			chn		- DMA channel number
1658:                	 *
1659:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1660:                	 *
1661:                	 * Side Effects:    None
1662:                	 *
1663:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1664:                	 *
1665:                	 * Note:            None.
1666:                	 *
1667:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL2);
1668:                	 *
1669:                	 ********************************************************************/
1670:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1671:                
1672:                	/*********************************************************************
1673:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1674:                	 *
1675:                	 * PreCondition:    chn		- valid DMA channel
1676:                	 * 					pTxCtrl	- valid pointer
1677:                	 *
1678:                	 * Input:			chn			- DMA channel number
1679:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1680:                	 * 								- vSrcAdd: source of the DMA transfer
1681:                	 * 								- vDstAdd: destination of the DMA transfer
1682:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1683:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1684:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1685:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1692:                	 * 					the source and the destination addresses.
1693:                	 * 					It also retrieves the source and destination lengths
1694:                	 * 					and the number of bytes	transferred per event.
1695:                	 *
1696:                	 * Note:            None
1697:                	 *
1698:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL2, &txCtl, FALSE);
1699:                	 ********************************************************************/
1700:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1701:                
1702:                	// Low level CRC functions
1703:                
1704:                	/*********************************************************************
1705:                	 * Function:        void DmaCrcEnable(int enable)
1706:                	 *
1707:                	 * PreCondition:    None
1708:                	 *
1709:                	 * Input:           enable - boolean to enable/disable the CRC module
1710:                	 *
1711:                	 * Output:          None
1712:                	 *
1713:                	 * Side Effects:    None
1714:                	 *
1715:                	 * Overview:        The function enables the CRC module functionality and the attached DMA channel transfers are routed to the CRC module.
1716:                	 *
1717:                	 * Note:            The CRC module should be properly configured before enabled.
1718:                	 *
1719:                	 * Example:         CrcEnable(1);
1720:                	 ********************************************************************/
1721:                	extern __inline__ void __attribute__((always_inline)) DmaCrcEnable(int enable)
1722:                	{
1723:                		if(enable)
1724:                		{
1725:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1726:                		}
1727:                		else
1728:                		{
1729:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1730:                		}
1731:                	}
1732:                
1733:                
1734:                
1735:                	/*********************************************************************
1736:                	 * Function:        int DmaCrcGetEnable(void)
1737:                	 *
1738:                	 * PreCondition:    None
1739:                	 *
1740:                	 * Input:			None
1741:                	 *
1742:                	 * Output:          TRUE, if the CRC module is enabled
1743:                	 * 					FALSE otherwise
1744:                	 *
1745:                	 * Side Effects:    None
1746:                	 *
1747:                	 * Overview:		The function returns the CRC module enabling status.
1748:                	 *
1749:                	 * Note:            None
1750:                	 *
1751:                	 * Example:			int isCrcEnabled=DmaCrcGetEnable();
1752:                	 ********************************************************************/
1753:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetEnable(void)
1754:                	{
1755:                		return	DCRCCONbits.CRCEN!=0;
1756:                	}
1757:                
1758:                	
1759:                	/*********************************************************************
1760:                	 * Function:        void DmaCrcAppendModeEnable(int enable)
1761:                	 *
1762:                	 * PreCondition:    None
1763:                	 *
1764:                	 * Input:           enable - boolean to enable/disable the append mode
1765:                	 *
1766:                	 * Output:          None
1767:                	 *
1768:                	 * Side Effects:    None
1769:                	 *
1770:                	 * Overview:		The function enables the CRC append mode. In this mode, the attached DMA channel reads
1771:                	 * 					the source data but does not write it to the destination address. The data it's just passed
1772:                	 * 					to the CRC generator for CRC calculation.
1773:                	 * 					When the block transfer is completed, the CRC result is written to the
1774:                	 * 					DMA channel destination address.
1775:                	 *
1776:                	 * Note:            The CRC module should be properly configured before enabled.
1777:                	 *
1778:                	 * Example:         DmaCrcAppendModeEnable(1);
1779:                	 ********************************************************************/
1780:                	extern __inline__ void __attribute__((always_inline)) DmaCrcAppendModeEnable(int enable)
1781:                	{
1782:                		if(enable)
1783:                		{
1784:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1785:                		}
1786:                		else
1787:                		{
1788:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1789:                		}
1790:                	}
1791:                
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        int DmaCrcGetAppendMode(void)
1795:                	 *
1796:                	 * PreCondition:    None
1797:                	 *
1798:                	 * Input:           None
1799:                	 *
1800:                	 * Output:          TRUE, if the CRC append mode is enabled
1801:                	 * 					FALSE otherwise
1802:                	 *
1803:                	 * Side Effects:    None
1804:                	 *
1805:                	 * Overview:		The function returns the CRC module enabling status.
1806:                	 *
1807:                	 * Note:            None
1808:                	 *
1809:                	 * Example:			int isAppendEnabled=DmaCrcGetAppendMode();
1810:                	 ********************************************************************/
1811:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetAppendMode(void)
1812:                	{
1813:                		return DCRCCONbits.CRCAPP!=0;
1814:                	}
1815:                
1816:                	/*********************************************************************
1817:                	 * Function:        void DmaCrcSetAttach(DmaChannel chn)
1818:                	 *
1819:                	 * PreCondition:    chn		- valid DMA channel
1820:                	 *
1821:                	 * Input:			chn	- the DMA channel to be attached to the CRC module (the DMA channel transfers will be routed to the CRC module)
1822:                	 *
1823:                	 * Output:          None
1824:                	 *
1825:                	 * Side Effects:    None
1826:                	 *
1827:                	 * Overview:		The function attaches a DMA channel to the CRC module.
1828:                	 *
1829:                	 * Note:            None
1830:                	 *
1831:                	 * Example:			DmaCrcSetAttach(DMA_CHANNEL0);
1832:                	 ********************************************************************/
1833:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetAttach(DmaChannel chn)
1834:                	{
1835:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1836:                		DCRCCONSET=chn;
1837:                	}
1838:                		
1839:                	/*********************************************************************
1840:                	 * Function:        DmaChannel DmaCrcGetAttach(void)
1841:                	 *
1842:                	 * PreCondition:    None
1843:                	 *
1844:                	 * Input:			None
1845:                	 *
1846:                	 * Output:          the DMA channel that is currently attached to the CRC module
1847:                	 *
1848:                	 * Side Effects:    None
1849:                	 *
1850:                	 * Overview:		The function returns the DMA channel number that is currently attached to the CRC module.
1851:                	 *
1852:                	 * Note:            None
1853:                	 *
1854:                	 * Example:			DmaChannel chn=DmaCrcGetAttach();
1855:                	 ********************************************************************/
1856:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaCrcGetAttach(void)
1857:                	{
1858:                		return	(DmaChannel)DCRCCONbits.CRCCH;
1859:                	}
1860:                
1861:                
1862:                	/*********************************************************************
1863:                	 * Function:        void DmaCrcSetPLen(int pLen)
1864:                	 *
1865:                	 * PreCondition:    pLen	- valid polynomial length within 1-16
1866:                	 *
1867:                	 * Input:			pLen	- the length of the CRC generator polynomial
1868:                	 *
1869:                	 * Output:          None
1870:                	 *
1871:                	 * Side Effects:    None
1872:                	 *
1873:                	 * Overview:		The length of the CRC generator polynomial is set as being pLen;
1874:                	 *
1875:                	 * Note:            None
1876:                	 *
1877:                	 * Example:         DmaCrcSetPLen(16);
1878:                	 ********************************************************************/
1879:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1880:                	{
1881:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
1882:                		DCRCCONSET=(pLen)-1;
1883:                	}
1884:                		
1885:                	/*********************************************************************
1886:                	 * Function:        int DmaCrcGetPLen(void)
1887:                	 *
1888:                	 * PreCondition:    None
1889:                	 *
1890:                	 * Input:           None
1891:                	 *
1892:                	 * Output:          the length of the CRC generator polynomial
1893:                	 *
1894:                	 * Side Effects:    None
1895:                	 *
1896:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
1897:                	 *                  It's always a number between 1 and 16.
1898:                	 *
1899:                	 * Note:            None
1900:                	 *
1901:                	 * Example:         int polyLen=DmaCrcGetPLen();
1902:                	 ********************************************************************/
1903:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
1904:                	{
1905:                		return	DCRCCONbits.PLEN+1; 
1906:                	}
1907:                	
1908:                
1909:                	/*********************************************************************
1910:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
1911:                	 *
1912:                	 * PreCondition:    None
1913:                	 *
1914:                	 * Input:			feedback	- the layout of the CRC generator
1915:                	 *
1916:                	 * Output:          None
1917:                	 *
1918:                	 * Side Effects:    None
1919:                	 *
1920:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
1921:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1922:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1923:                	 *
1924:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1925:                	 *
1926:                	 * Example:         DmaCrcSetShiftFeedback(0x8005);
1927:                	 ********************************************************************/
1928:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
1929:                	{
1930:                		DCRCXOR=feedback;
1931:                	}
1932:                
1933:                		
1934:                	/*********************************************************************
1935:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
1936:                	 *
1937:                	 * PreCondition:    None
1938:                	 *
1939:                	 * Input:			None
1940:                	 *
1941:                	 * Output:          the current layout of the CRC generator
1942:                	 *
1943:                	 * Side Effects:    None
1944:                	 *
1945:                	 * Overview:		The function returns the layout of the shift stages that take place in the CRC generation.
1946:                	 * 					A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1947:                	 * 					If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1948:                	 *
1949:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1950:                	 *
1951:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
1952:                	 ********************************************************************/
1953:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
1954:                	{
1955:                		return DCRCXOR;
1956:                	}
1957:                
1958:                	/*********************************************************************
1959:                	 * Function:        void DmaCrcSetSeed(unsigned int seed)
1960:                	 *
1961:                	 * PreCondition:    None
1962:                	 *
1963:                	 * Input:			seed	- the initial seed of the CRC generator
1964:                	 *
1965:                	 * Output:          None
1966:                	 *
1967:                	 * Side Effects:    None
1968:                	 *
1969:                	 * Overview:		The function sets the seed of the CRC generator. This is the initial data present in the
1970:                	 * 					CRC shift register before the CRC calculation begins.
1971:                	 *
1972:                	 * Note:            None
1973:                	 *
1974:                	 * Example:			DmaCrcSetSeed(0xffff);
1975:                	 ********************************************************************/
1976:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetSeed(unsigned int seed)
1977:                	{
1978:                		DCRCDATA=seed;
1979:                	}
1980:                		
1981:                	/*********************************************************************
1982:                	 * Function:        unsigned int DmaCrcGetValue(void)
1983:                	 *
1984:                	 * PreCondition:    None
1985:                	 *
1986:                	 * Input:			None
1987:                	 *
1988:                	 * Output:          the current value of the CRC generator
1989:                	 *
1990:                	 * Side Effects:    None
1991:                	 *
1992:                	 * Overview:		The function returns the current value of the CRC generator.
1993:                	 *
1994:                	 * Note:            Only the remainder bits (0 to pLen-1) are significant, the rest should be ignored.
1995:                	 *
1996:                	 * Example:		unsigned int calcCrc=DmaCrcGetValue();
1997:                	 ********************************************************************/
1998:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetValue(void)
1999:                	{
2000:                		return DCRCDATA;
2001:                	}
2002:                
2003:                
2004:                	// Channel test/debug and special functions
2005:                
2006:                	/*********************************************************************
2007:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2008:                	 *
2009:                	 * PreCondition:    chn	- valid DMA channel
2010:                	 *
2011:                	 * Input:			chn		- DMA channel number
2012:                	 * 					eFlags	- event flags with the following significance:
2013:                	 * 								- DMA_EV_ERR: address error event
2014:                	 * 								- DMA_EV_ABORT: transfer abort event
2015:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2016:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2017:                	 * 								- DMA_EV_DST_HALF: destination half event
2018:                	 * 								- DMA_EV_DST_FULL: destination full event
2019:                	 * 								- DMA_EV_SRC_HALF: source half event
2020:                	 * 								- DMA_EV_SRC_FULL: source full event
2021:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2022:                	 *
2023:                	 * Output:          None
2024:                	 *
2025:                	 * Side Effects:    None
2026:                	 *
2027:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2028:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2029:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2030:                	 *
2031:                	 * Note:            This is intended as a channel test function.
2032:                	 *
2033:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2034:                	 ********************************************************************/
2035:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2036:                
2037:                	/*********************************************************************
2038:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2039:                	 *
2040:                	 * PreCondition:    chn	- valid DMA channel
2041:                	 *
2042:                	 * Input:			chn		- DMA channel number
2043:                	 * 					eFlags	- event flags with the following significance:
2044:                	 * 								- DMA_EV_ERR: address error event
2045:                	 * 								- DMA_EV_ABORT: transfer abort event
2046:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2047:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2048:                	 * 								- DMA_EV_DST_HALF: destination half event
2049:                	 * 								- DMA_EV_DST_FULL: destination full event
2050:                	 * 								- DMA_EV_SRC_HALF: source half event
2051:                	 * 								- DMA_EV_SRC_FULL: source full event
2052:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2053:                	 *
2054:                	 * Output:          None
2055:                	 *
2056:                	 * Side Effects:    None
2057:                	 *
2058:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2059:                	 * 					The channel event flags are forced to the eFlags value.
2060:                	 *
2061:                	 * Note:            This is intended as a channel test function.
2062:                	 *
2063:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2064:                	 ********************************************************************/
2065:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2066:                
2067:                
2068:                	/********************************************************************
2069:                	 * Include legacy DMA functions
2070:                	 * New projects should not use them!
2071:                	 * Note that interrupt functions are no longer provided.
2072:                	 * The functions in the int.h should be used instead.
2073:                	 ********************************************************************/
2074:                	#ifndef _PLIB_DISABLE_LEGACY
2075:                		#include <peripheral/legacy/dma_legacy.h>
2076:                	#endif
2077:                
2078:                	 
2079:                #else
2080:                	#undef _DMA_CHANNELS		// no DMA channels
2081:                #endif	// _DMAC0
2082:                
2083:                #endif /*_DMA_H_*/
2084:                
2085:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0001B8  27BDFFF8   ADDIU SP, SP, -8
9D0001BC  AFBE0004   SW FP, 4(SP)
9D0001C0  03A0F025   OR FP, SP, ZERO
9D0001C4  AFC40008   SW A0, 8(FP)
9D0001C8  AFC5000C   SW A1, 12(FP)
9D0001CC  AFC60010   SW A2, 16(FP)
9D0001D0  3C02BF88   LUI V0, -16504
9D0001D4  24030F00   ADDIU V1, ZERO, 3840
9D0001D8  AC433034   SW V1, 12340(V0)
9D0001DC  8FC2000C   LW V0, 12(FP)
9D0001E0  2442FFFF   ADDIU V0, V0, -1
9D0001E4  00021200   SLL V0, V0, 8
9D0001E8  00401825   OR V1, V0, ZERO
9D0001EC  3C02BF88   LUI V0, -16504
9D0001F0  AC433038   SW V1, 12344(V0)
9D0001F4  3C02BF88   LUI V0, -16504
9D0001F8  8FC30010   LW V1, 16(FP)
9D0001FC  AC433040   SW V1, 12352(V0)
9D000200  3C02BF88   LUI V0, -16504
9D000204  8FC30008   LW V1, 8(FP)
9D000208  AC433050   SW V1, 12368(V0)
9D00020C  00000000   NOP
9D000210  03C0E825   OR SP, FP, ZERO
9D000214  8FBE0004   LW FP, 4(SP)
9D000218  27BD0008   ADDIU SP, SP, 8
9D00021C  03E00008   JR RA
9D000220  00000000   NOP
9D000224  27BDFFF8   ADDIU SP, SP, -8
9D000228  AFBE0004   SW FP, 4(SP)
9D00022C  03A0F025   OR FP, SP, ZERO
9D000230  AFC40008   SW A0, 8(FP)
9D000234  8FC20008   LW V0, 8(FP)
9D000238  10400006   BEQ V0, ZERO, 0x9D000254
9D00023C  00000000   NOP
9D000240  3C02BF88   LUI V0, -16504
9D000244  34038000   ORI V1, ZERO, -32768
9D000248  AC433008   SW V1, 12296(V0)
9D00024C  1000000B   BEQ ZERO, ZERO, 0x9D00027C
9D000250  00000000   NOP
9D000254  3C02BF88   LUI V0, -16504
9D000258  34038000   ORI V1, ZERO, -32768
9D00025C  AC433004   SW V1, 12292(V0)
9D000260  00000000   NOP
9D000264  3C02BF88   LUI V0, -16504
9D000268  8C423000   LW V0, 12288(V0)
9D00026C  7C4203C0   EXT V0, V0, 15, 1
9D000270  304200FF   ANDI V0, V0, 255
9D000274  1440FFFB   BNE V0, ZERO, 0x9D000264
9D000278  00000000   NOP
9D00027C  00000000   NOP
9D000280  03C0E825   OR SP, FP, ZERO
9D000284  8FBE0004   LW FP, 4(SP)
9D000288  27BD0008   ADDIU SP, SP, 8
9D00028C  03E00008   JR RA
9D000290  00000000   NOP
9D000294  27BDFFF0   ADDIU SP, SP, -16
9D000298  AFBE000C   SW FP, 12(SP)
9D00029C  03A0F025   OR FP, SP, ZERO
9D0002A0  3C02BF88   LUI V0, -16504
9D0002A4  8C423000   LW V0, 12288(V0)
9D0002A8  7C420300   EXT V0, V0, 12, 1
9D0002AC  304200FF   ANDI V0, V0, 255
9D0002B0  AFC20000   SW V0, 0(FP)
9D0002B4  8FC20000   LW V0, 0(FP)
9D0002B8  1440000B   BNE V0, ZERO, DmaSuspend
9D0002BC  00000000   NOP
9D0002C0  3C02BF88   LUI V0, -16504
9D0002C4  24031000   ADDIU V1, ZERO, 4096
9D0002C8  AC433008   SW V1, 12296(V0)
9D0002CC  00000000   NOP
9D0002D0  3C02BF88   LUI V0, -16504
9D0002D4  8C423000   LW V0, 12288(V0)
9D0002D8  7C420300   EXT V0, V0, 12, 1
9D0002DC  304200FF   ANDI V0, V0, 255
9D0002E0  1040FFFB   BEQ V0, ZERO, DmaSuspend
9D0002E4  00000000   NOP
9D0002E8  8FC20000   LW V0, 0(FP)
9D0002EC  03C0E825   OR SP, FP, ZERO
9D0002F0  8FBE000C   LW FP, 12(SP)
9D0002F4  27BD0010   ADDIU SP, SP, 16
9D0002F8  03E00008   JR RA
9D0002FC  00000000   NOP
9D000300  27BDFFF0   ADDIU SP, SP, -16
9D000304  AFBE000C   SW FP, 12(SP)
9D000308  03A0F025   OR FP, SP, ZERO
9D00030C  AFC40010   SW A0, 16(FP)
9D000310  8FC20010   LW V0, 16(FP)
9D000314  10400014   BEQ V0, ZERO, DmaResume
9D000318  00000000   NOP
9D00031C  3C02BF88   LUI V0, -16504
9D00032C  AFC20000   SW V0, 0(FP)
9D000330  8FC20000   LW V0, 0(FP)
9D00033C  3C02BF88   LUI V0, -16504
9D000348  3C02BF88   LUI V0, -16504
9D000358  1040FFFB   BEQ V0, ZERO, DmaResume
9D000360  10000004   BEQ ZERO, ZERO, DmaResume
9D000364  00000000   NOP
9D000368  3C02BF88   LUI V0, -16504
9D00036C  24031000   ADDIU V1, ZERO, 4096
9D000370  AC433004   SW V1, 12292(V0)
9D000374  00000000   NOP
9D000378  03C0E825   OR SP, FP, ZERO
9D00037C  8FBE000C   LW FP, 12(SP)
9D000380  27BD0010   ADDIU SP, SP, 16
9D000384  03E00008   JR RA
9D000388  00000000   NOP
9D00038C  27BDFFF8   ADDIU SP, SP, -8
9D000390  AFBE0004   SW FP, 4(SP)
9D000394  03A0F025   OR FP, SP, ZERO
9D000398  AFC40008   SW A0, 8(FP)
9D00039C  3C02BF88   LUI V0, -16504
9D0003A0  8FC30008   LW V1, 8(FP)
9D0003A4  AC433008   SW V1, 12296(V0)
9D0003A8  00000000   NOP
9D0003AC  03C0E825   OR SP, FP, ZERO
9D0003B0  8FBE0004   LW FP, 4(SP)
9D0003B4  27BD0008   ADDIU SP, SP, 8
9D0003B8  03E00008   JR RA
9D0003BC  00000000   NOP
9D0003C0  27BDFFF8   ADDIU SP, SP, -8
9D0003C4  AFBE0004   SW FP, 4(SP)
9D0003C8  03A0F025   OR FP, SP, ZERO
9D0003CC  AFC40008   SW A0, 8(FP)
9D0003D0  3C02BF88   LUI V0, -16504
9D0003D4  8FC30008   LW V1, 8(FP)
9D0003D8  AC433004   SW V1, 12292(V0)
9D0003DC  00000000   NOP
9D0003E0  03C0E825   OR SP, FP, ZERO
9D0003E4  8FBE0004   LW FP, 4(SP)
9D0003E8  27BD0008   ADDIU SP, SP, 8
9D0003EC  03E00008   JR RA
9D0003F0  00000000   NOP
9D0003F4  27BDFFF8   ADDIU SP, SP, -8
9D0003F8  AFBE0004   SW FP, 4(SP)
9D0003FC  03A0F025   OR FP, SP, ZERO
9D000400  AFC40008   SW A0, 8(FP)
9D000404  3C02BF88   LUI V0, -16504
9D000408  8FC30008   LW V1, 8(FP)
9D00040C  AC433000   SW V1, 12288(V0)
9D000410  00000000   NOP
9D000414  03C0E825   OR SP, FP, ZERO
9D000418  8FBE0004   LW FP, 4(SP)
9D00041C  27BD0008   ADDIU SP, SP, 8
9D000420  03E00008   JR RA
9D000424  00000000   NOP
9D000428  27BDFFF8   ADDIU SP, SP, -8
9D00042C  AFBE0004   SW FP, 4(SP)
9D000430  03A0F025   OR FP, SP, ZERO
9D000434  3C02BF88   LUI V0, -16504
9D000438  8C423000   LW V0, 12288(V0)
9D00043C  03C0E825   OR SP, FP, ZERO
9D000440  8FBE0004   LW FP, 4(SP)
9D000444  27BD0008   ADDIU SP, SP, 8
9D000448  03E00008   JR RA
9D00044C  00000000   NOP
9D000450  27BDFFF8   ADDIU SP, SP, -8
9D000454  AFBE0004   SW FP, 4(SP)
9D000458  03A0F025   OR FP, SP, ZERO
9D00045C  24020100   ADDIU V0, ZERO, 256
9D000460  03C0E825   OR SP, FP, ZERO
9D000464  8FBE0004   LW FP, 4(SP)
9D000468  27BD0008   ADDIU SP, SP, 8
9D00046C  03E00008   JR RA
9D000470  00000000   NOP
9D000474  27BDFFF8   ADDIU SP, SP, -8
9D000478  AFBE0004   SW FP, 4(SP)
9D00047C  03A0F025   OR FP, SP, ZERO
9D000480  AFC40008   SW A0, 8(FP)
9D000484  8FC20008   LW V0, 8(FP)
9D000488  10400006   BEQ V0, ZERO, 0x9D0004A4
9D00048C  00000000   NOP
9D000490  3C02BF88   LUI V0, -16504
9D000494  24030080   ADDIU V1, ZERO, 128
9D000498  AC433038   SW V1, 12344(V0)
9D00049C  10000004   BEQ ZERO, ZERO, 0x9D0004B0
9D0004A0  00000000   NOP
9D0004A4  3C02BF88   LUI V0, -16504
9D0004A8  24030080   ADDIU V1, ZERO, 128
9D0004AC  AC433034   SW V1, 12340(V0)
9D0004B0  00000000   NOP
9D0004B4  03C0E825   OR SP, FP, ZERO
9D0004B8  8FBE0004   LW FP, 4(SP)
9D0004BC  27BD0008   ADDIU SP, SP, 8
9D0004C0  03E00008   JR RA
9D0004C4  00000000   NOP
9D0004C8  27BDFFF8   ADDIU SP, SP, -8
9D0004CC  AFBE0004   SW FP, 4(SP)
9D0004D0  03A0F025   OR FP, SP, ZERO
9D0004D4  3C02BF88   LUI V0, -16504
9D0004D8  8C423030   LW V0, 12336(V0)
9D0004DC  7C4201C0   EXT V0, V0, 7, 1
9D0004E0  304200FF   ANDI V0, V0, 255
9D0004E4  03C0E825   OR SP, FP, ZERO
9D0004E8  8FBE0004   LW FP, 4(SP)
9D0004EC  27BD0008   ADDIU SP, SP, 8
9D0004F0  03E00008   JR RA
9D0004F4  00000000   NOP
9D0004F8  27BDFFF8   ADDIU SP, SP, -8
9D0004FC  AFBE0004   SW FP, 4(SP)
9D000500  03A0F025   OR FP, SP, ZERO
9D000504  AFC40008   SW A0, 8(FP)
9D000508  8FC20008   LW V0, 8(FP)
9D00050C  10400006   BEQ V0, ZERO, 0x9D000528
9D000510  00000000   NOP
9D000514  3C02BF88   LUI V0, -16504
9D000518  24030040   ADDIU V1, ZERO, 64
9D00051C  AC433038   SW V1, 12344(V0)
9D000520  10000004   BEQ ZERO, ZERO, 0x9D000534
9D000524  00000000   NOP
9D000528  3C02BF88   LUI V0, -16504
9D00052C  24030040   ADDIU V1, ZERO, 64
9D000530  AC433034   SW V1, 12340(V0)
9D000534  00000000   NOP
9D000538  03C0E825   OR SP, FP, ZERO
9D00053C  8FBE0004   LW FP, 4(SP)
9D000540  27BD0008   ADDIU SP, SP, 8
9D000544  03E00008   JR RA
9D000548  00000000   NOP
9D00054C  27BDFFF8   ADDIU SP, SP, -8
9D000550  AFBE0004   SW FP, 4(SP)
9D000554  03A0F025   OR FP, SP, ZERO
9D000558  3C02BF88   LUI V0, -16504
9D00055C  8C423030   LW V0, 12336(V0)
9D000560  7C420180   EXT V0, V0, 6, 1
9D000564  304200FF   ANDI V0, V0, 255
9D000568  03C0E825   OR SP, FP, ZERO
9D00056C  8FBE0004   LW FP, 4(SP)
9D000570  27BD0008   ADDIU SP, SP, 8
9D000574  03E00008   JR RA
9D000578  00000000   NOP
9D00057C  27BDFFF8   ADDIU SP, SP, -8
9D000580  AFBE0004   SW FP, 4(SP)
9D000584  03A0F025   OR FP, SP, ZERO
9D000588  AFC40008   SW A0, 8(FP)
9D00058C  3C02BF88   LUI V0, -16504
9D000590  24030003   ADDIU V1, ZERO, 3
9D000594  AC433034   SW V1, 12340(V0)
9D000598  3C02BF88   LUI V0, -16504
9D00059C  8FC30008   LW V1, 8(FP)
9D0005A0  AC433038   SW V1, 12344(V0)
9D0005A4  00000000   NOP
9D0005A8  03C0E825   OR SP, FP, ZERO
9D0005AC  8FBE0004   LW FP, 4(SP)
9D0005B0  27BD0008   ADDIU SP, SP, 8
9D0005B4  03E00008   JR RA
9D0005B8  00000000   NOP
9D0005BC  27BDFFF8   ADDIU SP, SP, -8
9D0005C0  AFBE0004   SW FP, 4(SP)
9D0005C4  03A0F025   OR FP, SP, ZERO
9D0005C8  3C02BF88   LUI V0, -16504
9D0005CC  8C423030   LW V0, 12336(V0)
9D0005D0  7C420800   EXT V0, V0, 0, 2
9D0005D4  304200FF   ANDI V0, V0, 255
9D0005D8  03C0E825   OR SP, FP, ZERO
9D0005DC  8FBE0004   LW FP, 4(SP)
9D0005E0  27BD0008   ADDIU SP, SP, 8
9D0005E4  03E00008   JR RA
9D0005E8  00000000   NOP
9D0005EC  27BDFFF8   ADDIU SP, SP, -8
9D0005F0  AFBE0004   SW FP, 4(SP)
9D0005F4  03A0F025   OR FP, SP, ZERO
9D0005F8  AFC40008   SW A0, 8(FP)
9D0005FC  3C02BF88   LUI V0, -16504
9D000600  24030F00   ADDIU V1, ZERO, 3840
9D000604  AC433034   SW V1, 12340(V0)
9D000608  8FC20008   LW V0, 8(FP)
9D00060C  2442FFFF   ADDIU V0, V0, -1
9D000610  00401825   OR V1, V0, ZERO
9D000614  3C02BF88   LUI V0, -16504
9D000618  AC433038   SW V1, 12344(V0)
9D00061C  00000000   NOP
9D000620  03C0E825   OR SP, FP, ZERO
9D000624  8FBE0004   LW FP, 4(SP)
9D000628  27BD0008   ADDIU SP, SP, 8
9D00062C  03E00008   JR RA
9D000630  00000000   NOP
9D000634  27BDFFF8   ADDIU SP, SP, -8
9D000638  AFBE0004   SW FP, 4(SP)
9D00063C  03A0F025   OR FP, SP, ZERO
9D000640  3C02BF88   LUI V0, -16504
9D000644  8C423030   LW V0, 12336(V0)
9D000648  7C421A00   EXT V0, V0, 8, 4
9D00064C  304200FF   ANDI V0, V0, 255
9D000650  24420001   ADDIU V0, V0, 1
9D000654  03C0E825   OR SP, FP, ZERO
9D000658  8FBE0004   LW FP, 4(SP)
9D00065C  27BD0008   ADDIU SP, SP, 8
9D000660  03E00008   JR RA
9D000664  00000000   NOP
9D000668  27BDFFF8   ADDIU SP, SP, -8
9D00066C  AFBE0004   SW FP, 4(SP)
9D000670  03A0F025   OR FP, SP, ZERO
9D000674  AFC40008   SW A0, 8(FP)
9D000678  3C02BF88   LUI V0, -16504
9D00067C  8FC30008   LW V1, 8(FP)
9D000680  AC433050   SW V1, 12368(V0)
9D000684  00000000   NOP
9D000688  03C0E825   OR SP, FP, ZERO
9D00068C  8FBE0004   LW FP, 4(SP)
9D000690  27BD0008   ADDIU SP, SP, 8
9D000694  03E00008   JR RA
9D000698  00000000   NOP
9D00069C  27BDFFF8   ADDIU SP, SP, -8
9D0006A0  AFBE0004   SW FP, 4(SP)
9D0006A4  03A0F025   OR FP, SP, ZERO
9D0006A8  3C02BF88   LUI V0, -16504
9D0006AC  8C423050   LW V0, 12368(V0)
9D0006B0  03C0E825   OR SP, FP, ZERO
9D0006B4  8FBE0004   LW FP, 4(SP)
9D0006B8  27BD0008   ADDIU SP, SP, 8
9D0006BC  03E00008   JR RA
9D0006C0  00000000   NOP
9D0006C4  27BDFFF8   ADDIU SP, SP, -8
9D0006C8  AFBE0004   SW FP, 4(SP)
9D0006CC  03A0F025   OR FP, SP, ZERO
9D0006D0  AFC40008   SW A0, 8(FP)
9D0006D4  3C02BF88   LUI V0, -16504
9D0006D8  8FC30008   LW V1, 8(FP)
9D0006DC  AC433040   SW V1, 12352(V0)
9D0006E0  00000000   NOP
9D0006E4  03C0E825   OR SP, FP, ZERO
9D0006E8  8FBE0004   LW FP, 4(SP)
9D0006EC  27BD0008   ADDIU SP, SP, 8
9D0006F0  03E00008   JR RA
9D0006F4  00000000   NOP
9D0006F8  27BDFFF8   ADDIU SP, SP, -8
9D0006FC  AFBE0004   SW FP, 4(SP)
9D000700  03A0F025   OR FP, SP, ZERO
9D000704  3C02BF88   LUI V0, -16504
9D000708  8C423040   LW V0, 12352(V0)
9D00070C  03C0E825   OR SP, FP, ZERO
9D000710  8FBE0004   LW FP, 4(SP)
9D000714  27BD0008   ADDIU SP, SP, 8
9D000718  03E00008   JR RA
9D00071C  00000000   NOP
9D000C38  3C02BF88   LUI V0, -16504
9D000C48  AFC20020   SW V0, 32(FP)
9D000C4C  8FC20020   LW V0, 32(FP)
9D000C58  3C02BF88   LUI V0, -16504
9D000C64  3C02BF88   LUI V0, -16504
9D000C74  1040FFFB   BEQ V0, ZERO, 0x9D000C64
9D000C7C  8FC20020   LW V0, 32(FP)
9D000CD0  8FC20018   LW V0, 24(FP)
9D000CDC  3C02BF88   LUI V0, -16504
9D000CEC  AFC2001C   SW V0, 28(FP)
9D000CF0  8FC2001C   LW V0, 28(FP)
9D000CFC  3C02BF88   LUI V0, -16504
9D000D08  3C02BF88   LUI V0, -16504
9D000D18  1040FFFB   BEQ V0, ZERO, 0x9D000D08
9D000D28  3C02BF88   LUI V0, -16504
9D000FA4  3C02BF88   LUI V0, -16504
9D000FB4  AFC20020   SW V0, 32(FP)
9D000FB8  8FC20020   LW V0, 32(FP)
9D000FC4  3C02BF88   LUI V0, -16504
9D000FD0  3C02BF88   LUI V0, -16504
9D000FE0  1040FFFB   BEQ V0, ZERO, OSCSetPBDIV
9D000FE8  8FC20020   LW V0, 32(FP)
9D001070  8FC20018   LW V0, 24(FP)
9D001074  10400014   BEQ V0, ZERO, OSCSetPBDIV
9D001078  00000000   NOP
9D00107C  3C02BF88   LUI V0, -16504
9D00108C  AFC2001C   SW V0, 28(FP)
9D001090  8FC2001C   LW V0, 28(FP)
9D00109C  3C02BF88   LUI V0, -16504
9D0010A8  3C02BF88   LUI V0, -16504
9D0010B8  1040FFFB   BEQ V0, ZERO, OSCSetPBDIV
9D0010C8  3C02BF88   LUI V0, -16504
9D0010CC  24031000   ADDIU V1, ZERO, 4096
9D0010D0  AC433004   SW V1, 12292(V0)
9D001164  3C02BF88   LUI V0, -16504
9D001174  AFC20020   SW V0, 32(FP)
9D001178  8FC20020   LW V0, 32(FP)
9D001184  3C02BF88   LUI V0, -16504
9D001190  3C02BF88   LUI V0, -16504
9D0011A0  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPB
9D0011A8  8FC20020   LW V0, 32(FP)
9D001230  8FC20028   LW V0, 40(FP)
9D00123C  3C02BF88   LUI V0, -16504
9D00124C  AFC2002C   SW V0, 44(FP)
9D001250  8FC2002C   LW V0, 44(FP)
9D00125C  3C02BF88   LUI V0, -16504
9D001268  3C02BF88   LUI V0, -16504
9D001278  1040FFFB   BEQ V0, ZERO, SYSTEMConfigPB
9D001288  3C02BF88   LUI V0, -16504
9D0013C4  3C02BF88   LUI V0, -16504
9D0013D4  AFC20030   SW V0, 48(FP)
9D0013D8  8FC20030   LW V0, 48(FP)
9D0013E4  3C02BF88   LUI V0, -16504
9D0013F0  3C02BF88   LUI V0, -16504
9D001400  1040FFFB   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D001408  8FC20030   LW V0, 48(FP)
9D001490  8FC20038   LW V0, 56(FP)
9D00149C  3C02BF88   LUI V0, -16504
9D0014AC  AFC2003C   SW V0, 60(FP)
9D0014B0  8FC2003C   LW V0, 60(FP)
9D0014BC  3C02BF88   LUI V0, -16504
9D0014C8  3C02BF88   LUI V0, -16504
9D0014D8  1040FFFB   BEQ V0, ZERO, SYSTEMConfigWaitStatesAndPB
9D0014E8  3C02BF88   LUI V0, -16504
9D001604  3C02BF88   LUI V0, -16504
9D001614  AFC20034   SW V0, 52(FP)
9D001618  8FC20034   LW V0, 52(FP)
9D001624  3C02BF88   LUI V0, -16504
9D001630  3C02BF88   LUI V0, -16504
9D001640  1040FFFB   BEQ V0, ZERO, 0x9D001630
9D001648  8FC20034   LW V0, 52(FP)
9D0016D0  8FC2003C   LW V0, 60(FP)
9D0016DC  3C02BF88   LUI V0, -16504
9D0016EC  AFC20040   SW V0, 64(FP)
9D0016F0  8FC20040   LW V0, 64(FP)
9D0016FC  3C02BF88   LUI V0, -16504
9D001708  3C02BF88   LUI V0, -16504
9D001718  1040FFFB   BEQ V0, ZERO, 0x9D001708
9D001728  3C02BF88   LUI V0, -16504
9D001940  3C02BF88   LUI V0, -16504
9D001950  AFC2003C   SW V0, 60(FP)
9D001954  8FC2003C   LW V0, 60(FP)
9D001960  3C02BF88   LUI V0, -16504
9D00196C  3C02BF88   LUI V0, -16504
9D00197C  1040FFFB   BEQ V0, ZERO, 0x9D00196C
9D001984  8FC2003C   LW V0, 60(FP)
9D001A0C  8FC20044   LW V0, 68(FP)
9D001A18  3C02BF88   LUI V0, -16504
9D001A28  AFC20048   SW V0, 72(FP)
9D001A2C  8FC20048   LW V0, 72(FP)
9D001A38  3C02BF88   LUI V0, -16504
9D001A44  3C02BF88   LUI V0, -16504
9D001A54  1040FFFB   BEQ V0, ZERO, 0x9D001A44
9D001A64  3C02BF88   LUI V0, -16504
---  C:/Program Files/Microchip/MPLABX/v6.00/packs/Microchip/PIC32MX_DFP/1.5.259/xc32/startup/crt0.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     * Publication is not required when this file is used in an embedded 
                                                  32:     * application.
                                                  33:     *
                                                  34:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  35:     * derived from this software without specific prior written permission.
                                                  36:     *
                                                  37:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  38:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  39:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  40:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  41:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  42:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  43:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  44:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  45:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  46:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  47:     *
                                                  48:     ********************************************************************/
                                                  49:    
                                                  50:    #include "xc.h"
                                                  51:    #include <cp0defs.h>
                                                  52:    
                                                  53:    #ifdef __LIBBUILD__
                                                  54:       # Replace the standard debugging information with a simple filename. This
                                                  55:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  56:       # also effectively disables source-line debugging.
                                                  57:       .file 1 "libpic32/startup/crt0.S"
                                                  58:       .loc 1 0
                                                  59:    #endif
                                                  60:    
                                                  61:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  62:    #define CPP_INIT
                                                  63:    #endif
                                                  64:    
                                                  65:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  66:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  67:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  68:    #  else
                                                  69:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  70:    #    define PIC32_SRS_SET_COUNT 2
                                                  71:    #  endif
                                                  72:    #endif
                                                  73:    
                                                  74:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  75:    #define INIT_DATA 1
                                                  76:    #endif
                                                  77:    
                                                  78:    /* This file contains 32-bit assembly code */
                                                  79:           .set nomips16
                                                  80:    
                                                  81:            ##################################################################
                                                  82:            # Entry point of the entire application
                                                  83:            ##################################################################
                                                  84:            .section .reset,code,keep
                                                  85:            .align 2
                                                  86:            .set noreorder
                                                  87:            .ent _reset
                                                  88:    
                                                  89:    ############################
                                                  90:    # Begin ISA switching code #
                                                  91:    ############################
                                                  92:    
                                                  93:    #if defined (__mips_micromips)
                                                  94:            .set micromips
                                                  95:    #endif
                                                  96:    
                                                  97:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  98:    _reset:
                                                  99:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  100:                                /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  101:                                /* DO NOT change the relative branch               */
                                                  102:   
                                                  103:           .word 0x00000000     /* NOP */
                                                  104:   __reset_micromips_isa:
                                                  105:           .set    micromips
                                                  106:           jal     _startup
                                                  107:           nop
                                                  108:   
                                                  109:           .align 2
                                                  110:           /* Device not in proper ISA mode */
                                                  111:           .set nomicromips
                                                  112:   __reset_switch_isa:
                                                  113:           jal _startup
                                                  114:           nop
                                                  115:   
                                                  116:   #else
                                                  117:   
                                                  118:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               119:           jal _startup
BFC00004  00000000   NOP                          120:           nop
                                                  121:   
                                                  122:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  123:   
                                                  124:           .align 2
                                                  125:           .end _reset
                                                  126:           .globl _reset
                                                  127:           .size _reset, .-_reset
                                                  128:   
                                                  129:           .section .reset.startup,code,keep
                                                  130:           .align 2
                                                  131:           .set noreorder
                                                  132:   
                                                  133:   #if defined (__mips_micromips)
                                                  134:           .set micromips
                                                  135:   #else
                                                  136:           .set nomicromips
                                                  137:   #endif
                                                  138:   
                                                  139:   ############################
                                                  140:   # End ISA switching code   #
                                                  141:   ############################
                                                  142:   
                                                  143:           ##################################################################
                                                  144:           # Startup code
                                                  145:           ##################################################################
                                                  146:           .align 2
                                                  147:           .globl _startup
                                                  148:           .set noreorder
                                                  149:           .ent _startup
                                                  150:   _startup:
                                                  151:           ##################################################################
                                                  152:           # If entered because of an NMI, jump to the NMI handler.
                                                  153:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              154:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            155:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     156:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          157:           nop
BFC00018  3C1A9D00   LUI K0, -25344               158:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        159:           jr      k0
BFC00024  00000000   NOP                          160:           nop
                                                  161:   _no_nmi:
                                                  162:   
                                                  163:           ##################################################################
                                                  164:           # Initialize Stack Pointer
                                                  165:           #   _stack is initialized by the linker script to point to the
                                                  166:           #    starting location of the stack in DRM
                                                  167:           ##################################################################
BFC00028  3C1DA000   LUI SP, -24576               168:           la      sp,_stack
                                                  169:   
                                                  170:           ##################################################################
                                                  171:           # Initialize Global Pointer
                                                  172:           #   _gp is initialized by the linker script to point to "middle"
                                                  173:           #   of the small variables region
                                                  174:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               175:           la      gp,_gp
                                                  176:   
                                                  177:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  178:           ##################################################################
                                                  179:           # Initialize Global Pointer in Shadow Set
                                                  180:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  181:           #   to initialize the global pointer.  Since we have only a
                                                  182:           #   single shadow set (besides the normal), we will initialize
                                                  183:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  184:           #   to the previous shadow set to ensure that on interrupt, the
                                                  185:           #   global pointer has been initialized.
                                                  186:           ##################################################################
BFC00038  40096002   MFC0 T1, SRSCtl              187:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
BFC0003C  01205820   ADD T3, T1, ZERO             188:           add     t3,t1,zero              # Save off current SRSCtl
BFC00040  7D2A1E80   EXT T2, T1, 26, 4            189:           ext     t2,t1,26,4              # to obtain HSS field
BFC00044  7D494984   INS T1, T2, 6, 4             190:           ins     t1,t2,6,4               # Put HSS field
BFC00048  40896002   MTC0 T1, SRSCtl              191:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
BFC0004C  000000C0   EHB                          192:           ehb                             # Clear hazard before using new SRSCTL
BFC00050  41DCE000   WRPGPR GP, GP                193:           wrpgpr  gp,gp                   # Set global pointer in PSS
BFC00054  408B6002   MTC0 T3, SRSCtl              194:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
BFC00058  000000C0   EHB                          195:           ehb
                                                  196:   
                                                  197:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  198:           ##################################################################
                                                  199:           # Initialize Global Pointer in Shadow Set(s)
                                                  200:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  201:           #   to initialize the global pointer.  We will initialize
                                                  202:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  203:           #   We write the global pointer to the previous shadow set to
                                                  204:           #   ensure that on interrupt, the global pointer has been
                                                  205:           #   initialized.
                                                  206:           ##################################################################
                                                  207:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  208:           add     t3,t1,zero              # Save off current SRSCtl
                                                  209:   
                                                  210:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  211:   
                                                  212:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  213:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  214:           ehb                             # Clear hazard before using new SRSCTL
                                                  215:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  216:   
                                                  217:           addiu   t2,t2,-1                # Next lower shadow set
                                                  218:                                           # Loop for all sets
                                                  219:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  220:           nop
                                                  221:   
                                                  222:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  223:           ehb
                                                  224:   
                                                  225:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  226:   
                                                  227:           ##################################################################
                                                  228:           # Call the "on reset" procedure
                                                  229:           ##################################################################
BFC0005C  3C089D00   LUI T0, -25344               230:           la      t0,_on_reset
BFC00064  0100F809   JALR T0                      231:           jalr    t0
BFC00068  00000000   NOP                          232:           nop
                                                  233:   
                                                  234:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  235:           ##################################################################
                                                  236:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  237:           ##################################################################
                                                  238:           .extern __pic32_tlb_init_ebi_sqi
                                                  239:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  240:           jalr    t0
                                                  241:           nop
                                                  242:   #endif
                                                  243:   
                                                  244:           ##################################################################
                                                  245:           # Clear uninitialized data sections
                                                  246:           ##################################################################
                                                  247:   _start_bss_init:
BFC0006C  3C08A000   LUI T0, -24576               248:           la      t0,_bss_begin
BFC00074  3C09A000   LUI T1, -24576               249:           la      t1,_bss_end
BFC0007C  10000003   BEQ ZERO, ZERO, 0xBFC0008C   250:           b       _bss_check
BFC00080  00000000   NOP                          251:           nop
                                                  252:   
                                                  253:   _bss_init:
BFC00084  AD000000   SW ZERO, 0(T0)               254:           sw      zero,0x0(t0)
BFC00088  25080004   ADDIU T0, T0, 4              255:           addu    t0,4
                                                  256:   _bss_check:
BFC0008C  0109082B   SLTU AT, T0, T1              257:           bltu    t0,t1,_bss_init
BFC00094  00000000   NOP                          258:           nop
                                                  259:   
                                                  260:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  261:           ##################################################################
                                                  262:           # Initialize L1 cache. This must be done after bss clearing
                                                  263:           # since the _bss_end symbol may not be cache-line aligned.
                                                  264:           ##################################################################
                                                  265:           .extern   __pic32_init_cache
                                                  266:           la      t0,__pic32_init_cache
                                                  267:           jalr    t0
                                                  268:           nop
                                                  269:   #endif
                                                  270:   
                                                  271:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  272:   
                                                  273:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  274:   
                                                  275:           ##################################################################
                                                  276:           # Initialize data using the linker-generated .dinit table
                                                  277:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  278:           ##################################################################
                                                  279:           .equiv FMT_CLEAR,0
                                                  280:           .equiv FMT_COPY,1
                                                  281:   _dinit_init:
                                                  282:           la      t0,_dinit_addr
                                                  283:   
                                                  284:   #define SRC t0
                                                  285:   #define DST t1
                                                  286:   #define LEN t2
                                                  287:   #define FMT t3
                                                  288:   
                                                  289:   0:      lw      DST,0(SRC)
                                                  290:           beqz    DST,9f
                                                  291:           addu    SRC,4
                                                  292:           lw      LEN,0(SRC)
                                                  293:           addu    SRC,4
                                                  294:           lw      FMT,0(SRC)
                                                  295:           beq     FMT,$0,_dinit_clear
                                                  296:           addu    SRC,4
                                                  297:   
                                                  298:   _dinit_copy:
                                                  299:           lbu     t4,0(SRC)
                                                  300:           subu    LEN,1
                                                  301:           addu    SRC,1
                                                  302:           sb      t4,0(DST)
                                                  303:           bne     LEN,$0,_dinit_copy
                                                  304:           addu    DST,1
                                                  305:   
                                                  306:           b       _dinit_end
                                                  307:           nop
                                                  308:   
                                                  309:   _dinit_clear:
                                                  310:           sb      $0,(DST)
                                                  311:           subu    LEN,1
                                                  312:           bne     LEN,$0,_dinit_clear
                                                  313:           addu    DST,1
                                                  314:   
                                                  315:   _dinit_end:
                                                  316:           addu    SRC,3
                                                  317:           addiu   LEN,$0,-4
                                                  318:           and     SRC,LEN,SRC
                                                  319:           lw      DST,0(SRC)
                                                  320:           bne     DST,$0,0b
                                                  321:           nop
                                                  322:   9:
                                                  323:   
                                                  324:   #else
                                                  325:           #####################################################################
                                                  326:           # Initialize data using the linker-generated .dinit table
                                                  327:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  328:           # packaged with the compiler rather than the DFP. Use that init
                                                  329:           # code instead.
                                                  330:           #####################################################################
                                                  331:           .extern   __pic32_data_init
BFC00098  3C089D00   LUI T0, -25344               332:           la      t0, __pic32_data_init
BFC000A0  0100F809   JALR T0                      333:           jalr    t0
BFC000A4  00000000   NOP                          334:           nop
                                                  335:   
                                                  336:   #if defined(_OFF168_VOFF_POSITION)
                                                  337:           lui	t1,%hi(OFF168)
                                                  338:           lui	t2,%hi(__vector_offset_168)
                                                  339:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  340:           sw	t2,%lo(OFF168)(t1)
                                                  341:   #endif
                                                  342:   
                                                  343:   #endif /* __LIBBUILD__ */
                                                  344:   
                                                  345:   #endif /* INIT_DATA */
                                                  346:   
                                                  347:           ##################################################################
                                                  348:           # If there are no RAM functions, skip the next section --
                                                  349:           # initializing bus matrix registers.
                                                  350:           ##################################################################
BFC000A8  3C090000   LUI T1, 0                    351:           la      t1,_ramfunc_begin
BFC000B0  11200010   BEQ T1, ZERO, 0xBFC000F4     352:           beqz    t1,_ramfunc_done
BFC000B4  00000000   NOP                          353:           nop
                                                  354:   
                                                  355:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  356:     /* No initialization required */
                                                  357:   #else /* Use BMX */
                                                  358:           ##################################################################
                                                  359:           # Initialize bus matrix registers if RAM functions exist in the
                                                  360:           # application
                                                  361:           ##################################################################
BFC000B8  3C090001   LUI T1, 1                    362:           la      t1,_bmxdkpba_address
BFC000C0  3C0ABF88   LUI T2, -16504               363:           la      t2,BMXDKPBA
BFC000C8  AD490000   SW T1, 0(T2)                 364:           sw      t1,0(t2)
BFC000CC  3C090001   LUI T1, 1                    365:           la      t1,_bmxdudba_address
BFC000D4  3C0ABF88   LUI T2, -16504               366:           la      t2,BMXDUDBA
BFC000DC  AD490000   SW T1, 0(T2)                 367:           sw      t1,0(t2)
BFC000E0  3C090001   LUI T1, 1                    368:           la      t1,_bmxdupba_address
BFC000E8  3C0ABF88   LUI T2, -16504               369:           la      t2,BMXDUPBA
BFC000F0  AD490000   SW T1, 0(T2)                 370:           sw      t1,0(t2)
                                                  371:   #endif /* INIT_SSX */
                                                  372:   
                                                  373:   _ramfunc_done:
                                                  374:   
                                                  375:           ##################################################################
                                                  376:           # Initialize CP0 registers
                                                  377:           ##################################################################
                                                  378:           # Initialize Count register
                                                  379:           ##################################################################
BFC000F4  40804800   MTC0 ZERO, Count             380:           mtc0    zero,_CP0_COUNT
                                                  381:   
                                                  382:           ##################################################################
                                                  383:           # Initialize Compare register
                                                  384:           ##################################################################
BFC000F8  240AFFFF   ADDIU T2, ZERO, -1           385:           li      t2,-1
BFC000FC  408A5800   MTC0 T2, Compare             386:           mtc0    t2,_CP0_COMPARE
                                                  387:   
                                                  388:           ##################################################################
                                                  389:           # Ensure BEV set and Initialize EBase register
                                                  390:           ##################################################################
BFC00100  3C080040   LUI T0, 64                   391:           li      t0, (1<<22)
BFC00104  400A6000   MFC0 T2, Status              392:           mfc0    t2,_CP0_STATUS
BFC00108  010A5025   OR T2, T0, T2                393:           or      t2,t0,t2               # Set BEV bit 22
BFC0010C  408A6000   MTC0 T2, Status              394:           mtc0    t2,_CP0_STATUS
                                                  395:   
BFC00110  3C099FC0   LUI T1, -24640               396:           la      t1,_ebase_address
BFC00118  000000C0   EHB                          397:           ehb
BFC0011C  40897801   MTC0 T1, EBase               398:           mtc0    t1,_CP0_EBASE
                                                  399:           
                                                  400:           ##################################################################
                                                  401:           # Initialize PRISS register to a safer default for devices that 
                                                  402:           # have it. The application should re-initialize it to an
                                                  403:           # application-specific value.
                                                  404:           #
                                                  405:           # We do NOT do this by default.
                                                  406:           ##################################################################
                                                  407:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  408:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  409:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  410:           li	    t2, 0x76540000
                                                  411:           addiu	t2, t2, 0x3210
                                                  412:           lui	    t1, %hi(PRISS)
                                                  413:           sw	    t2, %lo(PRISS)(t1)
                                                  414:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  415:           li	    t2, 0x10000000
                                                  416:           lui	    t1, %hi(PRISS)
                                                  417:           sw	    t2, %lo(PRISS)(t1)
                                                  418:   #endif /* PIC32_SRS_SET_COUNT */
                                                  419:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  420:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  421:           
                                                  422:           ##################################################################
                                                  423:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  424:           ##################################################################
BFC00120  3C090000   LUI T1, 0                    425:           la      t1,_vector_spacing
                                                  426:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  427:           la      t0, INTCON
                                                  428:           lw      t2, 0(t0)
                                                  429:           li      t2, 0
                                                  430:           ins     t2, t1, 16, 7
                                                  431:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  432:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  433:   #endif
                                                  434:           sw      t2, 0(t0)
                                                  435:   #endif
BFC00128  240A0000   ADDIU T2, ZERO, 0            436:           li      t2,0                    # Clear t2 and
BFC0012C  7D2A4944   INS T2, T1, 5, 5             437:           ins     t2,t1,5,5               # shift value to VS field
BFC00130  408A6001   MTC0 T2, IntCtl              438:           mtc0    t2,_CP0_INTCTL
                                                  439:   
                                                  440:           ##################################################################
                                                  441:           # Initialize CAUSE registers
                                                  442:           # - Enable counting of Count register <DC = 0>
                                                  443:           # - Use special exception vector <IV = 1>
                                                  444:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  445:           ##################################################################
BFC00134  3C090080   LUI T1, 128                  446:           li      t1,0x00800000
BFC00138  40896800   MTC0 T1, Cause               447:           mtc0    t1,_CP0_CAUSE
                                                  448:   
                                                  449:           ##################################################################
                                                  450:           # Initialize STATUS register
                                                  451:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  452:           # - User mode uses configured endianness <RE = 0>
                                                  453:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  454:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  455:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  456:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  457:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  458:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  459:           # - Base mode is Kernel mode <UM = 0>
                                                  460:           # - Error level is normal <ERL = 0>
                                                  461:           # - Exception level is normal <EXL = 0>
                                                  462:           # - Interrupts are disabled <IE = 0>
                                                  463:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  464:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  465:           ##################################################################
BFC0013C  40088000   MFC0 T0, Config              466:           mfc0    t0,_CP0_CONFIG
BFC00140  7D090580   EXT T1, T0, 22, 1            467:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00144  00094C40   SLL T1, T1, 17               468:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00148  40086000   MFC0 T0, Status              469:           mfc0    t0,_CP0_STATUS
BFC0014C  3C010058   LUI AT, 88                   470:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  471:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  472:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  473:           or      t0,t2,t0
                                                  474:   #endif
                                                  475:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  476:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  477:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  478:   #endif
                                                  479:   
BFC00154  01284025   OR T0, T1, T0                480:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00158  40886000   MTC0 T0, Status              481:           mtc0    t0,_CP0_STATUS
                                                  482:           
                                                  483:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  484:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  485:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  486:           li      t1,0x10000              # ISAONEXEC bit
                                                  487:           mfc0    t0,_CP0_CONFIG3
                                                  488:           or      t1,t0,t1
                                                  489:           mtc0    t1,_CP0_CONFIG3
                                                  490:   
                                                  491:   #endif /* PIC32WK && __mips_micromips */
                                                  492:   
                                                  493:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  494:                                           # FPU Control and Status
                                                  495:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  496:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  497:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  498:   #endif
BFC0015C  000000C0   EHB                          499:           ehb
                                                  500:   
                                                  501:           ##################################################################
                                                  502:           # Call the "on bootstrap" procedure
                                                  503:           ##################################################################
BFC00160  3C089D00   LUI T0, -25344               504:           la      t0,_on_bootstrap
BFC00168  0100F809   JALR T0                      505:           jalr    t0
BFC0016C  00000000   NOP                          506:           nop
                                                  507:   
                                                  508:           ##################################################################
                                                  509:           # Initialize Status<BEV> for normal exception vectors
                                                  510:           ##################################################################
BFC00170  40086000   MFC0 T0, Status              511:           mfc0    t0,_CP0_STATUS
BFC00174  3C01FFBF   LUI AT, -65                  512:           and     t0,t0,0xffbfffff        # Clear BEV
BFC00180  40886000   MTC0 T0, Status              513:           mtc0    t0,_CP0_STATUS
                                                  514:   
                                                  515:           ##################################################################
                                                  516:           # Call main. We do this via a thunk in the text section so that
                                                  517:           # a normal jump and link can be used, enabling the startup code
                                                  518:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  519:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  520:           # necessary
                                                  521:           ##################################################################
BFC00184  30840000   ANDI A0, A0, 0               522:           and     a0,a0,0
BFC00188  30A50000   ANDI A1, A1, 0               523:           and     a1,a1,0
BFC0018C  3C089D00   LUI T0, -25344               524:           la      t0,_main_entry
BFC00194  01000008   JR T0                        525:           jr      t0
BFC00198  00000000   NOP                          526:           nop
                                                  527:   
                                                  528:           .end _startup
                                                  529:   
                                                  530:           ##################################################################
                                                  531:           # Boot Exception Vector Handler
                                                  532:           # Jumps to _bootstrap_exception_handler
                                                  533:           ##################################################################
                                                  534:           .section .bev_handler,code,keep
                                                  535:           .align 2
                                                  536:           .set noreorder
                                                  537:           .ent _bev_exception
                                                  538:   _bev_exception:
BFC00380  3C1A9D00   LUI K0, -25344               539:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        540:           jr        k0
BFC0038C  00000000   NOP                          541:           nop
                                                  542:   
                                                  543:           .end _bev_exception
                                                  544:   
                                                  545:           ##################################################################
                                                  546:           # General Exception Vector Handler
                                                  547:           # Jumps to _general_exception_context
                                                  548:           ##################################################################
                                                  549:           .section .gen_handler,code
                                                  550:           .align 2
                                                  551:           .set noreorder
                                                  552:           .ent _gen_exception
                                                  553:   _gen_exception:
9FC01180  3C1A9D00   LUI K0, -25344               554:   0:      la      k0,_general_exception_context
9FC01188  03400008   JR K0                        555:           jr      k0
9FC0118C  00000000   NOP                          556:           nop
                                                  557:   
                                                  558:           .end _gen_exception
                                                  559:   
                                                  560:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  561:           ##################################################################
                                                  562:           # Simple TLB-Refill Exception Vector
                                                  563:           # Jumps to _simple_tlb_refill_exception_context
                                                  564:           ##################################################################
                                                  565:           .section .simple_tlb_refill_vector,code,keep
                                                  566:           .align 2
                                                  567:           .set noreorder
                                                  568:           .ent simple_tlb_refill_vector
                                                  569:   simple_tlb_refill_vector:
                                                  570:           la      k0,_simple_tlb_refill_exception_context
                                                  571:           jr      k0
                                                  572:           nop
                                                  573:   
                                                  574:           .end simple_tlb_refill_vector
                                                  575:   #endif
                                                  576:   
                                                  577:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  578:           ##################################################################
                                                  579:           # Cache-Error Exception Vector Handler
                                                  580:           # Jumps to _cache_err_exception_context
                                                  581:           ##################################################################
                                                  582:           .section .cache_err_vector,code,keep
                                                  583:           .align 2
                                                  584:           .set noreorder
                                                  585:           .ent _cache_err_vector
                                                  586:   _cache_err_vector:
                                                  587:           la      k0,_cache_err_exception_context
                                                  588:           jr      k0
                                                  589:           nop
                                                  590:   
                                                  591:           .end _cache_err_vector
                                                  592:   #endif
                                                  593:   
                                                  594:           .section .text.main_entry,code,keep
                                                  595:           .align 2
                                                  596:           .ent _main_entry
                                                  597:   _main_entry:
                                                  598:   
                                                  599:   #if defined(CPP_INIT)
                                                  600:           .weak _init
                                                  601:           # call .init section to run constructors etc
9D002484  3C040000   LUI A0, 0                    602:           lui	a0,%hi(_init)
9D002488  27BDFFE8   ADDIU SP, SP, -24            603:           addiu	sp,sp,-24
9D00248C  24840000   ADDIU A0, A0, 0              604:           addiu	a0,a0,%lo(_init)
9D002490  10800003   BEQ A0, ZERO, 0x9D0024A0     605:           beq	a0,$0,2f
9D002494  AFBF0014   SW RA, 20(SP)                606:           sw	$31,20(sp)	 #,
9D002498  0080F809   JALR A0                      607:           jalr	a0
9D00249C  00000000   NOP                          608:           nop
                                                  609:   2:
                                                  610:   #endif
9D0024A0  30840000   ANDI A0, A0, 0               611:           and     a0,a0,0
9D0024A4  30A50000   ANDI A1, A1, 0               612:           and     a1,a1,0
                                                  613:   
                                                  614:           ##################################################################
                                                  615:   
                                                  616:           # Call main
                                                  617:           ##################################################################
9D0024A8  3C089D00   LUI T0, -25344               618:           la    	t0,main
9D0024B0  0100F809   JALR T0                      619:           jalr 	t0
9D0024B4  00000000   NOP                          620:           nop
                                                  621:   
                                                  622:   #if defined(CALL_EXIT)
                                                  623:           ##################################################################
                                                  624:           # Call exit()
                                                  625:           ##################################################################
                                                  626:           jal exit
                                                  627:           nop
                                                  628:   #endif
                                                  629:   
                                                  630:           ##################################################################
                                                  631:           # Just in case, go into infinite loop
                                                  632:           # Call a software breakpoint only with -mdebugger compiler option
                                                  633:           ##################################################################
                                                  634:           .weak __exception_handler_break
                                                  635:   __crt0_exit:
                                                  636:   1:
9D0024B8  3C029D00   LUI V0, -25344               637:           la      v0,__exception_handler_break
9D0024C0  10400003   BEQ V0, ZERO, 0x9D0024D0     638:           beq     v0,0,0f
9D0024C4  00000000   NOP                          639:           nop
9D0024C8  0040F809   JALR V0                      640:           jalr    v0
9D0024CC  00000000   NOP                          641:           nop
                                                  642:   
9D0024D0  1000FFF9   BEQ ZERO, ZERO, 0x9D0024B8   643:   0:      b       1b
9D0024D4  00000000   NOP                          644:           nop
                                                  645:   
                                                  646:           .globl __crt0_exit
                                                  647:           .end _main_entry
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-reset.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00281C  03E00008   JR RA
9D002820  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-bootstrap.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D002824  03E00008   JR RA
9D002828  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-general-exception-handler.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D002520  3C020000   LUI V0, 0
9D002524  24420001   ADDIU V0, V0, 1
9D002528  10400005   BEQ V0, ZERO, 0x9D002540
9D00252C  3C029D00   LUI V0, -25344
9D002530  24422810   ADDIU V0, V0, 10256
9D002534  10400003   BEQ V0, ZERO, 0x9D002544
9D002538  3C029D00   LUI V0, -25344
9D00253C  7000003F   SDBBP 0
9D002540  3C029D00   LUI V0, -25344
9D002544  244225B0   ADDIU V0, V0, 9648
9D002548  10400005   BEQ V0, ZERO, 0x9D002560
9D00254C  00000000   NOP
9D002550  27BDFFE8   ADDIU SP, SP, -24
9D002554  AFBF0014   SW RA, 20(SP)
9D002558  0040F809   JALR V0
9D00255C  00000000   NOP
9D002560  1000FFFF   BEQ ZERO, ZERO, 0x9D002560
9D002564  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-bootstrap-exception-handler.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0024D8  3C020000   LUI V0, 0
9D0024DC  24420001   ADDIU V0, V0, 1
9D0024E0  10400005   BEQ V0, ZERO, 0x9D0024F8
9D0024E4  3C029D00   LUI V0, -25344
9D0024E8  24422810   ADDIU V0, V0, 10256
9D0024EC  10400003   BEQ V0, ZERO, 0x9D0024FC
9D0024F0  3C029D00   LUI V0, -25344
9D0024F4  7000003F   SDBBP 0
9D0024F8  3C029D00   LUI V0, -25344
9D0024FC  244225B0   ADDIU V0, V0, 9648
9D002500  10400005   BEQ V0, ZERO, 0x9D002518
9D002504  00000000   NOP
9D002508  27BDFFE8   ADDIU SP, SP, -24
9D00250C  AFBF0014   SW RA, 20(SP)
9D002510  0040F809   JALR V0
9D002514  00000000   NOP
9D002518  1000FFFF   BEQ ZERO, ZERO, 0x9D002518
9D00251C  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/startup/software-debug-break.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D002810  7000003F   SDBBP 0
9D002814  03E00008   JR RA
9D002818  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PMB4100-JOB1/build-Linux/pic32m-libs/libpic32/default_vector_dispatch/defaultinterrupt.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D002568  3C020000   LUI V0, 0
9D00256C  24420001   ADDIU V0, V0, 1
9D002570  10400007   BEQ V0, ZERO, 0x9D002590
9D002574  3C029D00   LUI V0, -25344
9D002578  24422810   ADDIU V0, V0, 10256
9D00257C  50400005   BEQL V0, ZERO, 0x9D002594
9D002580  3C029D00   LUI V0, -25344
9D002584  7000003F   SDBBP 0
9D002588  03E00008   JR RA
9D00258C  00000000   NOP
9D002590  3C029D00   LUI V0, -25344
9D002594  244225B0   ADDIU V0, V0, 9648
9D002598  10400003   BEQ V0, ZERO, 0x9D0025A8
9D00259C  00000000   NOP
9D0025A0  0040F809   JALR V0
9D0025A4  00000000   NOP
9D0025A8  03E00008   JR RA
9D0025AC  00000000   NOP
